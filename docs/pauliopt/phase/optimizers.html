<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>pauliopt.phase.optimizers API documentation</title>
<meta name="description" content="This module contains code to optimize circuits of mixed ZX phase gadgets
using topologically-aware circuits of CNOTs." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pauliopt.phase.optimizers</code></h1>
</header>
<section id="section-intro">
<p>This module contains code to optimize circuits of mixed ZX phase gadgets
using topologically-aware circuits of CNOTs.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
    This module contains code to optimize circuits of mixed ZX phase gadgets
    using topologically-aware circuits of CNOTs.
&#34;&#34;&#34;

from collections import deque
from math import log
from typing import (Collection, Deque, Dict, FrozenSet, Optional, Protocol,
                    runtime_checkable, Sequence, Set, Tuple, TypedDict, Union)
import numpy as np # type: ignore
from pauliopt.phase.circuits import (PhaseGadget, PhaseCircuit, PhaseCircuitView,
                                     CXCircuitLayer, CXCircuit, CXCircuitView)
from pauliopt.topologies import Coupling, Topology
from pauliopt.utils import Number, TempSchedule

@runtime_checkable
class CostFun(Protocol):
    &#34;&#34;&#34;
        Protocol for a cost function.
        The cost is a `float` or `int` computed from the phase block (readonly view)
        and CX block (readonly view) exposed by an instance of `PhaseCircuitOptimizer`.
    &#34;&#34;&#34;

    def __call__(self, phase_block: PhaseCircuitView, cx_block: CXCircuitView) -&gt; Number:
        ...

class _WeightFun(Protocol):
    def __call__(self, fro: int, to: int) -&gt; Number:
        ...

def _prim_algorithm_debug(nodes: Collection[int], weight: _WeightFun,
                          inf: Number) -&gt; Tuple[Sequence[Number], Sequence[Tuple[int, int]]]:
    &#34;&#34;&#34;
        Computes the weight of the minimum spanning tree connecting
        the given nodes, using the given weight function for branches.
        The number `inf` should be larger than the maximum weight
        that can be encountered in the process.

        Returns the list of weights for the individual branches in such
        a minimum spanning tree the list of branches defining the tree itself.
    &#34;&#34;&#34;
    if not nodes:
        return [], []
    mst_lengths = []
    mst = []
    # Initialise set of nodes to visit:
    to_visit = set(nodes)
    n0 = next(iter(to_visit))
    to_visit.remove(n0)
    # Initialise dict of distances from visited set:
    dist_from_visited = {
        n: weight(n0, n) for n in nodes
    }
    edge_from_visited: Dict[int, Tuple[int, int]] = {
        n: (n0, n) for n in nodes
    }
    while to_visit:
        # Look for the node to be visited which is nearest to the visited set:
        nearest_node = 0 # dummy value
        nearest_dist = inf # dummy value
        for n in to_visit:
            n_dist = dist_from_visited[n]
            if n_dist &lt; nearest_dist:
                nearest_node = n
                nearest_dist = n_dist
        # Nearest node is removed and added to the MST:
        to_visit.remove(nearest_node)
        mst_lengths.append(nearest_dist)
        mst.append(edge_from_visited[nearest_node])
        # Update shortest distances to visited set:
        for n in to_visit:
            dist_nearest_n = weight(nearest_node, n)
            if dist_nearest_n &lt; dist_from_visited[n]:
                dist_from_visited[n] = dist_nearest_n
                edge_from_visited[n] = (nearest_node, n)
    return mst_lengths, mst

def _prim_algorithm(nodes: Collection[int], weight: _WeightFun,
                    inf: Number) -&gt; Number:
    &#34;&#34;&#34;
        Computes the weight of the minimum spanning tree connecting
        the given nodes, using the given weight function for branches.
        The number `inf` should be larger than the maximum weight
        that can be encountered in the process.
    &#34;&#34;&#34;
    if not nodes:
        return 0
    mst_length: Number = 0
    # Initialise set of nodes to visit:
    to_visit = set(nodes)
    n0 = next(iter(to_visit))
    to_visit.remove(n0)
    # Initialise dict of distances from visited set:
    dist_from_visited = {
        n: weight(n0, n) for n in nodes
    }
    while to_visit:
        # Look for the node to be visited which is nearest to the visited set:
        nearest_node = 0 # dummy value
        nearest_dist = inf # dummy value
        for n in to_visit:
            n_dist = dist_from_visited[n]
            if n_dist &lt; nearest_dist:
                nearest_node = n
                nearest_dist = n_dist
        # Nearest node is removed and added to the MST:
        to_visit.remove(nearest_node)
        mst_length += nearest_dist
        # Update shortest distances to visited set:
        for n in to_visit:
            dist_nearest_n = weight(nearest_node, n)
            if dist_nearest_n &lt; dist_from_visited[n]:
                dist_from_visited[n] = dist_nearest_n
    return mst_length

def cx_count(gadget: PhaseGadget,
             topology: Topology) -&gt; Tuple[Sequence[Number], Sequence[Tuple[int, int]]]:
    &#34;&#34;&#34;
        Returns detailed CX count information for the minimal spanning tree
        implementation of the given gadget on the given topology.
        Returns the list of CX counts for the individual branches of an MST and
        the MST itself (as a list of branches).
    &#34;&#34;&#34;
    if not isinstance(gadget, PhaseGadget):
        raise TypeError(f&#34;Expected PhaseGadget, found {type(gadget)}.&#34;)
    if not isinstance(topology, Topology):
        raise TypeError(f&#34;Expected Topology, found {type(topology)}.&#34;)
    return _prim_algorithm_debug(gadget.qubits,
                                 lambda u, v: 4*topology.dist(u, v)-2,
                                 4*len(topology.qubits)-2)


def cx_count_cost_fun(topology: Topology, circuit_rep: int = 1) -&gt; &#34;CostFun&#34;:
    &#34;&#34;&#34;
        Returns a topology-aware cost function for the optimizer, based on CX count.
        It takes an optional `circuit_rep` argument that can be used to specify the
        number of repetitions for the original circuit (e.g. for QML ansatz applications).

        The CX count for an individual phase circuit block in the optimized circuit is
        computed by finding a minimum spanning tree implementation of the phase gadgets.
        The CX count for an individual block is then multiplied by `circuit_rep` and twice
        the number of CX gates in the CX block is added (because each gate appears twice,
        once in the first block and once in the last block of the optimized circuit.).
        The resulting CX count is returned as the cost.
    &#34;&#34;&#34;
    if not isinstance(topology, Topology):
        raise TypeError(f&#34;Expected Topology, found {type(topology)}.&#34;)
    if not isinstance(circuit_rep, int) or circuit_rep &lt;= 0:
        raise TypeError(f&#34;Expected positive integer, found {circuit_rep}.&#34;)
    def cost_fun(phase_block: PhaseCircuitView, cx_block: CXCircuitView):
        phase_block_cost: Number = 0
        for gadget in phase_block.gadgets:
            phase_block_cost += _prim_algorithm(gadget.qubits,
                                                lambda u, v: 4*topology.dist(u, v)-2,
                                                4*len(topology.qubits)-2)
        return circuit_rep*phase_block_cost + 2*cx_block.num_gates
    return cost_fun


@runtime_checkable
class AnnealingCostLogger(Protocol):
    &#34;&#34;&#34;
        Protocol for logger of initial/final cost in annealing.
    &#34;&#34;&#34;

    def __call__(self, cost: Number, num_iters: int):
        ...


@runtime_checkable
class AnnealingIterLogger(Protocol):
    &#34;&#34;&#34;
        Protocol for logging of iteration info in annealing.
    &#34;&#34;&#34;

    def __call__(self, it: int, prev_cost: Number, new_cost: Number,
                 accepted: bool, flip: Tuple[int, Tuple[int, int]],
                 t: Number, num_iters: int):
        # pylint: disable = too-many-arguments
        ...


class AnnealingLoggers(TypedDict, total=False):
    &#34;&#34;&#34;
        Typed dictionary of loggers for annealing.
    &#34;&#34;&#34;

    log_init_cost: AnnealingCostLogger
    log_iter: AnnealingIterLogger
    log_final_cost: AnnealingCostLogger


class PhaseCircuitOptimizer:
    # pylint: disable = too-many-instance-attributes
    &#34;&#34;&#34;
        Optimizer for phase circuits based on simulated annealing.
        The original phase circuit is passed to the constructor, together
        with a qubit topology and a fixed number of layers constraining the
        CX circuits to be used for simplification.

        To understand how this works, consider the following code snipped:

        ```py
            optimizer = PhaseCircuitOptimizer(original_circuit, topology, num_layers)
            optimizer.anneal(num_iters, temp_schedule, cost_fun)
            phase_block = optimizer.phase_block
            cx_block = optimizer.cx_block
        ```

        The optimized circuit is obtained by composing three blocks:

        1. a first block of CX gates, given by `cx_block.dag`
           (the same CX gates of `cx_block`, but in reverse order);
        2. a central block of phase gadgets, given by `phase_block`;
        3. a final block of CX gates, given by `cx_block`.

        Furthermore, if the original circuit is repeated `n` times, e.g. as part
        of a quantum machine learning ansatz, then the corresponding optimized
        circuit is obtained by repeating the central `phase_block` alone `n` times,
        keeping the first and last CX blocks unaltered (because the intermediate
        CX blocks cancel each other out when repeating the optimized circuit `n` times).

    &#34;&#34;&#34;

    _topology: Topology
    _qubits: FrozenSet[int]
    _original_gadgets: Tuple[PhaseGadget, ...]
    _phase_block: PhaseCircuit
    _phase_block_view: PhaseCircuitView
    _cx_block: CXCircuit
    _cx_block_view: CXCircuitView
    _rng_seed: Optional[int]
    _rng: np.random.Generator

    def __init__(self, original_circuit: PhaseCircuit, topology: Topology, num_layers: int, *,
                 rng_seed: Optional[int] = None):
        if not isinstance(original_circuit, PhaseCircuit):
            raise TypeError(f&#34;Expected PhaseCircuit, found {type(original_circuit)}.&#34;)
        if not isinstance(topology, Topology):
            raise TypeError(f&#34;Expected Topology, found {type(topology)}.&#34;)
        if not isinstance(num_layers, int) or num_layers &lt;= 0:
            raise TypeError(f&#34;Expected positive integer, found {num_layers}.&#34;)
        if rng_seed is not None and not isinstance(rng_seed, int):
            raise TypeError(&#34;RNG seed must be integer or None.&#34;)
        self._topology = topology
        self._qubits = original_circuit.qubits
        self._original_gadgets = tuple(original_circuit.gadgets)
        self._phase_block = PhaseCircuit(self._qubits, self._original_gadgets)
        self._cx_block = CXCircuit(topology,
                                   [CXCircuitLayer(topology) for _ in range(num_layers)])
        self._rng_seed = rng_seed
        self._rng = np.random.default_rng(seed=rng_seed)
        self._phase_block_view = PhaseCircuitView(self._phase_block)
        self._cx_block_view = CXCircuitView(self._cx_block)

    @property
    def topology(self) -&gt; Topology:
        &#34;&#34;&#34;
            Readonly property exposing the topology constraining the circuit optimization.
        &#34;&#34;&#34;
        return self._topology

    @property
    def qubits(self) -&gt; FrozenSet[int]:
        &#34;&#34;&#34;
            Readonly property exposing the qubits spanned by the circuit to be optimized.
        &#34;&#34;&#34;
        return self._qubits

    @property
    def original_gadgets(self) -&gt; Tuple[PhaseGadget, ...]:
        &#34;&#34;&#34;
            Readonly property exposing the gadgets in the original circuit to be optimized.
        &#34;&#34;&#34;
        return self._original_gadgets

    @property
    def phase_block(self) -&gt; PhaseCircuitView:
        &#34;&#34;&#34;
            Readonly property returning a readonly view on the optimized circuit.
        &#34;&#34;&#34;
        return self._phase_block_view

    @property
    def cx_block(self) -&gt; CXCircuitView:
        &#34;&#34;&#34;
            Readonly property returning a readonly view on the CX circuit used for optimization.
        &#34;&#34;&#34;
        return self._cx_block_view

    def anneal(self,
               num_iters: int,
               temp_schedule: TempSchedule,
               cost_fun: CostFun, *,
               loggers: AnnealingLoggers = {}):
               # pylint: disable = dangerous-default-value
        # pylint: disable = too-many-locals
        &#34;&#34;&#34;
            Performs a cycle of simulated annealing optimization,
            using the given number of iterations, temperature schedule
            and cost function.
        &#34;&#34;&#34;
        # Validate arguments:
        if not isinstance(num_iters, int) or num_iters &lt;= 0:
            raise TypeError(f&#34;Expected a positive integer, found {num_iters}.&#34;)
        if not isinstance(temp_schedule, TempSchedule):
            raise TypeError(f&#34;Expected TempSchedule, found {type(temp_schedule)}.&#34;)
        if not isinstance(cost_fun, CostFun):
            raise TypeError(f&#34;Expected CostFun, found {type(cost_fun)}.&#34;)
        log_init_cost = loggers.get(&#34;log_init_cost&#34;, None)
        log_iter = loggers.get(&#34;log_iter&#34;, None)
        log_final_cost = loggers.get(&#34;log_final_cost&#34;, None)
        if log_init_cost is not None and not isinstance(log_init_cost, AnnealingCostLogger):
            raise TypeError(f&#34;Expected AnnealingCostLogger, found {type(log_init_cost)}&#34;)
        if log_iter is not None and not isinstance(log_iter, AnnealingIterLogger):
            raise TypeError(f&#34;Expected AnnealingCostLogger, found {type(log_iter)}&#34;)
        if log_final_cost is not None and not isinstance(log_final_cost, AnnealingCostLogger):
            raise TypeError(f&#34;Expected AnnealingCostLogger, found {type(log_final_cost)}&#34;)
        # Compute and log initial cost:
        init_cost = cost_fun(self.phase_block, self.cx_block)
        curr_cost = init_cost
        if log_init_cost is not None:
            log_init_cost(init_cost, num_iters)
        # Pre-sample random numbers to use in iterations:
        rand = self._rng.uniform(size=num_iters)
        # Run iterations:
        for it in range(num_iters):
            t = temp_schedule(it, num_iters=num_iters)
            layer_idx, (ctrl, trgt) = self.random_flip_cx()
            new_cost = cost_fun(self.phase_block, self.cx_block)
            accept_step = (new_cost &lt; curr_cost
                           or rand[it] &lt; np.exp(-(new_cost-curr_cost)/t))
            if log_iter is not None:
                log_iter(it, curr_cost, new_cost, accept_step,
                         (layer_idx, (ctrl, trgt)), t, num_iters)
            if accept_step:
                # Accept changes:
                curr_cost = new_cost
            else:
                # Undo changes:
                self._flip_cx(layer_idx, ctrl, trgt)
        # Log final cost:
        if log_final_cost is not None:
            log_final_cost(curr_cost, num_iters)

    def random_flip_cx(self) -&gt; Tuple[int, Tuple[int, int]]:
        &#34;&#34;&#34;
            Randomly flips a CX gate in the CX circuit used for the optimization,
            updating both the CX circuit and the circuit being optimized.

            Returns the layer index and gate (pair of control and target) that were
            flipped (e.g. in case the flip needs to be subsequently undone).
        &#34;&#34;&#34;
        layer_idx = int(self._rng.integers(len(self._cx_block)))
        flippable_gates = list(self._cx_block[layer_idx]._iter_flippable_cxs()) # pylint: disable = protected-access
        gate_idx = self._rng.integers(len(flippable_gates))
        ctrl, trgt = flippable_gates[gate_idx]
        self._flip_cx(layer_idx, ctrl, trgt)
        return layer_idx, (ctrl, trgt)

    def is_cx_flippable(self, layer_idx: int, ctrl: int, trgt: int) -&gt; bool:
        &#34;&#34;&#34;
            Checks whether the given CX gate can be flipped in the given layer.
        &#34;&#34;&#34;
        if not isinstance(layer_idx, int) or not 0 &lt;= layer_idx &lt; len(self._cx_block):
            raise TypeError(f&#34;Invalid layer index {layer_idx} for CX circuit.&#34;)
        layer = self._cx_block[layer_idx]
        return layer.is_cx_flippable(ctrl, trgt)

    def flip_cx(self, layer_idx: int, ctrl: int, trgt: int) -&gt; None:
        &#34;&#34;&#34;
            Performs the actions needed to flip the given CX gate in the given layer
            of the CX circuit used for the optimization:

            - undoes all gates in layers subsequent to the given layer which are
              causally following the given gate, starting from the last layer and
              working backwards towards the gate;
            - applies the desired gate;
            - redoes all gate undone, in reverse order (starting from the gate and
              working forwards towards the last layer).
        &#34;&#34;&#34;
        if not self.is_cx_flippable(layer_idx, ctrl, trgt):
            raise ValueError(f&#34;Gate {(ctrl, trgt)} cannot be flipped in layer number {layer_idx}.&#34;)
        self._flip_cx(layer_idx, ctrl, trgt)

    def _flip_cx(self, layer_idx: int, ctrl: int, trgt: int) -&gt; None:
        conj_by: Deque[Tuple[int, int]] = deque([(ctrl, trgt)])
        qubits_spanned: Set[int] = set([ctrl, trgt])
        for layer in self._cx_block[layer_idx:]:
            new_qubits_spanned: Set[int] = set()
            for q in qubits_spanned:
                incident_gate = layer.incident(q)
                if incident_gate is not None:
                    new_qubits_spanned.update({incident_gate[0], incident_gate[1]})
                    conj_by.appendleft(incident_gate) # will first undo the gate ...
                    # ... then do all gates already in conj_by ...
                    conj_by.append(incident_gate) # ... then finally redo the gate
            qubits_spanned.update(new_qubits_spanned)
        # Flip the gate in the CX circuit:
        self._cx_block[layer_idx].flip_cx(ctrl, trgt)
        # Conjugate the optimized phase gadget circuit by all necessary gates:
        for cx in conj_by:
            self._phase_block.conj_by_cx(*cx)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pauliopt.phase.optimizers.cx_count"><code class="name flex">
<span>def <span class="ident">cx_count</span></span>(<span>gadget: <a title="pauliopt.phase.circuits.PhaseGadget" href="circuits.html#pauliopt.phase.circuits.PhaseGadget">PhaseGadget</a>, topology: <a title="pauliopt.topologies.Topology" href="../topologies.html#pauliopt.topologies.Topology">Topology</a>) ‑> Tuple[Sequence[Union[int, float]], Sequence[Tuple[int, int]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns detailed CX count information for the minimal spanning tree
implementation of the given gadget on the given topology.
Returns the list of CX counts for the individual branches of an MST and
the MST itself (as a list of branches).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cx_count(gadget: PhaseGadget,
             topology: Topology) -&gt; Tuple[Sequence[Number], Sequence[Tuple[int, int]]]:
    &#34;&#34;&#34;
        Returns detailed CX count information for the minimal spanning tree
        implementation of the given gadget on the given topology.
        Returns the list of CX counts for the individual branches of an MST and
        the MST itself (as a list of branches).
    &#34;&#34;&#34;
    if not isinstance(gadget, PhaseGadget):
        raise TypeError(f&#34;Expected PhaseGadget, found {type(gadget)}.&#34;)
    if not isinstance(topology, Topology):
        raise TypeError(f&#34;Expected Topology, found {type(topology)}.&#34;)
    return _prim_algorithm_debug(gadget.qubits,
                                 lambda u, v: 4*topology.dist(u, v)-2,
                                 4*len(topology.qubits)-2)</code></pre>
</details>
</dd>
<dt id="pauliopt.phase.optimizers.cx_count_cost_fun"><code class="name flex">
<span>def <span class="ident">cx_count_cost_fun</span></span>(<span>topology: <a title="pauliopt.topologies.Topology" href="../topologies.html#pauliopt.topologies.Topology">Topology</a>, circuit_rep: int = 1) ‑> <a title="pauliopt.phase.optimizers.CostFun" href="#pauliopt.phase.optimizers.CostFun">CostFun</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns a topology-aware cost function for the optimizer, based on CX count.
It takes an optional <code>circuit_rep</code> argument that can be used to specify the
number of repetitions for the original circuit (e.g. for QML ansatz applications).</p>
<p>The CX count for an individual phase circuit block in the optimized circuit is
computed by finding a minimum spanning tree implementation of the phase gadgets.
The CX count for an individual block is then multiplied by <code>circuit_rep</code> and twice
the number of CX gates in the CX block is added (because each gate appears twice,
once in the first block and once in the last block of the optimized circuit.).
The resulting CX count is returned as the cost.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cx_count_cost_fun(topology: Topology, circuit_rep: int = 1) -&gt; &#34;CostFun&#34;:
    &#34;&#34;&#34;
        Returns a topology-aware cost function for the optimizer, based on CX count.
        It takes an optional `circuit_rep` argument that can be used to specify the
        number of repetitions for the original circuit (e.g. for QML ansatz applications).

        The CX count for an individual phase circuit block in the optimized circuit is
        computed by finding a minimum spanning tree implementation of the phase gadgets.
        The CX count for an individual block is then multiplied by `circuit_rep` and twice
        the number of CX gates in the CX block is added (because each gate appears twice,
        once in the first block and once in the last block of the optimized circuit.).
        The resulting CX count is returned as the cost.
    &#34;&#34;&#34;
    if not isinstance(topology, Topology):
        raise TypeError(f&#34;Expected Topology, found {type(topology)}.&#34;)
    if not isinstance(circuit_rep, int) or circuit_rep &lt;= 0:
        raise TypeError(f&#34;Expected positive integer, found {circuit_rep}.&#34;)
    def cost_fun(phase_block: PhaseCircuitView, cx_block: CXCircuitView):
        phase_block_cost: Number = 0
        for gadget in phase_block.gadgets:
            phase_block_cost += _prim_algorithm(gadget.qubits,
                                                lambda u, v: 4*topology.dist(u, v)-2,
                                                4*len(topology.qubits)-2)
        return circuit_rep*phase_block_cost + 2*cx_block.num_gates
    return cost_fun</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pauliopt.phase.optimizers.AnnealingCostLogger"><code class="flex name class">
<span>class <span class="ident">AnnealingCostLogger</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Protocol for logger of initial/final cost in annealing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AnnealingCostLogger(Protocol):
    &#34;&#34;&#34;
        Protocol for logger of initial/final cost in annealing.
    &#34;&#34;&#34;

    def __call__(self, cost: Number, num_iters: int):
        ...</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="pauliopt.phase.optimizers.AnnealingIterLogger"><code class="flex name class">
<span>class <span class="ident">AnnealingIterLogger</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Protocol for logging of iteration info in annealing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AnnealingIterLogger(Protocol):
    &#34;&#34;&#34;
        Protocol for logging of iteration info in annealing.
    &#34;&#34;&#34;

    def __call__(self, it: int, prev_cost: Number, new_cost: Number,
                 accepted: bool, flip: Tuple[int, Tuple[int, int]],
                 t: Number, num_iters: int):
        # pylint: disable = too-many-arguments
        ...</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="pauliopt.phase.optimizers.AnnealingLoggers"><code class="flex name class">
<span>class <span class="ident">AnnealingLoggers</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Typed dictionary of loggers for annealing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AnnealingLoggers(TypedDict, total=False):
    &#34;&#34;&#34;
        Typed dictionary of loggers for annealing.
    &#34;&#34;&#34;

    log_init_cost: AnnealingCostLogger
    log_iter: AnnealingIterLogger
    log_final_cost: AnnealingCostLogger</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pauliopt.phase.optimizers.AnnealingLoggers.log_final_cost"><code class="name">var <span class="ident">log_final_cost</span> : <a title="pauliopt.phase.optimizers.AnnealingCostLogger" href="#pauliopt.phase.optimizers.AnnealingCostLogger">AnnealingCostLogger</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pauliopt.phase.optimizers.AnnealingLoggers.log_init_cost"><code class="name">var <span class="ident">log_init_cost</span> : <a title="pauliopt.phase.optimizers.AnnealingCostLogger" href="#pauliopt.phase.optimizers.AnnealingCostLogger">AnnealingCostLogger</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pauliopt.phase.optimizers.AnnealingLoggers.log_iter"><code class="name">var <span class="ident">log_iter</span> : <a title="pauliopt.phase.optimizers.AnnealingIterLogger" href="#pauliopt.phase.optimizers.AnnealingIterLogger">AnnealingIterLogger</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="pauliopt.phase.optimizers.CostFun"><code class="flex name class">
<span>class <span class="ident">CostFun</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Protocol for a cost function.
The cost is a <code>float</code> or <code>int</code> computed from the phase block (readonly view)
and CX block (readonly view) exposed by an instance of <code><a title="pauliopt.phase.optimizers.PhaseCircuitOptimizer" href="#pauliopt.phase.optimizers.PhaseCircuitOptimizer">PhaseCircuitOptimizer</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CostFun(Protocol):
    &#34;&#34;&#34;
        Protocol for a cost function.
        The cost is a `float` or `int` computed from the phase block (readonly view)
        and CX block (readonly view) exposed by an instance of `PhaseCircuitOptimizer`.
    &#34;&#34;&#34;

    def __call__(self, phase_block: PhaseCircuitView, cx_block: CXCircuitView) -&gt; Number:
        ...</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="pauliopt.phase.optimizers.PhaseCircuitOptimizer"><code class="flex name class">
<span>class <span class="ident">PhaseCircuitOptimizer</span></span>
<span>(</span><span>original_circuit: <a title="pauliopt.phase.circuits.PhaseCircuit" href="circuits.html#pauliopt.phase.circuits.PhaseCircuit">PhaseCircuit</a>, topology: <a title="pauliopt.topologies.Topology" href="../topologies.html#pauliopt.topologies.Topology">Topology</a>, num_layers: int, *, rng_seed: Union[int, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Optimizer for phase circuits based on simulated annealing.
The original phase circuit is passed to the constructor, together
with a qubit topology and a fixed number of layers constraining the
CX circuits to be used for simplification.</p>
<p>To understand how this works, consider the following code snipped:</p>
<pre><code class="py">    optimizer = PhaseCircuitOptimizer(original_circuit, topology, num_layers)
    optimizer.anneal(num_iters, temp_schedule, cost_fun)
    phase_block = optimizer.phase_block
    cx_block = optimizer.cx_block
</code></pre>
<p>The optimized circuit is obtained by composing three blocks:</p>
<ol>
<li>a first block of CX gates, given by <code>cx_block.dag</code>
(the same CX gates of <code>cx_block</code>, but in reverse order);</li>
<li>a central block of phase gadgets, given by <code>phase_block</code>;</li>
<li>a final block of CX gates, given by <code>cx_block</code>.</li>
</ol>
<p>Furthermore, if the original circuit is repeated <code>n</code> times, e.g. as part
of a quantum machine learning ansatz, then the corresponding optimized
circuit is obtained by repeating the central <code>phase_block</code> alone <code>n</code> times,
keeping the first and last CX blocks unaltered (because the intermediate
CX blocks cancel each other out when repeating the optimized circuit <code>n</code> times).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PhaseCircuitOptimizer:
    # pylint: disable = too-many-instance-attributes
    &#34;&#34;&#34;
        Optimizer for phase circuits based on simulated annealing.
        The original phase circuit is passed to the constructor, together
        with a qubit topology and a fixed number of layers constraining the
        CX circuits to be used for simplification.

        To understand how this works, consider the following code snipped:

        ```py
            optimizer = PhaseCircuitOptimizer(original_circuit, topology, num_layers)
            optimizer.anneal(num_iters, temp_schedule, cost_fun)
            phase_block = optimizer.phase_block
            cx_block = optimizer.cx_block
        ```

        The optimized circuit is obtained by composing three blocks:

        1. a first block of CX gates, given by `cx_block.dag`
           (the same CX gates of `cx_block`, but in reverse order);
        2. a central block of phase gadgets, given by `phase_block`;
        3. a final block of CX gates, given by `cx_block`.

        Furthermore, if the original circuit is repeated `n` times, e.g. as part
        of a quantum machine learning ansatz, then the corresponding optimized
        circuit is obtained by repeating the central `phase_block` alone `n` times,
        keeping the first and last CX blocks unaltered (because the intermediate
        CX blocks cancel each other out when repeating the optimized circuit `n` times).

    &#34;&#34;&#34;

    _topology: Topology
    _qubits: FrozenSet[int]
    _original_gadgets: Tuple[PhaseGadget, ...]
    _phase_block: PhaseCircuit
    _phase_block_view: PhaseCircuitView
    _cx_block: CXCircuit
    _cx_block_view: CXCircuitView
    _rng_seed: Optional[int]
    _rng: np.random.Generator

    def __init__(self, original_circuit: PhaseCircuit, topology: Topology, num_layers: int, *,
                 rng_seed: Optional[int] = None):
        if not isinstance(original_circuit, PhaseCircuit):
            raise TypeError(f&#34;Expected PhaseCircuit, found {type(original_circuit)}.&#34;)
        if not isinstance(topology, Topology):
            raise TypeError(f&#34;Expected Topology, found {type(topology)}.&#34;)
        if not isinstance(num_layers, int) or num_layers &lt;= 0:
            raise TypeError(f&#34;Expected positive integer, found {num_layers}.&#34;)
        if rng_seed is not None and not isinstance(rng_seed, int):
            raise TypeError(&#34;RNG seed must be integer or None.&#34;)
        self._topology = topology
        self._qubits = original_circuit.qubits
        self._original_gadgets = tuple(original_circuit.gadgets)
        self._phase_block = PhaseCircuit(self._qubits, self._original_gadgets)
        self._cx_block = CXCircuit(topology,
                                   [CXCircuitLayer(topology) for _ in range(num_layers)])
        self._rng_seed = rng_seed
        self._rng = np.random.default_rng(seed=rng_seed)
        self._phase_block_view = PhaseCircuitView(self._phase_block)
        self._cx_block_view = CXCircuitView(self._cx_block)

    @property
    def topology(self) -&gt; Topology:
        &#34;&#34;&#34;
            Readonly property exposing the topology constraining the circuit optimization.
        &#34;&#34;&#34;
        return self._topology

    @property
    def qubits(self) -&gt; FrozenSet[int]:
        &#34;&#34;&#34;
            Readonly property exposing the qubits spanned by the circuit to be optimized.
        &#34;&#34;&#34;
        return self._qubits

    @property
    def original_gadgets(self) -&gt; Tuple[PhaseGadget, ...]:
        &#34;&#34;&#34;
            Readonly property exposing the gadgets in the original circuit to be optimized.
        &#34;&#34;&#34;
        return self._original_gadgets

    @property
    def phase_block(self) -&gt; PhaseCircuitView:
        &#34;&#34;&#34;
            Readonly property returning a readonly view on the optimized circuit.
        &#34;&#34;&#34;
        return self._phase_block_view

    @property
    def cx_block(self) -&gt; CXCircuitView:
        &#34;&#34;&#34;
            Readonly property returning a readonly view on the CX circuit used for optimization.
        &#34;&#34;&#34;
        return self._cx_block_view

    def anneal(self,
               num_iters: int,
               temp_schedule: TempSchedule,
               cost_fun: CostFun, *,
               loggers: AnnealingLoggers = {}):
               # pylint: disable = dangerous-default-value
        # pylint: disable = too-many-locals
        &#34;&#34;&#34;
            Performs a cycle of simulated annealing optimization,
            using the given number of iterations, temperature schedule
            and cost function.
        &#34;&#34;&#34;
        # Validate arguments:
        if not isinstance(num_iters, int) or num_iters &lt;= 0:
            raise TypeError(f&#34;Expected a positive integer, found {num_iters}.&#34;)
        if not isinstance(temp_schedule, TempSchedule):
            raise TypeError(f&#34;Expected TempSchedule, found {type(temp_schedule)}.&#34;)
        if not isinstance(cost_fun, CostFun):
            raise TypeError(f&#34;Expected CostFun, found {type(cost_fun)}.&#34;)
        log_init_cost = loggers.get(&#34;log_init_cost&#34;, None)
        log_iter = loggers.get(&#34;log_iter&#34;, None)
        log_final_cost = loggers.get(&#34;log_final_cost&#34;, None)
        if log_init_cost is not None and not isinstance(log_init_cost, AnnealingCostLogger):
            raise TypeError(f&#34;Expected AnnealingCostLogger, found {type(log_init_cost)}&#34;)
        if log_iter is not None and not isinstance(log_iter, AnnealingIterLogger):
            raise TypeError(f&#34;Expected AnnealingCostLogger, found {type(log_iter)}&#34;)
        if log_final_cost is not None and not isinstance(log_final_cost, AnnealingCostLogger):
            raise TypeError(f&#34;Expected AnnealingCostLogger, found {type(log_final_cost)}&#34;)
        # Compute and log initial cost:
        init_cost = cost_fun(self.phase_block, self.cx_block)
        curr_cost = init_cost
        if log_init_cost is not None:
            log_init_cost(init_cost, num_iters)
        # Pre-sample random numbers to use in iterations:
        rand = self._rng.uniform(size=num_iters)
        # Run iterations:
        for it in range(num_iters):
            t = temp_schedule(it, num_iters=num_iters)
            layer_idx, (ctrl, trgt) = self.random_flip_cx()
            new_cost = cost_fun(self.phase_block, self.cx_block)
            accept_step = (new_cost &lt; curr_cost
                           or rand[it] &lt; np.exp(-(new_cost-curr_cost)/t))
            if log_iter is not None:
                log_iter(it, curr_cost, new_cost, accept_step,
                         (layer_idx, (ctrl, trgt)), t, num_iters)
            if accept_step:
                # Accept changes:
                curr_cost = new_cost
            else:
                # Undo changes:
                self._flip_cx(layer_idx, ctrl, trgt)
        # Log final cost:
        if log_final_cost is not None:
            log_final_cost(curr_cost, num_iters)

    def random_flip_cx(self) -&gt; Tuple[int, Tuple[int, int]]:
        &#34;&#34;&#34;
            Randomly flips a CX gate in the CX circuit used for the optimization,
            updating both the CX circuit and the circuit being optimized.

            Returns the layer index and gate (pair of control and target) that were
            flipped (e.g. in case the flip needs to be subsequently undone).
        &#34;&#34;&#34;
        layer_idx = int(self._rng.integers(len(self._cx_block)))
        flippable_gates = list(self._cx_block[layer_idx]._iter_flippable_cxs()) # pylint: disable = protected-access
        gate_idx = self._rng.integers(len(flippable_gates))
        ctrl, trgt = flippable_gates[gate_idx]
        self._flip_cx(layer_idx, ctrl, trgt)
        return layer_idx, (ctrl, trgt)

    def is_cx_flippable(self, layer_idx: int, ctrl: int, trgt: int) -&gt; bool:
        &#34;&#34;&#34;
            Checks whether the given CX gate can be flipped in the given layer.
        &#34;&#34;&#34;
        if not isinstance(layer_idx, int) or not 0 &lt;= layer_idx &lt; len(self._cx_block):
            raise TypeError(f&#34;Invalid layer index {layer_idx} for CX circuit.&#34;)
        layer = self._cx_block[layer_idx]
        return layer.is_cx_flippable(ctrl, trgt)

    def flip_cx(self, layer_idx: int, ctrl: int, trgt: int) -&gt; None:
        &#34;&#34;&#34;
            Performs the actions needed to flip the given CX gate in the given layer
            of the CX circuit used for the optimization:

            - undoes all gates in layers subsequent to the given layer which are
              causally following the given gate, starting from the last layer and
              working backwards towards the gate;
            - applies the desired gate;
            - redoes all gate undone, in reverse order (starting from the gate and
              working forwards towards the last layer).
        &#34;&#34;&#34;
        if not self.is_cx_flippable(layer_idx, ctrl, trgt):
            raise ValueError(f&#34;Gate {(ctrl, trgt)} cannot be flipped in layer number {layer_idx}.&#34;)
        self._flip_cx(layer_idx, ctrl, trgt)

    def _flip_cx(self, layer_idx: int, ctrl: int, trgt: int) -&gt; None:
        conj_by: Deque[Tuple[int, int]] = deque([(ctrl, trgt)])
        qubits_spanned: Set[int] = set([ctrl, trgt])
        for layer in self._cx_block[layer_idx:]:
            new_qubits_spanned: Set[int] = set()
            for q in qubits_spanned:
                incident_gate = layer.incident(q)
                if incident_gate is not None:
                    new_qubits_spanned.update({incident_gate[0], incident_gate[1]})
                    conj_by.appendleft(incident_gate) # will first undo the gate ...
                    # ... then do all gates already in conj_by ...
                    conj_by.append(incident_gate) # ... then finally redo the gate
            qubits_spanned.update(new_qubits_spanned)
        # Flip the gate in the CX circuit:
        self._cx_block[layer_idx].flip_cx(ctrl, trgt)
        # Conjugate the optimized phase gadget circuit by all necessary gates:
        for cx in conj_by:
            self._phase_block.conj_by_cx(*cx)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pauliopt.phase.optimizers.PhaseCircuitOptimizer.cx_block"><code class="name">var <span class="ident">cx_block</span> : <a title="pauliopt.phase.circuits.CXCircuitView" href="circuits.html#pauliopt.phase.circuits.CXCircuitView">CXCircuitView</a></code></dt>
<dd>
<div class="desc"><p>Readonly property returning a readonly view on the CX circuit used for optimization.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cx_block(self) -&gt; CXCircuitView:
    &#34;&#34;&#34;
        Readonly property returning a readonly view on the CX circuit used for optimization.
    &#34;&#34;&#34;
    return self._cx_block_view</code></pre>
</details>
</dd>
<dt id="pauliopt.phase.optimizers.PhaseCircuitOptimizer.original_gadgets"><code class="name">var <span class="ident">original_gadgets</span> : Tuple[<a title="pauliopt.phase.circuits.PhaseGadget" href="circuits.html#pauliopt.phase.circuits.PhaseGadget">PhaseGadget</a>, ...]</code></dt>
<dd>
<div class="desc"><p>Readonly property exposing the gadgets in the original circuit to be optimized.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def original_gadgets(self) -&gt; Tuple[PhaseGadget, ...]:
    &#34;&#34;&#34;
        Readonly property exposing the gadgets in the original circuit to be optimized.
    &#34;&#34;&#34;
    return self._original_gadgets</code></pre>
</details>
</dd>
<dt id="pauliopt.phase.optimizers.PhaseCircuitOptimizer.phase_block"><code class="name">var <span class="ident">phase_block</span> : <a title="pauliopt.phase.circuits.PhaseCircuitView" href="circuits.html#pauliopt.phase.circuits.PhaseCircuitView">PhaseCircuitView</a></code></dt>
<dd>
<div class="desc"><p>Readonly property returning a readonly view on the optimized circuit.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def phase_block(self) -&gt; PhaseCircuitView:
    &#34;&#34;&#34;
        Readonly property returning a readonly view on the optimized circuit.
    &#34;&#34;&#34;
    return self._phase_block_view</code></pre>
</details>
</dd>
<dt id="pauliopt.phase.optimizers.PhaseCircuitOptimizer.qubits"><code class="name">var <span class="ident">qubits</span> : FrozenSet[int]</code></dt>
<dd>
<div class="desc"><p>Readonly property exposing the qubits spanned by the circuit to be optimized.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def qubits(self) -&gt; FrozenSet[int]:
    &#34;&#34;&#34;
        Readonly property exposing the qubits spanned by the circuit to be optimized.
    &#34;&#34;&#34;
    return self._qubits</code></pre>
</details>
</dd>
<dt id="pauliopt.phase.optimizers.PhaseCircuitOptimizer.topology"><code class="name">var <span class="ident">topology</span> : <a title="pauliopt.topologies.Topology" href="../topologies.html#pauliopt.topologies.Topology">Topology</a></code></dt>
<dd>
<div class="desc"><p>Readonly property exposing the topology constraining the circuit optimization.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def topology(self) -&gt; Topology:
    &#34;&#34;&#34;
        Readonly property exposing the topology constraining the circuit optimization.
    &#34;&#34;&#34;
    return self._topology</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pauliopt.phase.optimizers.PhaseCircuitOptimizer.anneal"><code class="name flex">
<span>def <span class="ident">anneal</span></span>(<span>self, num_iters: int, temp_schedule: <a title="pauliopt.utils.TempSchedule" href="../utils.html#pauliopt.utils.TempSchedule">TempSchedule</a>, cost_fun: <a title="pauliopt.phase.optimizers.CostFun" href="#pauliopt.phase.optimizers.CostFun">CostFun</a>, *, loggers: <a title="pauliopt.phase.optimizers.AnnealingLoggers" href="#pauliopt.phase.optimizers.AnnealingLoggers">AnnealingLoggers</a> = {})</span>
</code></dt>
<dd>
<div class="desc"><p>Performs a cycle of simulated annealing optimization,
using the given number of iterations, temperature schedule
and cost function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def anneal(self,
           num_iters: int,
           temp_schedule: TempSchedule,
           cost_fun: CostFun, *,
           loggers: AnnealingLoggers = {}):
           # pylint: disable = dangerous-default-value
    # pylint: disable = too-many-locals
    &#34;&#34;&#34;
        Performs a cycle of simulated annealing optimization,
        using the given number of iterations, temperature schedule
        and cost function.
    &#34;&#34;&#34;
    # Validate arguments:
    if not isinstance(num_iters, int) or num_iters &lt;= 0:
        raise TypeError(f&#34;Expected a positive integer, found {num_iters}.&#34;)
    if not isinstance(temp_schedule, TempSchedule):
        raise TypeError(f&#34;Expected TempSchedule, found {type(temp_schedule)}.&#34;)
    if not isinstance(cost_fun, CostFun):
        raise TypeError(f&#34;Expected CostFun, found {type(cost_fun)}.&#34;)
    log_init_cost = loggers.get(&#34;log_init_cost&#34;, None)
    log_iter = loggers.get(&#34;log_iter&#34;, None)
    log_final_cost = loggers.get(&#34;log_final_cost&#34;, None)
    if log_init_cost is not None and not isinstance(log_init_cost, AnnealingCostLogger):
        raise TypeError(f&#34;Expected AnnealingCostLogger, found {type(log_init_cost)}&#34;)
    if log_iter is not None and not isinstance(log_iter, AnnealingIterLogger):
        raise TypeError(f&#34;Expected AnnealingCostLogger, found {type(log_iter)}&#34;)
    if log_final_cost is not None and not isinstance(log_final_cost, AnnealingCostLogger):
        raise TypeError(f&#34;Expected AnnealingCostLogger, found {type(log_final_cost)}&#34;)
    # Compute and log initial cost:
    init_cost = cost_fun(self.phase_block, self.cx_block)
    curr_cost = init_cost
    if log_init_cost is not None:
        log_init_cost(init_cost, num_iters)
    # Pre-sample random numbers to use in iterations:
    rand = self._rng.uniform(size=num_iters)
    # Run iterations:
    for it in range(num_iters):
        t = temp_schedule(it, num_iters=num_iters)
        layer_idx, (ctrl, trgt) = self.random_flip_cx()
        new_cost = cost_fun(self.phase_block, self.cx_block)
        accept_step = (new_cost &lt; curr_cost
                       or rand[it] &lt; np.exp(-(new_cost-curr_cost)/t))
        if log_iter is not None:
            log_iter(it, curr_cost, new_cost, accept_step,
                     (layer_idx, (ctrl, trgt)), t, num_iters)
        if accept_step:
            # Accept changes:
            curr_cost = new_cost
        else:
            # Undo changes:
            self._flip_cx(layer_idx, ctrl, trgt)
    # Log final cost:
    if log_final_cost is not None:
        log_final_cost(curr_cost, num_iters)</code></pre>
</details>
</dd>
<dt id="pauliopt.phase.optimizers.PhaseCircuitOptimizer.flip_cx"><code class="name flex">
<span>def <span class="ident">flip_cx</span></span>(<span>self, layer_idx: int, ctrl: int, trgt: int) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Performs the actions needed to flip the given CX gate in the given layer
of the CX circuit used for the optimization:</p>
<ul>
<li>undoes all gates in layers subsequent to the given layer which are
causally following the given gate, starting from the last layer and
working backwards towards the gate;</li>
<li>applies the desired gate;</li>
<li>redoes all gate undone, in reverse order (starting from the gate and
working forwards towards the last layer).</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flip_cx(self, layer_idx: int, ctrl: int, trgt: int) -&gt; None:
    &#34;&#34;&#34;
        Performs the actions needed to flip the given CX gate in the given layer
        of the CX circuit used for the optimization:

        - undoes all gates in layers subsequent to the given layer which are
          causally following the given gate, starting from the last layer and
          working backwards towards the gate;
        - applies the desired gate;
        - redoes all gate undone, in reverse order (starting from the gate and
          working forwards towards the last layer).
    &#34;&#34;&#34;
    if not self.is_cx_flippable(layer_idx, ctrl, trgt):
        raise ValueError(f&#34;Gate {(ctrl, trgt)} cannot be flipped in layer number {layer_idx}.&#34;)
    self._flip_cx(layer_idx, ctrl, trgt)</code></pre>
</details>
</dd>
<dt id="pauliopt.phase.optimizers.PhaseCircuitOptimizer.is_cx_flippable"><code class="name flex">
<span>def <span class="ident">is_cx_flippable</span></span>(<span>self, layer_idx: int, ctrl: int, trgt: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whether the given CX gate can be flipped in the given layer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_cx_flippable(self, layer_idx: int, ctrl: int, trgt: int) -&gt; bool:
    &#34;&#34;&#34;
        Checks whether the given CX gate can be flipped in the given layer.
    &#34;&#34;&#34;
    if not isinstance(layer_idx, int) or not 0 &lt;= layer_idx &lt; len(self._cx_block):
        raise TypeError(f&#34;Invalid layer index {layer_idx} for CX circuit.&#34;)
    layer = self._cx_block[layer_idx]
    return layer.is_cx_flippable(ctrl, trgt)</code></pre>
</details>
</dd>
<dt id="pauliopt.phase.optimizers.PhaseCircuitOptimizer.random_flip_cx"><code class="name flex">
<span>def <span class="ident">random_flip_cx</span></span>(<span>self) ‑> Tuple[int, Tuple[int, int]]</span>
</code></dt>
<dd>
<div class="desc"><p>Randomly flips a CX gate in the CX circuit used for the optimization,
updating both the CX circuit and the circuit being optimized.</p>
<p>Returns the layer index and gate (pair of control and target) that were
flipped (e.g. in case the flip needs to be subsequently undone).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def random_flip_cx(self) -&gt; Tuple[int, Tuple[int, int]]:
    &#34;&#34;&#34;
        Randomly flips a CX gate in the CX circuit used for the optimization,
        updating both the CX circuit and the circuit being optimized.

        Returns the layer index and gate (pair of control and target) that were
        flipped (e.g. in case the flip needs to be subsequently undone).
    &#34;&#34;&#34;
    layer_idx = int(self._rng.integers(len(self._cx_block)))
    flippable_gates = list(self._cx_block[layer_idx]._iter_flippable_cxs()) # pylint: disable = protected-access
    gate_idx = self._rng.integers(len(flippable_gates))
    ctrl, trgt = flippable_gates[gate_idx]
    self._flip_cx(layer_idx, ctrl, trgt)
    return layer_idx, (ctrl, trgt)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pauliopt.phase" href="index.html">pauliopt.phase</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pauliopt.phase.optimizers.cx_count" href="#pauliopt.phase.optimizers.cx_count">cx_count</a></code></li>
<li><code><a title="pauliopt.phase.optimizers.cx_count_cost_fun" href="#pauliopt.phase.optimizers.cx_count_cost_fun">cx_count_cost_fun</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pauliopt.phase.optimizers.AnnealingCostLogger" href="#pauliopt.phase.optimizers.AnnealingCostLogger">AnnealingCostLogger</a></code></h4>
</li>
<li>
<h4><code><a title="pauliopt.phase.optimizers.AnnealingIterLogger" href="#pauliopt.phase.optimizers.AnnealingIterLogger">AnnealingIterLogger</a></code></h4>
</li>
<li>
<h4><code><a title="pauliopt.phase.optimizers.AnnealingLoggers" href="#pauliopt.phase.optimizers.AnnealingLoggers">AnnealingLoggers</a></code></h4>
<ul class="">
<li><code><a title="pauliopt.phase.optimizers.AnnealingLoggers.log_final_cost" href="#pauliopt.phase.optimizers.AnnealingLoggers.log_final_cost">log_final_cost</a></code></li>
<li><code><a title="pauliopt.phase.optimizers.AnnealingLoggers.log_init_cost" href="#pauliopt.phase.optimizers.AnnealingLoggers.log_init_cost">log_init_cost</a></code></li>
<li><code><a title="pauliopt.phase.optimizers.AnnealingLoggers.log_iter" href="#pauliopt.phase.optimizers.AnnealingLoggers.log_iter">log_iter</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pauliopt.phase.optimizers.CostFun" href="#pauliopt.phase.optimizers.CostFun">CostFun</a></code></h4>
</li>
<li>
<h4><code><a title="pauliopt.phase.optimizers.PhaseCircuitOptimizer" href="#pauliopt.phase.optimizers.PhaseCircuitOptimizer">PhaseCircuitOptimizer</a></code></h4>
<ul class="two-column">
<li><code><a title="pauliopt.phase.optimizers.PhaseCircuitOptimizer.anneal" href="#pauliopt.phase.optimizers.PhaseCircuitOptimizer.anneal">anneal</a></code></li>
<li><code><a title="pauliopt.phase.optimizers.PhaseCircuitOptimizer.cx_block" href="#pauliopt.phase.optimizers.PhaseCircuitOptimizer.cx_block">cx_block</a></code></li>
<li><code><a title="pauliopt.phase.optimizers.PhaseCircuitOptimizer.flip_cx" href="#pauliopt.phase.optimizers.PhaseCircuitOptimizer.flip_cx">flip_cx</a></code></li>
<li><code><a title="pauliopt.phase.optimizers.PhaseCircuitOptimizer.is_cx_flippable" href="#pauliopt.phase.optimizers.PhaseCircuitOptimizer.is_cx_flippable">is_cx_flippable</a></code></li>
<li><code><a title="pauliopt.phase.optimizers.PhaseCircuitOptimizer.original_gadgets" href="#pauliopt.phase.optimizers.PhaseCircuitOptimizer.original_gadgets">original_gadgets</a></code></li>
<li><code><a title="pauliopt.phase.optimizers.PhaseCircuitOptimizer.phase_block" href="#pauliopt.phase.optimizers.PhaseCircuitOptimizer.phase_block">phase_block</a></code></li>
<li><code><a title="pauliopt.phase.optimizers.PhaseCircuitOptimizer.qubits" href="#pauliopt.phase.optimizers.PhaseCircuitOptimizer.qubits">qubits</a></code></li>
<li><code><a title="pauliopt.phase.optimizers.PhaseCircuitOptimizer.random_flip_cx" href="#pauliopt.phase.optimizers.PhaseCircuitOptimizer.random_flip_cx">random_flip_cx</a></code></li>
<li><code><a title="pauliopt.phase.optimizers.PhaseCircuitOptimizer.topology" href="#pauliopt.phase.optimizers.PhaseCircuitOptimizer.topology">topology</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>