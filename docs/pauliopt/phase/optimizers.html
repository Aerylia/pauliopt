<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>pauliopt.phase.optimizers API documentation</title>
<meta name="description" content="This module contains code to optimize circuits of mixed ZX phase gadgets
using topologically-aware circuits of CNOTs." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pauliopt.phase.optimizers</code></h1>
</header>
<section id="section-intro">
<p>This module contains code to optimize circuits of mixed ZX phase gadgets
using topologically-aware circuits of CNOTs.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
    This module contains code to optimize circuits of mixed ZX phase gadgets
    using topologically-aware circuits of CNOTs.
&#34;&#34;&#34;

from collections import deque
from typing import (Deque, Dict, Generic, Optional, Protocol, runtime_checkable,
                    Set, Tuple, TypedDict, Union)
import numpy as np # type: ignore
from pauliopt.phase.circuits import (PhaseGadget, PhaseCircuit, PhaseCircuitView,
                                     CXCircuitLayer, CXCircuit, CXCircuitView)
from pauliopt.topologies import Topology
from pauliopt.utils import AngleT, TempSchedule, StandardTempSchedule, StandardTempSchedules

@runtime_checkable
class AnnealingCostLogger(Protocol):
    &#34;&#34;&#34;
        Protocol for logger of initial/final cost in annealing.
    &#34;&#34;&#34;

    def __call__(self, cx_count: int, num_iters: int):
        ...


@runtime_checkable
class AnnealingIterLogger(Protocol):
    &#34;&#34;&#34;
        Protocol for logging of iteration info in annealing.
    &#34;&#34;&#34;

    def __call__(self, it: int, prev_cx_count: int, new_cx_count: int,
                 accepted: bool, flip: Tuple[int, Tuple[int, int]],
                 t: float, num_iters: int):
        # pylint: disable = too-many-arguments
        ...


class AnnealingLoggers(TypedDict, total=False):
    &#34;&#34;&#34;
        Typed dictionary of loggers for annealing.
    &#34;&#34;&#34;

    log_start: AnnealingCostLogger
    log_iter: AnnealingIterLogger
    log_end: AnnealingCostLogger


def _validate_temp_schedule(schedule: Union[StandardTempSchedule, TempSchedule]) -&gt; TempSchedule:
    if not isinstance(schedule, TempSchedule):
        if not isinstance(schedule, tuple) or len(schedule) != 3:
            raise TypeError(f&#34;Expected triple (schedule_name, t_init, t_final), &#34;
                            f&#34;found {schedule}&#34;)
        schedule_name, t_init, t_final = schedule
        if schedule_name not in StandardTempSchedules:
            raise TypeError(f&#34;Invalid standard temperature schedule name {schedule_name}, &#34;
                            f&#34;allowed names are: {list(StandardTempSchedules.keys())}&#34;)
        if not isinstance(t_init, (int, float)) or not isinstance(t_final, (int, float)):
            raise TypeError(&#34;Expected t_init and t_final to be int or float.&#34;)
        schedule = StandardTempSchedules[schedule_name](t_init, t_final)
    return schedule


def _validate_loggers(loggers: AnnealingLoggers) -&gt; Tuple[Optional[AnnealingCostLogger],
                                                          Optional[AnnealingIterLogger],
                                                          Optional[AnnealingCostLogger]]:
    log_start = loggers.get(&#34;log_start&#34;, None)
    log_iter = loggers.get(&#34;log_iter&#34;, None)
    log_end = loggers.get(&#34;log_end&#34;, None)
    if log_start is not None and not isinstance(log_start, AnnealingCostLogger):
        raise TypeError(f&#34;Expected AnnealingCostLogger, found {type(log_start)}&#34;)
    if log_iter is not None and not isinstance(log_iter, AnnealingIterLogger):
        raise TypeError(f&#34;Expected AnnealingCostLogger, found {type(log_iter)}&#34;)
    if log_end is not None and not isinstance(log_end, AnnealingCostLogger):
        raise TypeError(f&#34;Expected AnnealingCostLogger, found {type(log_end)}&#34;)
    return log_start, log_iter, log_end


class PhaseCircuitOptimizer(Generic[AngleT]):
    # pylint: disable = too-many-instance-attributes
    &#34;&#34;&#34;
        Optimizer for phase circuits based on simulated annealing.
        The original phase circuit is passed to the constructor, together
        with a qubit topology and a fixed number of layers constraining the
        CX circuits to be used for simplification.

        To understand how this works, consider the following code snippet:

        ```py
            optimizer = PhaseCircuitCXBlockOptimizer(original_circuit, topology, num_layers)
            optimizer.anneal(num_iters, temp_schedule, cost_fun)
            phase_block = optimizer.phase_block
            cx_block = optimizer.cx_block
        ```

        The optimized circuit is obtained by composing three blocks:

        1. a first block of CX gates, given by `cx_block.dag`
           (the same CX gates of `cx_block`, but in reverse order);
        2. a central block of phase gadgets, given by `phase_block`;
        3. a final block of CX gates, given by `cx_block`.

        Furthermore, if the original circuit is repeated `n` times, e.g. as part
        of a quantum machine learning ansatz, then the corresponding optimized
        circuit is obtained by repeating the central `phase_block` alone `n` times,
        keeping the first and last CX blocks unaltered (because the intermediate
        CX blocks cancel each other out when repeating the optimized circuit `n` times).
    &#34;&#34;&#34;

    _topology: Topology
    _num_qubits: int
    _original_gadgets: Tuple[PhaseGadget, ...]
    _circuit_rep: int
    _init_cx_count: int
    _gadget_cx_count_cache: Dict[int, Dict[Tuple[int, ...], int]]
    _phase_block: PhaseCircuit[AngleT]
    _phase_block_view: PhaseCircuitView
    _cx_block: CXCircuit
    _cx_block_view: CXCircuitView
    _cx_count: int
    _rng_seed: Optional[int]
    _rng: np.random.Generator

    def __init__(self, original_circuit: PhaseCircuit[AngleT], topology: Topology, num_layers: int,
                 *, circuit_rep: int = 1, rng_seed: Optional[int] = None):
        if not isinstance(original_circuit, PhaseCircuit):
            raise TypeError(f&#34;Expected PhaseCircuit, found {type(original_circuit)}.&#34;)
        if not isinstance(topology, Topology):
            raise TypeError(f&#34;Expected Topology, found {type(topology)}.&#34;)
        if not isinstance(num_layers, int) or num_layers &lt;= 0:
            raise TypeError(f&#34;Expected positive integer, found {num_layers}.&#34;)
        if not isinstance(circuit_rep, int) or circuit_rep &lt;= 0:
            raise TypeError(f&#34;Expected positive integer, found {circuit_rep}.&#34;)
        if rng_seed is not None and not isinstance(rng_seed, int):
            raise TypeError(&#34;RNG seed must be integer or None.&#34;)
        self._topology = topology
        self._num_qubits = original_circuit.num_qubits
        self._original_gadgets = tuple(original_circuit.gadgets)
        self._circuit_rep = circuit_rep
        self._phase_block = PhaseCircuit(self._num_qubits, self._original_gadgets)
        self._cx_block = CXCircuit(topology,
                                   [CXCircuitLayer(topology) for _ in range(num_layers)])
        self._rng_seed = rng_seed
        self._rng = np.random.default_rng(seed=rng_seed)
        self._phase_block_view = PhaseCircuitView(self._phase_block)
        self._cx_block_view = CXCircuitView(self._cx_block)
        self._gadget_cx_count_cache = {}
        self._init_cx_count = self._compute_cx_count()
        self._cx_count = self._init_cx_count

    @property
    def topology(self) -&gt; Topology:
        &#34;&#34;&#34;
            Readonly property exposing the topology constraining the circuit optimization.
        &#34;&#34;&#34;
        return self._topology

    @property
    def num_qubits(self) -&gt; int:
        &#34;&#34;&#34;
            Readonly property exposing the number of qubits spanned by the circuit to be optimized.
        &#34;&#34;&#34;
        return self._num_qubits

    @property
    def original_gadgets(self) -&gt; Tuple[PhaseGadget, ...]:
        &#34;&#34;&#34;
            Readonly property exposing the gadgets in the original circuit to be optimized.
        &#34;&#34;&#34;
        return self._original_gadgets

    @property
    def circuit_rep(self) -&gt; int:
        &#34;&#34;&#34;
            Readonly property exposing the number of times that the original circuit is
            to be repeated, for use when computing CX counts.
        &#34;&#34;&#34;
        return self._circuit_rep

    @property
    def init_cx_count(self) -&gt; int:
        &#34;&#34;&#34;
            Readonly property exposing the CX count for the original circuit.
        &#34;&#34;&#34;
        return self._init_cx_count

    @property
    def phase_block(self) -&gt; PhaseCircuitView:
        &#34;&#34;&#34;
            Readonly property exposing a readonly view on the phase block of the optimized circuit.
        &#34;&#34;&#34;
        return self._phase_block_view

    @property
    def cx_block(self) -&gt; CXCircuitView:
        &#34;&#34;&#34;
            Readonly property exposing a readonly view on the CX block of the optimized circuit.
        &#34;&#34;&#34;
        return self._cx_block_view

    @property
    def cx_count(self) -&gt; int:
        &#34;&#34;&#34;
            Readonly property exposing the current CX count for the optimized circuit.
        &#34;&#34;&#34;
        return self._cx_count

    def as_qiskit_circuit(self):
        &#34;&#34;&#34;
            Returns the optimized circuit as a Qiskit circuit.

            This method relies on the `qiskit` library being available.
            Specifically, the `circuit` argument must be of type
            `qiskit.providers.BaseBackend`.
        &#34;&#34;&#34;
        try:
            # pylint: disable = import-outside-toplevel
            from qiskit.circuit import QuantumCircuit # type: ignore
        except ModuleNotFoundError as _:
            raise ModuleNotFoundError(&#34;You must install the &#39;qiskit&#39; library.&#34;)
        circuit = QuantumCircuit(self.num_qubits)
        for layer in reversed(self._cx_block):
            for ctrl, trgt in layer.gates:
                circuit.cx(ctrl, trgt)
        for __ in range(self._circuit_rep):
            for gadget in self._phase_block.gadgets:
                gadget.on_qiskit_circuit(self._topology, circuit)
        for layer in self._cx_block:
            for ctrl, trgt in layer.gates:
                circuit.cx(ctrl, trgt)
        return circuit

    def anneal(self,
               num_iters: int, *,
               schedule: Union[StandardTempSchedule, TempSchedule] = (&#34;linear&#34;, 1.0, 0.1),
               loggers: AnnealingLoggers = {}):
               # pylint: disable = dangerous-default-value
        # pylint: disable = too-many-locals
        &#34;&#34;&#34;
            Performs a cycle of simulated annealing optimization,
            using the given number of iterations, temperature schedule,
            initial/final temperatures.
        &#34;&#34;&#34;
        # Validate arguments:
        if not isinstance(num_iters, int) or num_iters &lt;= 0:
            raise TypeError(f&#34;Expected a positive integer, found {num_iters}.&#34;)
        schedule = _validate_temp_schedule(schedule)
        log_start, log_iter, log_end = _validate_loggers(loggers)
        # Log start:
        if log_start is not None:
            log_start(self._cx_count, num_iters)
        # Pre-sample random numbers to use in iterations:
        rand = self._rng.uniform(size=num_iters)
        # Run iterations:
        for it in range(num_iters):
            t = schedule(it, num_iters=num_iters)
            layer_idx, (ctrl, trgt) = self.random_flip_cx()
            new_cx_count = self._compute_cx_count()
            cx_count_diff = new_cx_count-self._cx_count
            accept_step = cx_count_diff &lt; 0 or rand[it] &lt; np.exp(-cx_count_diff/t)
            if log_iter is not None:
                log_iter(it, self._cx_count, new_cx_count, accept_step,
                         (layer_idx, (ctrl, trgt)), t, num_iters)
            if accept_step:
                # Accept changes:
                self._cx_count = new_cx_count
            else:
                # Undo changes:
                self._flip_cx(layer_idx, ctrl, trgt)
        # Log end:
        if log_end is not None:
            log_end(self._cx_count, num_iters)

    def random_flip_cx(self) -&gt; Tuple[int, Tuple[int, int]]:
        &#34;&#34;&#34;
            Randomly flips a CX gate in the CX circuit used for the optimization,
            updating both the CX circuit and the circuit being optimized.

            Returns the layer index and gate (pair of control and target) that were
            flipped (e.g. in case the flip needs to be subsequently undone).
        &#34;&#34;&#34;
        while True:
            layer_idx = int(self._rng.integers(len(self._cx_block)))
            ctrl, trgt = self._cx_block[layer_idx].random_flip_cx(self._rng)
            if layer_idx &lt; len(self._cx_block)-1 and self._cx_block[layer_idx+1].has_cx(ctrl, trgt):
                # Try again if CX gate already present in layer above (to avoid redundancy)
                continue
            if layer_idx &gt; 0 and self._cx_block[layer_idx-1].has_cx(ctrl, trgt):
                # Try again if CX gate already present in layer below (to avoid redundancy)
                continue
            self._flip_cx(layer_idx, ctrl, trgt)
            return layer_idx, (ctrl, trgt)

    def is_cx_flippable(self, layer_idx: int, ctrl: int, trgt: int) -&gt; bool:
        &#34;&#34;&#34;
            Checks whether the given CX gate can be flipped in the given layer.
        &#34;&#34;&#34;
        if not isinstance(layer_idx, int) or not 0 &lt;= layer_idx &lt; len(self._cx_block):
            raise TypeError(f&#34;Invalid layer index {layer_idx} for CX circuit.&#34;)
        layer = self._cx_block[layer_idx]
        return layer.is_cx_flippable(ctrl, trgt)

    def flip_cx(self, layer_idx: int, ctrl: int, trgt: int) -&gt; None:
        &#34;&#34;&#34;
            Performs the actions needed to flip the given CX gate in the given layer
            of the CX circuit used for the optimization:

            - undoes all gates in layers subsequent to the given layer which are
              causally following the given gate, starting from the last layer and
              working backwards towards the gate;
            - applies the desired gate;
            - redoes all gate undone, in reverse order (starting from the gate and
              working forwards towards the last layer).
        &#34;&#34;&#34;
        if not self.is_cx_flippable(layer_idx, ctrl, trgt):
            raise ValueError(f&#34;Gate {(ctrl, trgt)} cannot be flipped in layer number {layer_idx}.&#34;)
        self._flip_cx(layer_idx, ctrl, trgt)

    def _flip_cx(self, layer_idx: int, ctrl: int, trgt: int) -&gt; None:
        conj_by: Deque[Tuple[int, int]] = deque([(ctrl, trgt)])
        qubits_spanned: Set[int] = set([ctrl, trgt])
        for layer in self._cx_block[layer_idx:]:
            new_qubits_spanned: Set[int] = set()
            for q in qubits_spanned:
                incident_gate = layer.incident(q)
                if incident_gate is not None:
                    new_qubits_spanned.update({incident_gate[0], incident_gate[1]})
                    conj_by.appendleft(incident_gate) # will first undo the gate ...
                    # ... then do all gates already in conj_by ...
                    conj_by.append(incident_gate) # ... then finally redo the gate
            qubits_spanned.update(new_qubits_spanned)
        # Flip the gate in the CX circuit:
        self._cx_block[layer_idx].flip_cx(ctrl, trgt)
        # Conjugate the optimized phase gadget circuit by all necessary gates:
        for cx in conj_by:
            self._phase_block.conj_by_cx(*cx)

    def _compute_cx_count(self) -&gt; int:
        # pylint: disable = protected-access
        phase_block_cost = self._phase_block._cx_count(self._topology,
                                                       self._gadget_cx_count_cache)
        return self._circuit_rep*phase_block_cost + 2*self._cx_block.num_gates</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pauliopt.phase.optimizers.AnnealingCostLogger"><code class="flex name class">
<span>class <span class="ident">AnnealingCostLogger</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Protocol for logger of initial/final cost in annealing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AnnealingCostLogger(Protocol):
    &#34;&#34;&#34;
        Protocol for logger of initial/final cost in annealing.
    &#34;&#34;&#34;

    def __call__(self, cx_count: int, num_iters: int):
        ...</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="pauliopt.phase.optimizers.AnnealingIterLogger"><code class="flex name class">
<span>class <span class="ident">AnnealingIterLogger</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Protocol for logging of iteration info in annealing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AnnealingIterLogger(Protocol):
    &#34;&#34;&#34;
        Protocol for logging of iteration info in annealing.
    &#34;&#34;&#34;

    def __call__(self, it: int, prev_cx_count: int, new_cx_count: int,
                 accepted: bool, flip: Tuple[int, Tuple[int, int]],
                 t: float, num_iters: int):
        # pylint: disable = too-many-arguments
        ...</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="pauliopt.phase.optimizers.AnnealingLoggers"><code class="flex name class">
<span>class <span class="ident">AnnealingLoggers</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Typed dictionary of loggers for annealing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AnnealingLoggers(TypedDict, total=False):
    &#34;&#34;&#34;
        Typed dictionary of loggers for annealing.
    &#34;&#34;&#34;

    log_start: AnnealingCostLogger
    log_iter: AnnealingIterLogger
    log_end: AnnealingCostLogger</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pauliopt.phase.optimizers.AnnealingLoggers.log_end"><code class="name">var <span class="ident">log_end</span> : <a title="pauliopt.phase.optimizers.AnnealingCostLogger" href="#pauliopt.phase.optimizers.AnnealingCostLogger">AnnealingCostLogger</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pauliopt.phase.optimizers.AnnealingLoggers.log_iter"><code class="name">var <span class="ident">log_iter</span> : <a title="pauliopt.phase.optimizers.AnnealingIterLogger" href="#pauliopt.phase.optimizers.AnnealingIterLogger">AnnealingIterLogger</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pauliopt.phase.optimizers.AnnealingLoggers.log_start"><code class="name">var <span class="ident">log_start</span> : <a title="pauliopt.phase.optimizers.AnnealingCostLogger" href="#pauliopt.phase.optimizers.AnnealingCostLogger">AnnealingCostLogger</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="pauliopt.phase.optimizers.PhaseCircuitOptimizer"><code class="flex name class">
<span>class <span class="ident">PhaseCircuitOptimizer</span></span>
<span>(</span><span>original_circuit: <a title="pauliopt.phase.circuits.PhaseCircuit" href="circuits.html#pauliopt.phase.circuits.PhaseCircuit">PhaseCircuit</a>[~AngleT], topology: <a title="pauliopt.topologies.Topology" href="../topologies.html#pauliopt.topologies.Topology">Topology</a>, num_layers: int, *, circuit_rep: int = 1, rng_seed: Union[int, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Optimizer for phase circuits based on simulated annealing.
The original phase circuit is passed to the constructor, together
with a qubit topology and a fixed number of layers constraining the
CX circuits to be used for simplification.</p>
<p>To understand how this works, consider the following code snippet:</p>
<pre><code class="py">    optimizer = PhaseCircuitCXBlockOptimizer(original_circuit, topology, num_layers)
    optimizer.anneal(num_iters, temp_schedule, cost_fun)
    phase_block = optimizer.phase_block
    cx_block = optimizer.cx_block
</code></pre>
<p>The optimized circuit is obtained by composing three blocks:</p>
<ol>
<li>a first block of CX gates, given by <code>cx_block.dag</code>
(the same CX gates of <code>cx_block</code>, but in reverse order);</li>
<li>a central block of phase gadgets, given by <code>phase_block</code>;</li>
<li>a final block of CX gates, given by <code>cx_block</code>.</li>
</ol>
<p>Furthermore, if the original circuit is repeated <code>n</code> times, e.g. as part
of a quantum machine learning ansatz, then the corresponding optimized
circuit is obtained by repeating the central <code>phase_block</code> alone <code>n</code> times,
keeping the first and last CX blocks unaltered (because the intermediate
CX blocks cancel each other out when repeating the optimized circuit <code>n</code> times).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PhaseCircuitOptimizer(Generic[AngleT]):
    # pylint: disable = too-many-instance-attributes
    &#34;&#34;&#34;
        Optimizer for phase circuits based on simulated annealing.
        The original phase circuit is passed to the constructor, together
        with a qubit topology and a fixed number of layers constraining the
        CX circuits to be used for simplification.

        To understand how this works, consider the following code snippet:

        ```py
            optimizer = PhaseCircuitCXBlockOptimizer(original_circuit, topology, num_layers)
            optimizer.anneal(num_iters, temp_schedule, cost_fun)
            phase_block = optimizer.phase_block
            cx_block = optimizer.cx_block
        ```

        The optimized circuit is obtained by composing three blocks:

        1. a first block of CX gates, given by `cx_block.dag`
           (the same CX gates of `cx_block`, but in reverse order);
        2. a central block of phase gadgets, given by `phase_block`;
        3. a final block of CX gates, given by `cx_block`.

        Furthermore, if the original circuit is repeated `n` times, e.g. as part
        of a quantum machine learning ansatz, then the corresponding optimized
        circuit is obtained by repeating the central `phase_block` alone `n` times,
        keeping the first and last CX blocks unaltered (because the intermediate
        CX blocks cancel each other out when repeating the optimized circuit `n` times).
    &#34;&#34;&#34;

    _topology: Topology
    _num_qubits: int
    _original_gadgets: Tuple[PhaseGadget, ...]
    _circuit_rep: int
    _init_cx_count: int
    _gadget_cx_count_cache: Dict[int, Dict[Tuple[int, ...], int]]
    _phase_block: PhaseCircuit[AngleT]
    _phase_block_view: PhaseCircuitView
    _cx_block: CXCircuit
    _cx_block_view: CXCircuitView
    _cx_count: int
    _rng_seed: Optional[int]
    _rng: np.random.Generator

    def __init__(self, original_circuit: PhaseCircuit[AngleT], topology: Topology, num_layers: int,
                 *, circuit_rep: int = 1, rng_seed: Optional[int] = None):
        if not isinstance(original_circuit, PhaseCircuit):
            raise TypeError(f&#34;Expected PhaseCircuit, found {type(original_circuit)}.&#34;)
        if not isinstance(topology, Topology):
            raise TypeError(f&#34;Expected Topology, found {type(topology)}.&#34;)
        if not isinstance(num_layers, int) or num_layers &lt;= 0:
            raise TypeError(f&#34;Expected positive integer, found {num_layers}.&#34;)
        if not isinstance(circuit_rep, int) or circuit_rep &lt;= 0:
            raise TypeError(f&#34;Expected positive integer, found {circuit_rep}.&#34;)
        if rng_seed is not None and not isinstance(rng_seed, int):
            raise TypeError(&#34;RNG seed must be integer or None.&#34;)
        self._topology = topology
        self._num_qubits = original_circuit.num_qubits
        self._original_gadgets = tuple(original_circuit.gadgets)
        self._circuit_rep = circuit_rep
        self._phase_block = PhaseCircuit(self._num_qubits, self._original_gadgets)
        self._cx_block = CXCircuit(topology,
                                   [CXCircuitLayer(topology) for _ in range(num_layers)])
        self._rng_seed = rng_seed
        self._rng = np.random.default_rng(seed=rng_seed)
        self._phase_block_view = PhaseCircuitView(self._phase_block)
        self._cx_block_view = CXCircuitView(self._cx_block)
        self._gadget_cx_count_cache = {}
        self._init_cx_count = self._compute_cx_count()
        self._cx_count = self._init_cx_count

    @property
    def topology(self) -&gt; Topology:
        &#34;&#34;&#34;
            Readonly property exposing the topology constraining the circuit optimization.
        &#34;&#34;&#34;
        return self._topology

    @property
    def num_qubits(self) -&gt; int:
        &#34;&#34;&#34;
            Readonly property exposing the number of qubits spanned by the circuit to be optimized.
        &#34;&#34;&#34;
        return self._num_qubits

    @property
    def original_gadgets(self) -&gt; Tuple[PhaseGadget, ...]:
        &#34;&#34;&#34;
            Readonly property exposing the gadgets in the original circuit to be optimized.
        &#34;&#34;&#34;
        return self._original_gadgets

    @property
    def circuit_rep(self) -&gt; int:
        &#34;&#34;&#34;
            Readonly property exposing the number of times that the original circuit is
            to be repeated, for use when computing CX counts.
        &#34;&#34;&#34;
        return self._circuit_rep

    @property
    def init_cx_count(self) -&gt; int:
        &#34;&#34;&#34;
            Readonly property exposing the CX count for the original circuit.
        &#34;&#34;&#34;
        return self._init_cx_count

    @property
    def phase_block(self) -&gt; PhaseCircuitView:
        &#34;&#34;&#34;
            Readonly property exposing a readonly view on the phase block of the optimized circuit.
        &#34;&#34;&#34;
        return self._phase_block_view

    @property
    def cx_block(self) -&gt; CXCircuitView:
        &#34;&#34;&#34;
            Readonly property exposing a readonly view on the CX block of the optimized circuit.
        &#34;&#34;&#34;
        return self._cx_block_view

    @property
    def cx_count(self) -&gt; int:
        &#34;&#34;&#34;
            Readonly property exposing the current CX count for the optimized circuit.
        &#34;&#34;&#34;
        return self._cx_count

    def as_qiskit_circuit(self):
        &#34;&#34;&#34;
            Returns the optimized circuit as a Qiskit circuit.

            This method relies on the `qiskit` library being available.
            Specifically, the `circuit` argument must be of type
            `qiskit.providers.BaseBackend`.
        &#34;&#34;&#34;
        try:
            # pylint: disable = import-outside-toplevel
            from qiskit.circuit import QuantumCircuit # type: ignore
        except ModuleNotFoundError as _:
            raise ModuleNotFoundError(&#34;You must install the &#39;qiskit&#39; library.&#34;)
        circuit = QuantumCircuit(self.num_qubits)
        for layer in reversed(self._cx_block):
            for ctrl, trgt in layer.gates:
                circuit.cx(ctrl, trgt)
        for __ in range(self._circuit_rep):
            for gadget in self._phase_block.gadgets:
                gadget.on_qiskit_circuit(self._topology, circuit)
        for layer in self._cx_block:
            for ctrl, trgt in layer.gates:
                circuit.cx(ctrl, trgt)
        return circuit

    def anneal(self,
               num_iters: int, *,
               schedule: Union[StandardTempSchedule, TempSchedule] = (&#34;linear&#34;, 1.0, 0.1),
               loggers: AnnealingLoggers = {}):
               # pylint: disable = dangerous-default-value
        # pylint: disable = too-many-locals
        &#34;&#34;&#34;
            Performs a cycle of simulated annealing optimization,
            using the given number of iterations, temperature schedule,
            initial/final temperatures.
        &#34;&#34;&#34;
        # Validate arguments:
        if not isinstance(num_iters, int) or num_iters &lt;= 0:
            raise TypeError(f&#34;Expected a positive integer, found {num_iters}.&#34;)
        schedule = _validate_temp_schedule(schedule)
        log_start, log_iter, log_end = _validate_loggers(loggers)
        # Log start:
        if log_start is not None:
            log_start(self._cx_count, num_iters)
        # Pre-sample random numbers to use in iterations:
        rand = self._rng.uniform(size=num_iters)
        # Run iterations:
        for it in range(num_iters):
            t = schedule(it, num_iters=num_iters)
            layer_idx, (ctrl, trgt) = self.random_flip_cx()
            new_cx_count = self._compute_cx_count()
            cx_count_diff = new_cx_count-self._cx_count
            accept_step = cx_count_diff &lt; 0 or rand[it] &lt; np.exp(-cx_count_diff/t)
            if log_iter is not None:
                log_iter(it, self._cx_count, new_cx_count, accept_step,
                         (layer_idx, (ctrl, trgt)), t, num_iters)
            if accept_step:
                # Accept changes:
                self._cx_count = new_cx_count
            else:
                # Undo changes:
                self._flip_cx(layer_idx, ctrl, trgt)
        # Log end:
        if log_end is not None:
            log_end(self._cx_count, num_iters)

    def random_flip_cx(self) -&gt; Tuple[int, Tuple[int, int]]:
        &#34;&#34;&#34;
            Randomly flips a CX gate in the CX circuit used for the optimization,
            updating both the CX circuit and the circuit being optimized.

            Returns the layer index and gate (pair of control and target) that were
            flipped (e.g. in case the flip needs to be subsequently undone).
        &#34;&#34;&#34;
        while True:
            layer_idx = int(self._rng.integers(len(self._cx_block)))
            ctrl, trgt = self._cx_block[layer_idx].random_flip_cx(self._rng)
            if layer_idx &lt; len(self._cx_block)-1 and self._cx_block[layer_idx+1].has_cx(ctrl, trgt):
                # Try again if CX gate already present in layer above (to avoid redundancy)
                continue
            if layer_idx &gt; 0 and self._cx_block[layer_idx-1].has_cx(ctrl, trgt):
                # Try again if CX gate already present in layer below (to avoid redundancy)
                continue
            self._flip_cx(layer_idx, ctrl, trgt)
            return layer_idx, (ctrl, trgt)

    def is_cx_flippable(self, layer_idx: int, ctrl: int, trgt: int) -&gt; bool:
        &#34;&#34;&#34;
            Checks whether the given CX gate can be flipped in the given layer.
        &#34;&#34;&#34;
        if not isinstance(layer_idx, int) or not 0 &lt;= layer_idx &lt; len(self._cx_block):
            raise TypeError(f&#34;Invalid layer index {layer_idx} for CX circuit.&#34;)
        layer = self._cx_block[layer_idx]
        return layer.is_cx_flippable(ctrl, trgt)

    def flip_cx(self, layer_idx: int, ctrl: int, trgt: int) -&gt; None:
        &#34;&#34;&#34;
            Performs the actions needed to flip the given CX gate in the given layer
            of the CX circuit used for the optimization:

            - undoes all gates in layers subsequent to the given layer which are
              causally following the given gate, starting from the last layer and
              working backwards towards the gate;
            - applies the desired gate;
            - redoes all gate undone, in reverse order (starting from the gate and
              working forwards towards the last layer).
        &#34;&#34;&#34;
        if not self.is_cx_flippable(layer_idx, ctrl, trgt):
            raise ValueError(f&#34;Gate {(ctrl, trgt)} cannot be flipped in layer number {layer_idx}.&#34;)
        self._flip_cx(layer_idx, ctrl, trgt)

    def _flip_cx(self, layer_idx: int, ctrl: int, trgt: int) -&gt; None:
        conj_by: Deque[Tuple[int, int]] = deque([(ctrl, trgt)])
        qubits_spanned: Set[int] = set([ctrl, trgt])
        for layer in self._cx_block[layer_idx:]:
            new_qubits_spanned: Set[int] = set()
            for q in qubits_spanned:
                incident_gate = layer.incident(q)
                if incident_gate is not None:
                    new_qubits_spanned.update({incident_gate[0], incident_gate[1]})
                    conj_by.appendleft(incident_gate) # will first undo the gate ...
                    # ... then do all gates already in conj_by ...
                    conj_by.append(incident_gate) # ... then finally redo the gate
            qubits_spanned.update(new_qubits_spanned)
        # Flip the gate in the CX circuit:
        self._cx_block[layer_idx].flip_cx(ctrl, trgt)
        # Conjugate the optimized phase gadget circuit by all necessary gates:
        for cx in conj_by:
            self._phase_block.conj_by_cx(*cx)

    def _compute_cx_count(self) -&gt; int:
        # pylint: disable = protected-access
        phase_block_cost = self._phase_block._cx_count(self._topology,
                                                       self._gadget_cx_count_cache)
        return self._circuit_rep*phase_block_cost + 2*self._cx_block.num_gates</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pauliopt.phase.optimizers.PhaseCircuitOptimizer.circuit_rep"><code class="name">var <span class="ident">circuit_rep</span> : int</code></dt>
<dd>
<div class="desc"><p>Readonly property exposing the number of times that the original circuit is
to be repeated, for use when computing CX counts.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def circuit_rep(self) -&gt; int:
    &#34;&#34;&#34;
        Readonly property exposing the number of times that the original circuit is
        to be repeated, for use when computing CX counts.
    &#34;&#34;&#34;
    return self._circuit_rep</code></pre>
</details>
</dd>
<dt id="pauliopt.phase.optimizers.PhaseCircuitOptimizer.cx_block"><code class="name">var <span class="ident">cx_block</span> : <a title="pauliopt.phase.circuits.CXCircuitView" href="circuits.html#pauliopt.phase.circuits.CXCircuitView">CXCircuitView</a></code></dt>
<dd>
<div class="desc"><p>Readonly property exposing a readonly view on the CX block of the optimized circuit.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cx_block(self) -&gt; CXCircuitView:
    &#34;&#34;&#34;
        Readonly property exposing a readonly view on the CX block of the optimized circuit.
    &#34;&#34;&#34;
    return self._cx_block_view</code></pre>
</details>
</dd>
<dt id="pauliopt.phase.optimizers.PhaseCircuitOptimizer.cx_count"><code class="name">var <span class="ident">cx_count</span> : int</code></dt>
<dd>
<div class="desc"><p>Readonly property exposing the current CX count for the optimized circuit.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cx_count(self) -&gt; int:
    &#34;&#34;&#34;
        Readonly property exposing the current CX count for the optimized circuit.
    &#34;&#34;&#34;
    return self._cx_count</code></pre>
</details>
</dd>
<dt id="pauliopt.phase.optimizers.PhaseCircuitOptimizer.init_cx_count"><code class="name">var <span class="ident">init_cx_count</span> : int</code></dt>
<dd>
<div class="desc"><p>Readonly property exposing the CX count for the original circuit.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def init_cx_count(self) -&gt; int:
    &#34;&#34;&#34;
        Readonly property exposing the CX count for the original circuit.
    &#34;&#34;&#34;
    return self._init_cx_count</code></pre>
</details>
</dd>
<dt id="pauliopt.phase.optimizers.PhaseCircuitOptimizer.num_qubits"><code class="name">var <span class="ident">num_qubits</span> : int</code></dt>
<dd>
<div class="desc"><p>Readonly property exposing the number of qubits spanned by the circuit to be optimized.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def num_qubits(self) -&gt; int:
    &#34;&#34;&#34;
        Readonly property exposing the number of qubits spanned by the circuit to be optimized.
    &#34;&#34;&#34;
    return self._num_qubits</code></pre>
</details>
</dd>
<dt id="pauliopt.phase.optimizers.PhaseCircuitOptimizer.original_gadgets"><code class="name">var <span class="ident">original_gadgets</span> : Tuple[<a title="pauliopt.phase.circuits.PhaseGadget" href="circuits.html#pauliopt.phase.circuits.PhaseGadget">PhaseGadget</a>, ...]</code></dt>
<dd>
<div class="desc"><p>Readonly property exposing the gadgets in the original circuit to be optimized.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def original_gadgets(self) -&gt; Tuple[PhaseGadget, ...]:
    &#34;&#34;&#34;
        Readonly property exposing the gadgets in the original circuit to be optimized.
    &#34;&#34;&#34;
    return self._original_gadgets</code></pre>
</details>
</dd>
<dt id="pauliopt.phase.optimizers.PhaseCircuitOptimizer.phase_block"><code class="name">var <span class="ident">phase_block</span> : <a title="pauliopt.phase.circuits.PhaseCircuitView" href="circuits.html#pauliopt.phase.circuits.PhaseCircuitView">PhaseCircuitView</a></code></dt>
<dd>
<div class="desc"><p>Readonly property exposing a readonly view on the phase block of the optimized circuit.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def phase_block(self) -&gt; PhaseCircuitView:
    &#34;&#34;&#34;
        Readonly property exposing a readonly view on the phase block of the optimized circuit.
    &#34;&#34;&#34;
    return self._phase_block_view</code></pre>
</details>
</dd>
<dt id="pauliopt.phase.optimizers.PhaseCircuitOptimizer.topology"><code class="name">var <span class="ident">topology</span> : <a title="pauliopt.topologies.Topology" href="../topologies.html#pauliopt.topologies.Topology">Topology</a></code></dt>
<dd>
<div class="desc"><p>Readonly property exposing the topology constraining the circuit optimization.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def topology(self) -&gt; Topology:
    &#34;&#34;&#34;
        Readonly property exposing the topology constraining the circuit optimization.
    &#34;&#34;&#34;
    return self._topology</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pauliopt.phase.optimizers.PhaseCircuitOptimizer.anneal"><code class="name flex">
<span>def <span class="ident">anneal</span></span>(<span>self, num_iters: int, *, schedule: Union[Tuple[Literal['linear', 'geometric', 'reciprocal', 'log'], Union[int, float], Union[int, float]], <a title="pauliopt.utils.TempSchedule" href="../utils.html#pauliopt.utils.TempSchedule">TempSchedule</a>] = ('linear', 1.0, 0.1), loggers: <a title="pauliopt.phase.optimizers.AnnealingLoggers" href="#pauliopt.phase.optimizers.AnnealingLoggers">AnnealingLoggers</a> = {})</span>
</code></dt>
<dd>
<div class="desc"><p>Performs a cycle of simulated annealing optimization,
using the given number of iterations, temperature schedule,
initial/final temperatures.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def anneal(self,
           num_iters: int, *,
           schedule: Union[StandardTempSchedule, TempSchedule] = (&#34;linear&#34;, 1.0, 0.1),
           loggers: AnnealingLoggers = {}):
           # pylint: disable = dangerous-default-value
    # pylint: disable = too-many-locals
    &#34;&#34;&#34;
        Performs a cycle of simulated annealing optimization,
        using the given number of iterations, temperature schedule,
        initial/final temperatures.
    &#34;&#34;&#34;
    # Validate arguments:
    if not isinstance(num_iters, int) or num_iters &lt;= 0:
        raise TypeError(f&#34;Expected a positive integer, found {num_iters}.&#34;)
    schedule = _validate_temp_schedule(schedule)
    log_start, log_iter, log_end = _validate_loggers(loggers)
    # Log start:
    if log_start is not None:
        log_start(self._cx_count, num_iters)
    # Pre-sample random numbers to use in iterations:
    rand = self._rng.uniform(size=num_iters)
    # Run iterations:
    for it in range(num_iters):
        t = schedule(it, num_iters=num_iters)
        layer_idx, (ctrl, trgt) = self.random_flip_cx()
        new_cx_count = self._compute_cx_count()
        cx_count_diff = new_cx_count-self._cx_count
        accept_step = cx_count_diff &lt; 0 or rand[it] &lt; np.exp(-cx_count_diff/t)
        if log_iter is not None:
            log_iter(it, self._cx_count, new_cx_count, accept_step,
                     (layer_idx, (ctrl, trgt)), t, num_iters)
        if accept_step:
            # Accept changes:
            self._cx_count = new_cx_count
        else:
            # Undo changes:
            self._flip_cx(layer_idx, ctrl, trgt)
    # Log end:
    if log_end is not None:
        log_end(self._cx_count, num_iters)</code></pre>
</details>
</dd>
<dt id="pauliopt.phase.optimizers.PhaseCircuitOptimizer.as_qiskit_circuit"><code class="name flex">
<span>def <span class="ident">as_qiskit_circuit</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the optimized circuit as a Qiskit circuit.</p>
<p>This method relies on the <code>qiskit</code> library being available.
Specifically, the <code>circuit</code> argument must be of type
<code>qiskit.providers.BaseBackend</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_qiskit_circuit(self):
    &#34;&#34;&#34;
        Returns the optimized circuit as a Qiskit circuit.

        This method relies on the `qiskit` library being available.
        Specifically, the `circuit` argument must be of type
        `qiskit.providers.BaseBackend`.
    &#34;&#34;&#34;
    try:
        # pylint: disable = import-outside-toplevel
        from qiskit.circuit import QuantumCircuit # type: ignore
    except ModuleNotFoundError as _:
        raise ModuleNotFoundError(&#34;You must install the &#39;qiskit&#39; library.&#34;)
    circuit = QuantumCircuit(self.num_qubits)
    for layer in reversed(self._cx_block):
        for ctrl, trgt in layer.gates:
            circuit.cx(ctrl, trgt)
    for __ in range(self._circuit_rep):
        for gadget in self._phase_block.gadgets:
            gadget.on_qiskit_circuit(self._topology, circuit)
    for layer in self._cx_block:
        for ctrl, trgt in layer.gates:
            circuit.cx(ctrl, trgt)
    return circuit</code></pre>
</details>
</dd>
<dt id="pauliopt.phase.optimizers.PhaseCircuitOptimizer.flip_cx"><code class="name flex">
<span>def <span class="ident">flip_cx</span></span>(<span>self, layer_idx: int, ctrl: int, trgt: int) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Performs the actions needed to flip the given CX gate in the given layer
of the CX circuit used for the optimization:</p>
<ul>
<li>undoes all gates in layers subsequent to the given layer which are
causally following the given gate, starting from the last layer and
working backwards towards the gate;</li>
<li>applies the desired gate;</li>
<li>redoes all gate undone, in reverse order (starting from the gate and
working forwards towards the last layer).</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flip_cx(self, layer_idx: int, ctrl: int, trgt: int) -&gt; None:
    &#34;&#34;&#34;
        Performs the actions needed to flip the given CX gate in the given layer
        of the CX circuit used for the optimization:

        - undoes all gates in layers subsequent to the given layer which are
          causally following the given gate, starting from the last layer and
          working backwards towards the gate;
        - applies the desired gate;
        - redoes all gate undone, in reverse order (starting from the gate and
          working forwards towards the last layer).
    &#34;&#34;&#34;
    if not self.is_cx_flippable(layer_idx, ctrl, trgt):
        raise ValueError(f&#34;Gate {(ctrl, trgt)} cannot be flipped in layer number {layer_idx}.&#34;)
    self._flip_cx(layer_idx, ctrl, trgt)</code></pre>
</details>
</dd>
<dt id="pauliopt.phase.optimizers.PhaseCircuitOptimizer.is_cx_flippable"><code class="name flex">
<span>def <span class="ident">is_cx_flippable</span></span>(<span>self, layer_idx: int, ctrl: int, trgt: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whether the given CX gate can be flipped in the given layer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_cx_flippable(self, layer_idx: int, ctrl: int, trgt: int) -&gt; bool:
    &#34;&#34;&#34;
        Checks whether the given CX gate can be flipped in the given layer.
    &#34;&#34;&#34;
    if not isinstance(layer_idx, int) or not 0 &lt;= layer_idx &lt; len(self._cx_block):
        raise TypeError(f&#34;Invalid layer index {layer_idx} for CX circuit.&#34;)
    layer = self._cx_block[layer_idx]
    return layer.is_cx_flippable(ctrl, trgt)</code></pre>
</details>
</dd>
<dt id="pauliopt.phase.optimizers.PhaseCircuitOptimizer.random_flip_cx"><code class="name flex">
<span>def <span class="ident">random_flip_cx</span></span>(<span>self) ‑> Tuple[int, Tuple[int, int]]</span>
</code></dt>
<dd>
<div class="desc"><p>Randomly flips a CX gate in the CX circuit used for the optimization,
updating both the CX circuit and the circuit being optimized.</p>
<p>Returns the layer index and gate (pair of control and target) that were
flipped (e.g. in case the flip needs to be subsequently undone).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def random_flip_cx(self) -&gt; Tuple[int, Tuple[int, int]]:
    &#34;&#34;&#34;
        Randomly flips a CX gate in the CX circuit used for the optimization,
        updating both the CX circuit and the circuit being optimized.

        Returns the layer index and gate (pair of control and target) that were
        flipped (e.g. in case the flip needs to be subsequently undone).
    &#34;&#34;&#34;
    while True:
        layer_idx = int(self._rng.integers(len(self._cx_block)))
        ctrl, trgt = self._cx_block[layer_idx].random_flip_cx(self._rng)
        if layer_idx &lt; len(self._cx_block)-1 and self._cx_block[layer_idx+1].has_cx(ctrl, trgt):
            # Try again if CX gate already present in layer above (to avoid redundancy)
            continue
        if layer_idx &gt; 0 and self._cx_block[layer_idx-1].has_cx(ctrl, trgt):
            # Try again if CX gate already present in layer below (to avoid redundancy)
            continue
        self._flip_cx(layer_idx, ctrl, trgt)
        return layer_idx, (ctrl, trgt)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pauliopt.phase" href="index.html">pauliopt.phase</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pauliopt.phase.optimizers.AnnealingCostLogger" href="#pauliopt.phase.optimizers.AnnealingCostLogger">AnnealingCostLogger</a></code></h4>
</li>
<li>
<h4><code><a title="pauliopt.phase.optimizers.AnnealingIterLogger" href="#pauliopt.phase.optimizers.AnnealingIterLogger">AnnealingIterLogger</a></code></h4>
</li>
<li>
<h4><code><a title="pauliopt.phase.optimizers.AnnealingLoggers" href="#pauliopt.phase.optimizers.AnnealingLoggers">AnnealingLoggers</a></code></h4>
<ul class="">
<li><code><a title="pauliopt.phase.optimizers.AnnealingLoggers.log_end" href="#pauliopt.phase.optimizers.AnnealingLoggers.log_end">log_end</a></code></li>
<li><code><a title="pauliopt.phase.optimizers.AnnealingLoggers.log_iter" href="#pauliopt.phase.optimizers.AnnealingLoggers.log_iter">log_iter</a></code></li>
<li><code><a title="pauliopt.phase.optimizers.AnnealingLoggers.log_start" href="#pauliopt.phase.optimizers.AnnealingLoggers.log_start">log_start</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pauliopt.phase.optimizers.PhaseCircuitOptimizer" href="#pauliopt.phase.optimizers.PhaseCircuitOptimizer">PhaseCircuitOptimizer</a></code></h4>
<ul class="two-column">
<li><code><a title="pauliopt.phase.optimizers.PhaseCircuitOptimizer.anneal" href="#pauliopt.phase.optimizers.PhaseCircuitOptimizer.anneal">anneal</a></code></li>
<li><code><a title="pauliopt.phase.optimizers.PhaseCircuitOptimizer.as_qiskit_circuit" href="#pauliopt.phase.optimizers.PhaseCircuitOptimizer.as_qiskit_circuit">as_qiskit_circuit</a></code></li>
<li><code><a title="pauliopt.phase.optimizers.PhaseCircuitOptimizer.circuit_rep" href="#pauliopt.phase.optimizers.PhaseCircuitOptimizer.circuit_rep">circuit_rep</a></code></li>
<li><code><a title="pauliopt.phase.optimizers.PhaseCircuitOptimizer.cx_block" href="#pauliopt.phase.optimizers.PhaseCircuitOptimizer.cx_block">cx_block</a></code></li>
<li><code><a title="pauliopt.phase.optimizers.PhaseCircuitOptimizer.cx_count" href="#pauliopt.phase.optimizers.PhaseCircuitOptimizer.cx_count">cx_count</a></code></li>
<li><code><a title="pauliopt.phase.optimizers.PhaseCircuitOptimizer.flip_cx" href="#pauliopt.phase.optimizers.PhaseCircuitOptimizer.flip_cx">flip_cx</a></code></li>
<li><code><a title="pauliopt.phase.optimizers.PhaseCircuitOptimizer.init_cx_count" href="#pauliopt.phase.optimizers.PhaseCircuitOptimizer.init_cx_count">init_cx_count</a></code></li>
<li><code><a title="pauliopt.phase.optimizers.PhaseCircuitOptimizer.is_cx_flippable" href="#pauliopt.phase.optimizers.PhaseCircuitOptimizer.is_cx_flippable">is_cx_flippable</a></code></li>
<li><code><a title="pauliopt.phase.optimizers.PhaseCircuitOptimizer.num_qubits" href="#pauliopt.phase.optimizers.PhaseCircuitOptimizer.num_qubits">num_qubits</a></code></li>
<li><code><a title="pauliopt.phase.optimizers.PhaseCircuitOptimizer.original_gadgets" href="#pauliopt.phase.optimizers.PhaseCircuitOptimizer.original_gadgets">original_gadgets</a></code></li>
<li><code><a title="pauliopt.phase.optimizers.PhaseCircuitOptimizer.phase_block" href="#pauliopt.phase.optimizers.PhaseCircuitOptimizer.phase_block">phase_block</a></code></li>
<li><code><a title="pauliopt.phase.optimizers.PhaseCircuitOptimizer.random_flip_cx" href="#pauliopt.phase.optimizers.PhaseCircuitOptimizer.random_flip_cx">random_flip_cx</a></code></li>
<li><code><a title="pauliopt.phase.optimizers.PhaseCircuitOptimizer.topology" href="#pauliopt.phase.optimizers.PhaseCircuitOptimizer.topology">topology</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>