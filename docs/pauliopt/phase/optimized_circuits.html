<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>pauliopt.phase.optimized_circuits API documentation</title>
<meta name="description" content="This module contains code to optimize circuits of mixed ZX phase gadgets
using topologically-aware circuits of CNOTs." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pauliopt.phase.optimized_circuits</code></h1>
</header>
<section id="section-intro">
<p>This module contains code to optimize circuits of mixed ZX phase gadgets
using topologically-aware circuits of CNOTs.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
    This module contains code to optimize circuits of mixed ZX phase gadgets
    using topologically-aware circuits of CNOTs.
&#34;&#34;&#34;

from collections import deque
from math import ceil, log10
from typing import (Deque, Dict, Generic, List, Optional, Protocol, runtime_checkable,
                    Set, Tuple, TypedDict, Union)
import numpy as np # type: ignore
from pauliopt.phase.phase_circuits import PhaseCircuit, PhaseCircuitView
from pauliopt.phase.cx_circuits import CXCircuitLayer, CXCircuit, CXCircuitView
from pauliopt.topologies import Topology
from pauliopt.utils import (AngleT, TempSchedule, StandardTempSchedule,
                            StandardTempSchedules, SVGBuilder)

@runtime_checkable
class AnnealingCostLogger(Protocol):
    &#34;&#34;&#34;
        Protocol for logger of initial/final cost in annealing.
    &#34;&#34;&#34;

    def __call__(self, cx_count: int, num_iters: int):
        ...


@runtime_checkable
class AnnealingIterLogger(Protocol):
    &#34;&#34;&#34;
        Protocol for logging of iteration info in annealing.
    &#34;&#34;&#34;

    def __call__(self, it: int, prev_cx_count: int, new_cx_count: int,
                 accepted: bool, flip: Tuple[int, Tuple[int, int]],
                 t: float, num_iters: int):
        # pylint: disable = too-many-arguments
        ...


class AnnealingLoggers(TypedDict, total=False):
    &#34;&#34;&#34;
        Typed dictionary of loggers for annealing.
    &#34;&#34;&#34;

    log_start: AnnealingCostLogger
    log_iter: AnnealingIterLogger
    log_end: AnnealingCostLogger


def _validate_temp_schedule(schedule: Union[StandardTempSchedule, TempSchedule]) -&gt; TempSchedule:
    if not isinstance(schedule, TempSchedule):
        if not isinstance(schedule, tuple) or len(schedule) != 3:
            raise TypeError(f&#34;Expected triple (schedule_name, t_init, t_final), &#34;
                            f&#34;found {schedule}&#34;)
        schedule_name, t_init, t_final = schedule
        if schedule_name not in StandardTempSchedules:
            raise TypeError(f&#34;Invalid standard temperature schedule name {schedule_name}, &#34;
                            f&#34;allowed names are: {list(StandardTempSchedules.keys())}&#34;)
        if not isinstance(t_init, (int, float)) or not isinstance(t_final, (int, float)):
            raise TypeError(&#34;Expected t_init and t_final to be int or float.&#34;)
        schedule = StandardTempSchedules[schedule_name](t_init, t_final)
    return schedule


def _validate_loggers(loggers: AnnealingLoggers) -&gt; Tuple[Optional[AnnealingCostLogger],
                                                          Optional[AnnealingIterLogger],
                                                          Optional[AnnealingCostLogger]]:
    log_start = loggers.get(&#34;log_start&#34;, None)
    log_iter = loggers.get(&#34;log_iter&#34;, None)
    log_end = loggers.get(&#34;log_end&#34;, None)
    if log_start is not None and not isinstance(log_start, AnnealingCostLogger):
        raise TypeError(f&#34;Expected AnnealingCostLogger, found {type(log_start)}&#34;)
    if log_iter is not None and not isinstance(log_iter, AnnealingIterLogger):
        raise TypeError(f&#34;Expected AnnealingCostLogger, found {type(log_iter)}&#34;)
    if log_end is not None and not isinstance(log_end, AnnealingCostLogger):
        raise TypeError(f&#34;Expected AnnealingCostLogger, found {type(log_end)}&#34;)
    return log_start, log_iter, log_end


class OptimizedPhaseCircuit(Generic[AngleT]):
    # pylint: disable = too-many-instance-attributes
    &#34;&#34;&#34;
        Container for a phase circuit to be progressively optimized.
        The original phase circuit is passed to the constructor, together
        with a qubit topology and a fixed number of layers constraining the
        CX circuit to be used for simplification.

        To understand the structure of the optimized phase circuit,
        consider the following code snippet:

        ```py
            opt_circ = PhaseCircuitCXBlockOptimizer(orig_circ, topology, num_cx_layers)
            # perform optimization using the methods of `opt_circ`
            phase_block = opt_circ.phase_block
            cx_block = opt_circ.cx_block
        ```

        The optimized circuit is obtained by composing three blocks:

        1. a first block of CX gates, given by `cx_block.dag()`
           (the same CX gates of `cx_block`, but in reverse order);
        2. a central block of phase gadgets, given by `phase_block`;
        3. a final block of CX gates, given by `cx_block`.

        An optional keyword argument `circuit_rep` (default: 1) can be passed to the
        constructor to indicate that the original circuit is to be repeated a certain
        number of times (default: 1). In the optimized circuit, this is achieved by
        repeating the `phase_block` part (at point 2. above) a number of times
        given by the `circuit_rep` argument.
        The first and last CX blocks are left unaltered (because the intermediate CX
        blocks would cancel each other out in pairs when repeating the optimized circuit).
    &#34;&#34;&#34;

    _topology: Topology
    _circuit_rep: int
    _phase_block: PhaseCircuit[AngleT]
    _phase_block_view: PhaseCircuitView
    _cx_block: CXCircuit
    _cx_block_view: CXCircuitView
    _init_cx_count: int
    _cx_count: int
    _init_cx_blocks_count: int
    _cx_blocks_count: int
    _gadget_cx_count_cache: Dict[int, Dict[Tuple[int, ...], int]]
    _rng_seed: Optional[int]
    _rng: np.random.Generator

    def __init__(self, phase_block: Union[PhaseCircuit[AngleT], PhaseCircuitView[AngleT]],
                 topology: Topology,
                 cx_block: Union[int, CXCircuit, CXCircuitView],
                 *,
                 circuit_rep: int = 1,
                 rng_seed: Optional[int] = None):
        if not isinstance(phase_block, PhaseCircuit):
            raise TypeError(f&#34;Expected PhaseCircuit, found {type(phase_block)}.&#34;)
        if not isinstance(topology, Topology):
            raise TypeError(f&#34;Expected Topology, found {type(topology)}.&#34;)
        if not isinstance(circuit_rep, int) or circuit_rep &lt;= 0:
            raise TypeError(f&#34;Expected positive integer, found {circuit_rep}.&#34;)
        if not isinstance(cx_block, (int, CXCircuit, CXCircuitView)):
            raise TypeError(f&#34;Expected int, CXCircuit or CXCircuitView, found {type(cx_block)}.&#34;)
        if isinstance(cx_block, int) and cx_block &lt;= 0:
            raise TypeError(f&#34;Expected positive integer number of CX layers, found {cx_block}.&#34;)
        if rng_seed is not None and not isinstance(rng_seed, int):
            raise TypeError(&#34;RNG seed must be integer or None.&#34;)
        self._topology = topology
        self._circuit_rep = circuit_rep
        self._phase_block = phase_block.clone()
        if isinstance(cx_block, int):
            self._cx_block = CXCircuit(topology,
                                       [CXCircuitLayer(topology) for _ in range(cx_block)])
        else:
            self._cx_block = cx_block.clone()
        self._rng_seed = rng_seed
        self._rng = np.random.default_rng(seed=rng_seed)
        self._phase_block_view = PhaseCircuitView(self._phase_block)
        self._cx_block_view = CXCircuitView(self._cx_block)
        self._gadget_cx_count_cache = {}
        self._init_cx_count, self._init_cx_blocks_count = self._compute_cx_count()
        self._cx_count = self._init_cx_count
        self._cx_blocks_count = self._init_cx_blocks_count

    @property
    def topology(self) -&gt; Topology:
        &#34;&#34;&#34;
            Readonly property exposing the topology constraining the circuit optimization.
        &#34;&#34;&#34;
        return self._topology

    @property
    def num_qubits(self) -&gt; int:
        &#34;&#34;&#34;
            Readonly property exposing the number of qubits spanned by the circuit to be optimized.
        &#34;&#34;&#34;
        return self._phase_block.num_qubits

    @property
    def circuit_rep(self) -&gt; int:
        &#34;&#34;&#34;
            Readonly property exposing the number of times that the original circuit is
            to be repeated, for use when computing CX counts.
        &#34;&#34;&#34;
        return self._circuit_rep

    @property
    def phase_block(self) -&gt; PhaseCircuitView:
        &#34;&#34;&#34;
            Readonly property exposing a readonly view on the phase block of the optimized circuit.
        &#34;&#34;&#34;
        return self._phase_block_view

    @property
    def cx_block(self) -&gt; CXCircuitView:
        &#34;&#34;&#34;
            Readonly property exposing a readonly view on the CX block of the optimized circuit.
        &#34;&#34;&#34;
        return self._cx_block_view

    @property
    def init_cx_count(self) -&gt; int:
        &#34;&#34;&#34;
            Readonly property exposing the CX count for the original circuit.
        &#34;&#34;&#34;
        return self._init_cx_count

    @property
    def cx_count(self) -&gt; int:
        &#34;&#34;&#34;
            Readonly property exposing the current CX count for the optimized circuit.
        &#34;&#34;&#34;
        return self._cx_count

    @property
    def init_cx_blocks_count(self) -&gt; int:
        &#34;&#34;&#34;
            Readonly property exposing the overall CX count for the two conjugating
            CX blocks at the time the circuit was instantiated.
        &#34;&#34;&#34;
        return self._init_cx_blocks_count

    @property
    def cx_blocks_count(self) -&gt; int:
        &#34;&#34;&#34;
            Readonly property exposing the overall CX count for the conjugating
            CX blocks in the currently optimized circuit.
        &#34;&#34;&#34;
        return self._cx_blocks_count

    @property
    def init_phase_block_cx_count(self) -&gt; int:
        &#34;&#34;&#34;
            Readonly property exposing the overall CX count for a single
            phase block at the time the circuit was instantiated.
        &#34;&#34;&#34;
        return (self.init_cx_count-self.init_cx_blocks_count)//self.circuit_rep

    @property
    def phase_block_cx_count(self) -&gt; int:
        &#34;&#34;&#34;
            Readonly property exposing the overall CX count for a single
            phase block in the currently optimized circuit.
        &#34;&#34;&#34;
        return (self.cx_count-self.cx_blocks_count)//self.circuit_rep

    def clone(self, rng_seed: Optional[int] = None) -&gt; &#34;OptimizedPhaseCircuit&#34;:
        &#34;&#34;&#34;
            Returns a copy of this optimized phase circuit.
        &#34;&#34;&#34;
        return OptimizedPhaseCircuit(self.phase_block, self.topology, self.cx_block,
                                     circuit_rep=self.circuit_rep, rng_seed=rng_seed)

    def to_qiskit(self):
        &#34;&#34;&#34;
            Returns the optimized circuit as a Qiskit circuit.

            This method relies on the `qiskit` library being available.
            Specifically, the `circuit` argument must be of type
            `qiskit.providers.BaseBackend`.
        &#34;&#34;&#34;
        try:
            # pylint: disable = import-outside-toplevel
            from qiskit.circuit import QuantumCircuit # type: ignore
        except ModuleNotFoundError as _:
            raise ModuleNotFoundError(&#34;You must install the &#39;qiskit&#39; library.&#34;)
        circuit = QuantumCircuit(self.num_qubits)
        for layer in reversed(self._cx_block):
            for ctrl, trgt in layer.gates:
                circuit.cx(ctrl, trgt)
        for __ in range(self._circuit_rep):
            for gadget in self._phase_block.gadgets:
                gadget.on_qiskit_circuit(self._topology, circuit)
        for layer in self._cx_block:
            for ctrl, trgt in layer.gates:
                circuit.cx(ctrl, trgt)
        return circuit

    def anneal(self,
               num_iters: int, *,
               schedule: Union[StandardTempSchedule, TempSchedule] = (&#34;linear&#34;, 1.0, 0.1),
               loggers: AnnealingLoggers = {}):
               # pylint: disable = dangerous-default-value
        # pylint: disable = too-many-locals
        &#34;&#34;&#34;
            Performs a cycle of simulated annealing optimization,
            using the given number of iterations, temperature schedule,
            initial/final temperatures.

            The circuit is modified in-place and then returned, as per the
            [fluent API pattern](https://en.wikipedia.org/wiki/Fluent_interface).
        &#34;&#34;&#34;
        # Validate arguments:
        if not isinstance(num_iters, int) or num_iters &lt;= 0:
            raise TypeError(f&#34;Expected a positive integer, found {num_iters}.&#34;)
        schedule = _validate_temp_schedule(schedule)
        log_start, log_iter, log_end = _validate_loggers(loggers)
        # Log start:
        if log_start is not None:
            log_start(self._cx_count, num_iters)
        # Pre-sample random numbers to use in iterations:
        rand = self._rng.uniform(size=num_iters)
        # Run iterations:
        for it in range(num_iters):
            t = schedule(it, num_iters=num_iters)
            layer_idx, (ctrl, trgt) = self.random_flip_cx()
            new_cx_count, new_cx_blocks_count = self._compute_cx_count()
            cx_count_diff = new_cx_count-self._cx_count
            accept_step = cx_count_diff &lt; 0 or rand[it] &lt; np.exp(-cx_count_diff/t)
            if log_iter is not None:
                log_iter(it, self._cx_count, new_cx_count, accept_step,
                         (layer_idx, (ctrl, trgt)), t, num_iters)
            if accept_step:
                # Accept changes:
                self._cx_count = new_cx_count
                self._cx_blocks_count = new_cx_blocks_count
            else:
                # Undo changes:
                self._flip_cx(layer_idx, ctrl, trgt)
        # Log end:
        if log_end is not None:
            log_end(self._cx_count, num_iters)

    def random_flip_cx(self) -&gt; Tuple[int, Tuple[int, int]]:
        &#34;&#34;&#34;
            Randomly flips a CX gate in the CX circuit used for the optimization,
            updating both the CX circuit and the circuit being optimized.

            Returns the layer index and gate (pair of control and target) that were
            flipped (e.g. in case the flip needs to be subsequently undone).
        &#34;&#34;&#34;
        while True:
            layer_idx = int(self._rng.integers(len(self._cx_block)))
            ctrl, trgt = self._cx_block[layer_idx].random_flip_cx(self._rng)
            if layer_idx &lt; len(self._cx_block)-1 and self._cx_block[layer_idx+1].has_cx(ctrl, trgt):
                # Try again if CX gate already present in layer above (to avoid redundancy)
                continue
            if layer_idx &gt; 0 and self._cx_block[layer_idx-1].has_cx(ctrl, trgt):
                # Try again if CX gate already present in layer below (to avoid redundancy)
                continue
            self._flip_cx(layer_idx, ctrl, trgt)
            return layer_idx, (ctrl, trgt)

    def is_cx_flippable(self, layer_idx: int, ctrl: int, trgt: int) -&gt; bool:
        &#34;&#34;&#34;
            Checks whether the given CX gate can be flipped in the given layer.
        &#34;&#34;&#34;
        if not isinstance(layer_idx, int) or not 0 &lt;= layer_idx &lt; len(self._cx_block):
            raise TypeError(f&#34;Invalid layer index {layer_idx} for CX circuit.&#34;)
        layer = self._cx_block[layer_idx]
        return layer.is_cx_flippable(ctrl, trgt)

    def flip_cx(self, layer_idx: int, ctrl: int, trgt: int):
        &#34;&#34;&#34;
            Performs the actions needed to flip the given CX gate in the given layer
            of the CX circuit used for the optimization:

            - undoes all gates in layers subsequent to the given layer which are
              causally following the given gate, starting from the last layer and
              working backwards towards the gate;
            - applies the desired gate;
            - redoes all gate undone, in reverse order (starting from the gate and
              working forwards towards the last layer).
        &#34;&#34;&#34;
        if not self.is_cx_flippable(layer_idx, ctrl, trgt):
            raise ValueError(f&#34;Gate {(ctrl, trgt)} cannot be flipped in layer number {layer_idx}.&#34;)
        self._flip_cx(layer_idx, ctrl, trgt)

    def _flip_cx(self, layer_idx: int, ctrl: int, trgt: int) -&gt; None:
        conj_by: Deque[Tuple[int, int]] = deque([(ctrl, trgt)])
        qubits_spanned: Set[int] = set([ctrl, trgt])
        for layer in self._cx_block[layer_idx:]:
            new_qubits_spanned: Set[int] = set()
            for q in qubits_spanned:
                incident_gate = layer.incident(q)
                if incident_gate is not None:
                    new_qubits_spanned.update({incident_gate[0], incident_gate[1]})
                    conj_by.appendleft(incident_gate) # will first undo the gate ...
                    # ... then do all gates already in conj_by ...
                    conj_by.append(incident_gate) # ... then finally redo the gate
            qubits_spanned.update(new_qubits_spanned)
        # Flip the gate in the CX circuit:
        self._cx_block[layer_idx].flip_cx(ctrl, trgt)
        # Conjugate the optimized phase gadget circuit by all necessary gates:
        for cx in conj_by:
            self._phase_block.conj_by_cx(*cx)

    def _compute_cx_count(self) -&gt; Tuple[int, int]:
        # pylint: disable = protected-access
        phase_block_cost = self._phase_block._cx_count(self._topology,
                                                       self._gadget_cx_count_cache)
        cx_blocks_count = 2*self._cx_block.num_gates
        cx_count = self._circuit_rep*phase_block_cost + cx_blocks_count
        return cx_count, cx_blocks_count

    def to_svg(self, *,
               zcolor: str = &#34;#CCFFCC&#34;,
               xcolor: str = &#34;#FF8888&#34;,
               hscale: float = 1.0, vscale: float = 1.0,
               scale: float = 1.0,
               svg_code_only: bool = False
               ):
        &#34;&#34;&#34;
            Returns an SVG representation of this optimized circuit, using
            the ZX calculus to express phase gadgets and CX gates.

            The keyword arguments `zcolor` and `xcolor` can be used to
            specify a colour for the Z and X basis spiders in the circuit.
            The keyword arguments `hscale` and `vscale` can be used to
            scale the circuit representation horizontally and vertically.
            The keyword argument `scale` can be used to scale the circuit
            representation isotropically.
            The keyword argument `svg_code_only` (default `False`) can be used
            to specify that the SVG code itself be returned, rather than the
            IPython `SVG` object.
        &#34;&#34;&#34;
        if not isinstance(zcolor, str):
            raise TypeError(&#34;Keyword argument &#39;zcolor&#39; must be string.&#34;)
        if not isinstance(xcolor, str):
            raise TypeError(&#34;Keyword argument &#39;xcolor&#39; must be string.&#34;)
        if not isinstance(hscale, (int, float)) or hscale &lt;= 0.0:
            raise TypeError(&#34;Keyword argument &#39;hscale&#39; must be positive float.&#34;)
        if not isinstance(vscale, (int, float)) or vscale &lt;= 0.0:
            raise TypeError(&#34;Keyword argument &#39;vscale&#39; must be positive float.&#34;)
        if not isinstance(scale, (int, float)) or scale &lt;= 0.0:
            raise TypeError(&#34;Keyword argument &#39;scale&#39; must be positive float.&#34;)
        return self._to_svg(zcolor=zcolor, xcolor=xcolor,
                            hscale=hscale, vscale=vscale, scale=scale,
                            svg_code_only=svg_code_only)

    def __eq__(self, other) -&gt; bool:
        if self is other:
            return True
        if not isinstance(other, OptimizedPhaseCircuit):
            return NotImplemented
        if self.circuit_rep != other.circuit_rep:
            return False
        if self.phase_block != other.phase_block:
            return False
        if self.cx_block != other.cx_block:
            return False
        return True

    def _to_svg(self, *,
                zcolor: str = &#34;#CCFFCC&#34;,
                xcolor: str = &#34;#FF8888&#34;,
                hscale: float = 1.0, vscale: float = 1.0,
                scale: float = 1.0,
                svg_code_only: bool = False
                ):
        # pylint: disable = too-many-locals, too-many-statements
        # TODO: reuse from phase circuit once cleaned up and restructured
        num_qubits = self.num_qubits
        vscale *= scale
        hscale *= scale
        cx_block = self._cx_block
        phase_block = self._phase_block
        pre_cx_gates = [gate for layer in reversed(cx_block) for gate in layer.gates]
        gadgets = list(phase_block.gadgets)*self._circuit_rep
        post_cx_gates = list(reversed(pre_cx_gates))
        _layers: List[int] = [0 for _ in range(num_qubits)]
        pre_cx_gates_depths: List[int] = []
        max_cx_gates_depth: int = 0
        for gate in pre_cx_gates:
            m = min(gate)
            M = max(gate)
            d = max(_layers[q] for q in range(m, M+1))
            max_cx_gates_depth = max(max_cx_gates_depth, d+1)
            pre_cx_gates_depths.append(d)
            for q in range(m, M+1):
                _layers[q] = d+1
        post_cx_gates_depths: List[int] = [max_cx_gates_depth - d
                                           for d in reversed(pre_cx_gates_depths)]
        num_digits = int(ceil(log10(num_qubits)))
        line_height = int(ceil(30*vscale))
        row_width = int(ceil(100*hscale))
        cx_row_width = int(ceil(40*hscale))
        pad_x = int(ceil(10*hscale))
        margin_x = int(ceil(40*hscale))
        pad_y = int(ceil(20*vscale))
        r = pad_y//2-2
        font_size = 2*r
        pad_x += font_size*(num_digits+1)
        delta_fst = row_width//2
        delta_snd = 3*row_width//4
        width = (2*pad_x + 2*margin_x + row_width*len(gadgets)
                 + 2*max_cx_gates_depth * cx_row_width)
        height = pad_y + line_height*(num_qubits+1)
        builder = SVGBuilder(width, height)
        for q in range(num_qubits):
            y = pad_y + (q+1) * line_height
            builder.line((pad_x, y), (width-pad_x, y))
            builder.text((0, y), f&#34;{str(q):&gt;{num_digits}}&#34;, font_size=font_size)
            builder.text((width-pad_x+r, y), f&#34;{str(q):&gt;{num_digits}}&#34;, font_size=font_size)
        for i, (ctrl, trgt) in enumerate(pre_cx_gates):
            row = pre_cx_gates_depths[i]
            x = pad_x + margin_x + row * cx_row_width
            y_ctrl = pad_y + (ctrl+1)*line_height
            y_trgt = pad_y + (trgt+1)*line_height
            builder.line((x, y_ctrl), (x, y_trgt))
            builder.circle((x, y_ctrl), r, zcolor)
            builder.circle((x, y_trgt), r, xcolor)
        for _row, gadget in enumerate(gadgets):
            fill = zcolor if gadget.basis == &#34;Z&#34; else xcolor
            other_fill = xcolor if gadget.basis == &#34;Z&#34; else zcolor
            row = _row
            x = pad_x + margin_x + row * row_width + max_cx_gates_depth * cx_row_width
            for q in gadget.qubits:
                y = pad_y + (q+1)*line_height
                builder.line((x, y), (x+delta_fst, pad_y))
            for q in gadget.qubits:
                y = pad_y + (q+1)*line_height
                builder.circle((x, y), r, fill)
            builder.line((x+delta_fst, pad_y), (x+delta_snd, pad_y))
            builder.circle((x+delta_fst, pad_y), r, other_fill)
            builder.circle((x+delta_snd, pad_y), r, fill)
            builder.text((x+delta_snd+2*r, pad_y), str(gadget.angle), font_size=font_size)
        for i, (ctrl, trgt) in enumerate(post_cx_gates):
            row = post_cx_gates_depths[i]
            x = (pad_x + margin_x + len(gadgets) * row_width
                 + (row+max_cx_gates_depth) * cx_row_width)
            y_ctrl = pad_y + (ctrl+1)*line_height
            y_trgt = pad_y + (trgt+1)*line_height
            builder.line((x, y_ctrl), (x, y_trgt))
            builder.circle((x, y_ctrl), r, zcolor)
            builder.circle((x, y_trgt), r, xcolor)
        svg_code = repr(builder)
        if svg_code_only:
            return svg_code
        try:
            # pylint: disable = import-outside-toplevel
            from IPython.core.display import SVG # type: ignore
        except ModuleNotFoundError as _:
            raise ModuleNotFoundError(&#34;You must install the &#39;IPython&#39; library.&#34;)
        return SVG(svg_code)

    def _repr_svg_(self):
        &#34;&#34;&#34;
            Magic method for IPython/Jupyter pretty-printing.
            See https://ipython.readthedocs.io/en/stable/api/generated/IPython.display.html
        &#34;&#34;&#34;
        return self._to_svg(svg_code_only=True)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pauliopt.phase.optimized_circuits.AnnealingCostLogger"><code class="flex name class">
<span>class <span class="ident">AnnealingCostLogger</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Protocol for logger of initial/final cost in annealing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AnnealingCostLogger(Protocol):
    &#34;&#34;&#34;
        Protocol for logger of initial/final cost in annealing.
    &#34;&#34;&#34;

    def __call__(self, cx_count: int, num_iters: int):
        ...</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="pauliopt.phase.optimized_circuits.AnnealingIterLogger"><code class="flex name class">
<span>class <span class="ident">AnnealingIterLogger</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Protocol for logging of iteration info in annealing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AnnealingIterLogger(Protocol):
    &#34;&#34;&#34;
        Protocol for logging of iteration info in annealing.
    &#34;&#34;&#34;

    def __call__(self, it: int, prev_cx_count: int, new_cx_count: int,
                 accepted: bool, flip: Tuple[int, Tuple[int, int]],
                 t: float, num_iters: int):
        # pylint: disable = too-many-arguments
        ...</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="pauliopt.phase.optimized_circuits.AnnealingLoggers"><code class="flex name class">
<span>class <span class="ident">AnnealingLoggers</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Typed dictionary of loggers for annealing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AnnealingLoggers(TypedDict, total=False):
    &#34;&#34;&#34;
        Typed dictionary of loggers for annealing.
    &#34;&#34;&#34;

    log_start: AnnealingCostLogger
    log_iter: AnnealingIterLogger
    log_end: AnnealingCostLogger</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pauliopt.phase.optimized_circuits.AnnealingLoggers.log_end"><code class="name">var <span class="ident">log_end</span> : <a title="pauliopt.phase.optimized_circuits.AnnealingCostLogger" href="#pauliopt.phase.optimized_circuits.AnnealingCostLogger">AnnealingCostLogger</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pauliopt.phase.optimized_circuits.AnnealingLoggers.log_iter"><code class="name">var <span class="ident">log_iter</span> : <a title="pauliopt.phase.optimized_circuits.AnnealingIterLogger" href="#pauliopt.phase.optimized_circuits.AnnealingIterLogger">AnnealingIterLogger</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pauliopt.phase.optimized_circuits.AnnealingLoggers.log_start"><code class="name">var <span class="ident">log_start</span> : <a title="pauliopt.phase.optimized_circuits.AnnealingCostLogger" href="#pauliopt.phase.optimized_circuits.AnnealingCostLogger">AnnealingCostLogger</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit"><code class="flex name class">
<span>class <span class="ident">OptimizedPhaseCircuit</span></span>
<span>(</span><span>phase_block: Union[<a title="pauliopt.phase.phase_circuits.PhaseCircuit" href="phase_circuits.html#pauliopt.phase.phase_circuits.PhaseCircuit">PhaseCircuit</a>[~AngleT], <a title="pauliopt.phase.phase_circuits.PhaseCircuitView" href="phase_circuits.html#pauliopt.phase.phase_circuits.PhaseCircuitView">PhaseCircuitView</a>[~AngleT]], topology: <a title="pauliopt.topologies.Topology" href="../topologies.html#pauliopt.topologies.Topology">Topology</a>, cx_block: Union[int, <a title="pauliopt.phase.cx_circuits.CXCircuit" href="cx_circuits.html#pauliopt.phase.cx_circuits.CXCircuit">CXCircuit</a>, <a title="pauliopt.phase.cx_circuits.CXCircuitView" href="cx_circuits.html#pauliopt.phase.cx_circuits.CXCircuitView">CXCircuitView</a>], *, circuit_rep: int = 1, rng_seed: Union[int, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Container for a phase circuit to be progressively optimized.
The original phase circuit is passed to the constructor, together
with a qubit topology and a fixed number of layers constraining the
CX circuit to be used for simplification.</p>
<p>To understand the structure of the optimized phase circuit,
consider the following code snippet:</p>
<pre><code class="py">    opt_circ = PhaseCircuitCXBlockOptimizer(orig_circ, topology, num_cx_layers)
    # perform optimization using the methods of `opt_circ`
    phase_block = opt_circ.phase_block
    cx_block = opt_circ.cx_block
</code></pre>
<p>The optimized circuit is obtained by composing three blocks:</p>
<ol>
<li>a first block of CX gates, given by <code>cx_block.dag()</code>
(the same CX gates of <code>cx_block</code>, but in reverse order);</li>
<li>a central block of phase gadgets, given by <code>phase_block</code>;</li>
<li>a final block of CX gates, given by <code>cx_block</code>.</li>
</ol>
<p>An optional keyword argument <code>circuit_rep</code> (default: 1) can be passed to the
constructor to indicate that the original circuit is to be repeated a certain
number of times (default: 1). In the optimized circuit, this is achieved by
repeating the <code>phase_block</code> part (at point 2. above) a number of times
given by the <code>circuit_rep</code> argument.
The first and last CX blocks are left unaltered (because the intermediate CX
blocks would cancel each other out in pairs when repeating the optimized circuit).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OptimizedPhaseCircuit(Generic[AngleT]):
    # pylint: disable = too-many-instance-attributes
    &#34;&#34;&#34;
        Container for a phase circuit to be progressively optimized.
        The original phase circuit is passed to the constructor, together
        with a qubit topology and a fixed number of layers constraining the
        CX circuit to be used for simplification.

        To understand the structure of the optimized phase circuit,
        consider the following code snippet:

        ```py
            opt_circ = PhaseCircuitCXBlockOptimizer(orig_circ, topology, num_cx_layers)
            # perform optimization using the methods of `opt_circ`
            phase_block = opt_circ.phase_block
            cx_block = opt_circ.cx_block
        ```

        The optimized circuit is obtained by composing three blocks:

        1. a first block of CX gates, given by `cx_block.dag()`
           (the same CX gates of `cx_block`, but in reverse order);
        2. a central block of phase gadgets, given by `phase_block`;
        3. a final block of CX gates, given by `cx_block`.

        An optional keyword argument `circuit_rep` (default: 1) can be passed to the
        constructor to indicate that the original circuit is to be repeated a certain
        number of times (default: 1). In the optimized circuit, this is achieved by
        repeating the `phase_block` part (at point 2. above) a number of times
        given by the `circuit_rep` argument.
        The first and last CX blocks are left unaltered (because the intermediate CX
        blocks would cancel each other out in pairs when repeating the optimized circuit).
    &#34;&#34;&#34;

    _topology: Topology
    _circuit_rep: int
    _phase_block: PhaseCircuit[AngleT]
    _phase_block_view: PhaseCircuitView
    _cx_block: CXCircuit
    _cx_block_view: CXCircuitView
    _init_cx_count: int
    _cx_count: int
    _init_cx_blocks_count: int
    _cx_blocks_count: int
    _gadget_cx_count_cache: Dict[int, Dict[Tuple[int, ...], int]]
    _rng_seed: Optional[int]
    _rng: np.random.Generator

    def __init__(self, phase_block: Union[PhaseCircuit[AngleT], PhaseCircuitView[AngleT]],
                 topology: Topology,
                 cx_block: Union[int, CXCircuit, CXCircuitView],
                 *,
                 circuit_rep: int = 1,
                 rng_seed: Optional[int] = None):
        if not isinstance(phase_block, PhaseCircuit):
            raise TypeError(f&#34;Expected PhaseCircuit, found {type(phase_block)}.&#34;)
        if not isinstance(topology, Topology):
            raise TypeError(f&#34;Expected Topology, found {type(topology)}.&#34;)
        if not isinstance(circuit_rep, int) or circuit_rep &lt;= 0:
            raise TypeError(f&#34;Expected positive integer, found {circuit_rep}.&#34;)
        if not isinstance(cx_block, (int, CXCircuit, CXCircuitView)):
            raise TypeError(f&#34;Expected int, CXCircuit or CXCircuitView, found {type(cx_block)}.&#34;)
        if isinstance(cx_block, int) and cx_block &lt;= 0:
            raise TypeError(f&#34;Expected positive integer number of CX layers, found {cx_block}.&#34;)
        if rng_seed is not None and not isinstance(rng_seed, int):
            raise TypeError(&#34;RNG seed must be integer or None.&#34;)
        self._topology = topology
        self._circuit_rep = circuit_rep
        self._phase_block = phase_block.clone()
        if isinstance(cx_block, int):
            self._cx_block = CXCircuit(topology,
                                       [CXCircuitLayer(topology) for _ in range(cx_block)])
        else:
            self._cx_block = cx_block.clone()
        self._rng_seed = rng_seed
        self._rng = np.random.default_rng(seed=rng_seed)
        self._phase_block_view = PhaseCircuitView(self._phase_block)
        self._cx_block_view = CXCircuitView(self._cx_block)
        self._gadget_cx_count_cache = {}
        self._init_cx_count, self._init_cx_blocks_count = self._compute_cx_count()
        self._cx_count = self._init_cx_count
        self._cx_blocks_count = self._init_cx_blocks_count

    @property
    def topology(self) -&gt; Topology:
        &#34;&#34;&#34;
            Readonly property exposing the topology constraining the circuit optimization.
        &#34;&#34;&#34;
        return self._topology

    @property
    def num_qubits(self) -&gt; int:
        &#34;&#34;&#34;
            Readonly property exposing the number of qubits spanned by the circuit to be optimized.
        &#34;&#34;&#34;
        return self._phase_block.num_qubits

    @property
    def circuit_rep(self) -&gt; int:
        &#34;&#34;&#34;
            Readonly property exposing the number of times that the original circuit is
            to be repeated, for use when computing CX counts.
        &#34;&#34;&#34;
        return self._circuit_rep

    @property
    def phase_block(self) -&gt; PhaseCircuitView:
        &#34;&#34;&#34;
            Readonly property exposing a readonly view on the phase block of the optimized circuit.
        &#34;&#34;&#34;
        return self._phase_block_view

    @property
    def cx_block(self) -&gt; CXCircuitView:
        &#34;&#34;&#34;
            Readonly property exposing a readonly view on the CX block of the optimized circuit.
        &#34;&#34;&#34;
        return self._cx_block_view

    @property
    def init_cx_count(self) -&gt; int:
        &#34;&#34;&#34;
            Readonly property exposing the CX count for the original circuit.
        &#34;&#34;&#34;
        return self._init_cx_count

    @property
    def cx_count(self) -&gt; int:
        &#34;&#34;&#34;
            Readonly property exposing the current CX count for the optimized circuit.
        &#34;&#34;&#34;
        return self._cx_count

    @property
    def init_cx_blocks_count(self) -&gt; int:
        &#34;&#34;&#34;
            Readonly property exposing the overall CX count for the two conjugating
            CX blocks at the time the circuit was instantiated.
        &#34;&#34;&#34;
        return self._init_cx_blocks_count

    @property
    def cx_blocks_count(self) -&gt; int:
        &#34;&#34;&#34;
            Readonly property exposing the overall CX count for the conjugating
            CX blocks in the currently optimized circuit.
        &#34;&#34;&#34;
        return self._cx_blocks_count

    @property
    def init_phase_block_cx_count(self) -&gt; int:
        &#34;&#34;&#34;
            Readonly property exposing the overall CX count for a single
            phase block at the time the circuit was instantiated.
        &#34;&#34;&#34;
        return (self.init_cx_count-self.init_cx_blocks_count)//self.circuit_rep

    @property
    def phase_block_cx_count(self) -&gt; int:
        &#34;&#34;&#34;
            Readonly property exposing the overall CX count for a single
            phase block in the currently optimized circuit.
        &#34;&#34;&#34;
        return (self.cx_count-self.cx_blocks_count)//self.circuit_rep

    def clone(self, rng_seed: Optional[int] = None) -&gt; &#34;OptimizedPhaseCircuit&#34;:
        &#34;&#34;&#34;
            Returns a copy of this optimized phase circuit.
        &#34;&#34;&#34;
        return OptimizedPhaseCircuit(self.phase_block, self.topology, self.cx_block,
                                     circuit_rep=self.circuit_rep, rng_seed=rng_seed)

    def to_qiskit(self):
        &#34;&#34;&#34;
            Returns the optimized circuit as a Qiskit circuit.

            This method relies on the `qiskit` library being available.
            Specifically, the `circuit` argument must be of type
            `qiskit.providers.BaseBackend`.
        &#34;&#34;&#34;
        try:
            # pylint: disable = import-outside-toplevel
            from qiskit.circuit import QuantumCircuit # type: ignore
        except ModuleNotFoundError as _:
            raise ModuleNotFoundError(&#34;You must install the &#39;qiskit&#39; library.&#34;)
        circuit = QuantumCircuit(self.num_qubits)
        for layer in reversed(self._cx_block):
            for ctrl, trgt in layer.gates:
                circuit.cx(ctrl, trgt)
        for __ in range(self._circuit_rep):
            for gadget in self._phase_block.gadgets:
                gadget.on_qiskit_circuit(self._topology, circuit)
        for layer in self._cx_block:
            for ctrl, trgt in layer.gates:
                circuit.cx(ctrl, trgt)
        return circuit

    def anneal(self,
               num_iters: int, *,
               schedule: Union[StandardTempSchedule, TempSchedule] = (&#34;linear&#34;, 1.0, 0.1),
               loggers: AnnealingLoggers = {}):
               # pylint: disable = dangerous-default-value
        # pylint: disable = too-many-locals
        &#34;&#34;&#34;
            Performs a cycle of simulated annealing optimization,
            using the given number of iterations, temperature schedule,
            initial/final temperatures.

            The circuit is modified in-place and then returned, as per the
            [fluent API pattern](https://en.wikipedia.org/wiki/Fluent_interface).
        &#34;&#34;&#34;
        # Validate arguments:
        if not isinstance(num_iters, int) or num_iters &lt;= 0:
            raise TypeError(f&#34;Expected a positive integer, found {num_iters}.&#34;)
        schedule = _validate_temp_schedule(schedule)
        log_start, log_iter, log_end = _validate_loggers(loggers)
        # Log start:
        if log_start is not None:
            log_start(self._cx_count, num_iters)
        # Pre-sample random numbers to use in iterations:
        rand = self._rng.uniform(size=num_iters)
        # Run iterations:
        for it in range(num_iters):
            t = schedule(it, num_iters=num_iters)
            layer_idx, (ctrl, trgt) = self.random_flip_cx()
            new_cx_count, new_cx_blocks_count = self._compute_cx_count()
            cx_count_diff = new_cx_count-self._cx_count
            accept_step = cx_count_diff &lt; 0 or rand[it] &lt; np.exp(-cx_count_diff/t)
            if log_iter is not None:
                log_iter(it, self._cx_count, new_cx_count, accept_step,
                         (layer_idx, (ctrl, trgt)), t, num_iters)
            if accept_step:
                # Accept changes:
                self._cx_count = new_cx_count
                self._cx_blocks_count = new_cx_blocks_count
            else:
                # Undo changes:
                self._flip_cx(layer_idx, ctrl, trgt)
        # Log end:
        if log_end is not None:
            log_end(self._cx_count, num_iters)

    def random_flip_cx(self) -&gt; Tuple[int, Tuple[int, int]]:
        &#34;&#34;&#34;
            Randomly flips a CX gate in the CX circuit used for the optimization,
            updating both the CX circuit and the circuit being optimized.

            Returns the layer index and gate (pair of control and target) that were
            flipped (e.g. in case the flip needs to be subsequently undone).
        &#34;&#34;&#34;
        while True:
            layer_idx = int(self._rng.integers(len(self._cx_block)))
            ctrl, trgt = self._cx_block[layer_idx].random_flip_cx(self._rng)
            if layer_idx &lt; len(self._cx_block)-1 and self._cx_block[layer_idx+1].has_cx(ctrl, trgt):
                # Try again if CX gate already present in layer above (to avoid redundancy)
                continue
            if layer_idx &gt; 0 and self._cx_block[layer_idx-1].has_cx(ctrl, trgt):
                # Try again if CX gate already present in layer below (to avoid redundancy)
                continue
            self._flip_cx(layer_idx, ctrl, trgt)
            return layer_idx, (ctrl, trgt)

    def is_cx_flippable(self, layer_idx: int, ctrl: int, trgt: int) -&gt; bool:
        &#34;&#34;&#34;
            Checks whether the given CX gate can be flipped in the given layer.
        &#34;&#34;&#34;
        if not isinstance(layer_idx, int) or not 0 &lt;= layer_idx &lt; len(self._cx_block):
            raise TypeError(f&#34;Invalid layer index {layer_idx} for CX circuit.&#34;)
        layer = self._cx_block[layer_idx]
        return layer.is_cx_flippable(ctrl, trgt)

    def flip_cx(self, layer_idx: int, ctrl: int, trgt: int):
        &#34;&#34;&#34;
            Performs the actions needed to flip the given CX gate in the given layer
            of the CX circuit used for the optimization:

            - undoes all gates in layers subsequent to the given layer which are
              causally following the given gate, starting from the last layer and
              working backwards towards the gate;
            - applies the desired gate;
            - redoes all gate undone, in reverse order (starting from the gate and
              working forwards towards the last layer).
        &#34;&#34;&#34;
        if not self.is_cx_flippable(layer_idx, ctrl, trgt):
            raise ValueError(f&#34;Gate {(ctrl, trgt)} cannot be flipped in layer number {layer_idx}.&#34;)
        self._flip_cx(layer_idx, ctrl, trgt)

    def _flip_cx(self, layer_idx: int, ctrl: int, trgt: int) -&gt; None:
        conj_by: Deque[Tuple[int, int]] = deque([(ctrl, trgt)])
        qubits_spanned: Set[int] = set([ctrl, trgt])
        for layer in self._cx_block[layer_idx:]:
            new_qubits_spanned: Set[int] = set()
            for q in qubits_spanned:
                incident_gate = layer.incident(q)
                if incident_gate is not None:
                    new_qubits_spanned.update({incident_gate[0], incident_gate[1]})
                    conj_by.appendleft(incident_gate) # will first undo the gate ...
                    # ... then do all gates already in conj_by ...
                    conj_by.append(incident_gate) # ... then finally redo the gate
            qubits_spanned.update(new_qubits_spanned)
        # Flip the gate in the CX circuit:
        self._cx_block[layer_idx].flip_cx(ctrl, trgt)
        # Conjugate the optimized phase gadget circuit by all necessary gates:
        for cx in conj_by:
            self._phase_block.conj_by_cx(*cx)

    def _compute_cx_count(self) -&gt; Tuple[int, int]:
        # pylint: disable = protected-access
        phase_block_cost = self._phase_block._cx_count(self._topology,
                                                       self._gadget_cx_count_cache)
        cx_blocks_count = 2*self._cx_block.num_gates
        cx_count = self._circuit_rep*phase_block_cost + cx_blocks_count
        return cx_count, cx_blocks_count

    def to_svg(self, *,
               zcolor: str = &#34;#CCFFCC&#34;,
               xcolor: str = &#34;#FF8888&#34;,
               hscale: float = 1.0, vscale: float = 1.0,
               scale: float = 1.0,
               svg_code_only: bool = False
               ):
        &#34;&#34;&#34;
            Returns an SVG representation of this optimized circuit, using
            the ZX calculus to express phase gadgets and CX gates.

            The keyword arguments `zcolor` and `xcolor` can be used to
            specify a colour for the Z and X basis spiders in the circuit.
            The keyword arguments `hscale` and `vscale` can be used to
            scale the circuit representation horizontally and vertically.
            The keyword argument `scale` can be used to scale the circuit
            representation isotropically.
            The keyword argument `svg_code_only` (default `False`) can be used
            to specify that the SVG code itself be returned, rather than the
            IPython `SVG` object.
        &#34;&#34;&#34;
        if not isinstance(zcolor, str):
            raise TypeError(&#34;Keyword argument &#39;zcolor&#39; must be string.&#34;)
        if not isinstance(xcolor, str):
            raise TypeError(&#34;Keyword argument &#39;xcolor&#39; must be string.&#34;)
        if not isinstance(hscale, (int, float)) or hscale &lt;= 0.0:
            raise TypeError(&#34;Keyword argument &#39;hscale&#39; must be positive float.&#34;)
        if not isinstance(vscale, (int, float)) or vscale &lt;= 0.0:
            raise TypeError(&#34;Keyword argument &#39;vscale&#39; must be positive float.&#34;)
        if not isinstance(scale, (int, float)) or scale &lt;= 0.0:
            raise TypeError(&#34;Keyword argument &#39;scale&#39; must be positive float.&#34;)
        return self._to_svg(zcolor=zcolor, xcolor=xcolor,
                            hscale=hscale, vscale=vscale, scale=scale,
                            svg_code_only=svg_code_only)

    def __eq__(self, other) -&gt; bool:
        if self is other:
            return True
        if not isinstance(other, OptimizedPhaseCircuit):
            return NotImplemented
        if self.circuit_rep != other.circuit_rep:
            return False
        if self.phase_block != other.phase_block:
            return False
        if self.cx_block != other.cx_block:
            return False
        return True

    def _to_svg(self, *,
                zcolor: str = &#34;#CCFFCC&#34;,
                xcolor: str = &#34;#FF8888&#34;,
                hscale: float = 1.0, vscale: float = 1.0,
                scale: float = 1.0,
                svg_code_only: bool = False
                ):
        # pylint: disable = too-many-locals, too-many-statements
        # TODO: reuse from phase circuit once cleaned up and restructured
        num_qubits = self.num_qubits
        vscale *= scale
        hscale *= scale
        cx_block = self._cx_block
        phase_block = self._phase_block
        pre_cx_gates = [gate for layer in reversed(cx_block) for gate in layer.gates]
        gadgets = list(phase_block.gadgets)*self._circuit_rep
        post_cx_gates = list(reversed(pre_cx_gates))
        _layers: List[int] = [0 for _ in range(num_qubits)]
        pre_cx_gates_depths: List[int] = []
        max_cx_gates_depth: int = 0
        for gate in pre_cx_gates:
            m = min(gate)
            M = max(gate)
            d = max(_layers[q] for q in range(m, M+1))
            max_cx_gates_depth = max(max_cx_gates_depth, d+1)
            pre_cx_gates_depths.append(d)
            for q in range(m, M+1):
                _layers[q] = d+1
        post_cx_gates_depths: List[int] = [max_cx_gates_depth - d
                                           for d in reversed(pre_cx_gates_depths)]
        num_digits = int(ceil(log10(num_qubits)))
        line_height = int(ceil(30*vscale))
        row_width = int(ceil(100*hscale))
        cx_row_width = int(ceil(40*hscale))
        pad_x = int(ceil(10*hscale))
        margin_x = int(ceil(40*hscale))
        pad_y = int(ceil(20*vscale))
        r = pad_y//2-2
        font_size = 2*r
        pad_x += font_size*(num_digits+1)
        delta_fst = row_width//2
        delta_snd = 3*row_width//4
        width = (2*pad_x + 2*margin_x + row_width*len(gadgets)
                 + 2*max_cx_gates_depth * cx_row_width)
        height = pad_y + line_height*(num_qubits+1)
        builder = SVGBuilder(width, height)
        for q in range(num_qubits):
            y = pad_y + (q+1) * line_height
            builder.line((pad_x, y), (width-pad_x, y))
            builder.text((0, y), f&#34;{str(q):&gt;{num_digits}}&#34;, font_size=font_size)
            builder.text((width-pad_x+r, y), f&#34;{str(q):&gt;{num_digits}}&#34;, font_size=font_size)
        for i, (ctrl, trgt) in enumerate(pre_cx_gates):
            row = pre_cx_gates_depths[i]
            x = pad_x + margin_x + row * cx_row_width
            y_ctrl = pad_y + (ctrl+1)*line_height
            y_trgt = pad_y + (trgt+1)*line_height
            builder.line((x, y_ctrl), (x, y_trgt))
            builder.circle((x, y_ctrl), r, zcolor)
            builder.circle((x, y_trgt), r, xcolor)
        for _row, gadget in enumerate(gadgets):
            fill = zcolor if gadget.basis == &#34;Z&#34; else xcolor
            other_fill = xcolor if gadget.basis == &#34;Z&#34; else zcolor
            row = _row
            x = pad_x + margin_x + row * row_width + max_cx_gates_depth * cx_row_width
            for q in gadget.qubits:
                y = pad_y + (q+1)*line_height
                builder.line((x, y), (x+delta_fst, pad_y))
            for q in gadget.qubits:
                y = pad_y + (q+1)*line_height
                builder.circle((x, y), r, fill)
            builder.line((x+delta_fst, pad_y), (x+delta_snd, pad_y))
            builder.circle((x+delta_fst, pad_y), r, other_fill)
            builder.circle((x+delta_snd, pad_y), r, fill)
            builder.text((x+delta_snd+2*r, pad_y), str(gadget.angle), font_size=font_size)
        for i, (ctrl, trgt) in enumerate(post_cx_gates):
            row = post_cx_gates_depths[i]
            x = (pad_x + margin_x + len(gadgets) * row_width
                 + (row+max_cx_gates_depth) * cx_row_width)
            y_ctrl = pad_y + (ctrl+1)*line_height
            y_trgt = pad_y + (trgt+1)*line_height
            builder.line((x, y_ctrl), (x, y_trgt))
            builder.circle((x, y_ctrl), r, zcolor)
            builder.circle((x, y_trgt), r, xcolor)
        svg_code = repr(builder)
        if svg_code_only:
            return svg_code
        try:
            # pylint: disable = import-outside-toplevel
            from IPython.core.display import SVG # type: ignore
        except ModuleNotFoundError as _:
            raise ModuleNotFoundError(&#34;You must install the &#39;IPython&#39; library.&#34;)
        return SVG(svg_code)

    def _repr_svg_(self):
        &#34;&#34;&#34;
            Magic method for IPython/Jupyter pretty-printing.
            See https://ipython.readthedocs.io/en/stable/api/generated/IPython.display.html
        &#34;&#34;&#34;
        return self._to_svg(svg_code_only=True)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.circuit_rep"><code class="name">var <span class="ident">circuit_rep</span> : int</code></dt>
<dd>
<div class="desc"><p>Readonly property exposing the number of times that the original circuit is
to be repeated, for use when computing CX counts.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def circuit_rep(self) -&gt; int:
    &#34;&#34;&#34;
        Readonly property exposing the number of times that the original circuit is
        to be repeated, for use when computing CX counts.
    &#34;&#34;&#34;
    return self._circuit_rep</code></pre>
</details>
</dd>
<dt id="pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.cx_block"><code class="name">var <span class="ident">cx_block</span> : <a title="pauliopt.phase.cx_circuits.CXCircuitView" href="cx_circuits.html#pauliopt.phase.cx_circuits.CXCircuitView">CXCircuitView</a></code></dt>
<dd>
<div class="desc"><p>Readonly property exposing a readonly view on the CX block of the optimized circuit.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cx_block(self) -&gt; CXCircuitView:
    &#34;&#34;&#34;
        Readonly property exposing a readonly view on the CX block of the optimized circuit.
    &#34;&#34;&#34;
    return self._cx_block_view</code></pre>
</details>
</dd>
<dt id="pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.cx_blocks_count"><code class="name">var <span class="ident">cx_blocks_count</span> : int</code></dt>
<dd>
<div class="desc"><p>Readonly property exposing the overall CX count for the conjugating
CX blocks in the currently optimized circuit.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cx_blocks_count(self) -&gt; int:
    &#34;&#34;&#34;
        Readonly property exposing the overall CX count for the conjugating
        CX blocks in the currently optimized circuit.
    &#34;&#34;&#34;
    return self._cx_blocks_count</code></pre>
</details>
</dd>
<dt id="pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.cx_count"><code class="name">var <span class="ident">cx_count</span> : int</code></dt>
<dd>
<div class="desc"><p>Readonly property exposing the current CX count for the optimized circuit.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cx_count(self) -&gt; int:
    &#34;&#34;&#34;
        Readonly property exposing the current CX count for the optimized circuit.
    &#34;&#34;&#34;
    return self._cx_count</code></pre>
</details>
</dd>
<dt id="pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.init_cx_blocks_count"><code class="name">var <span class="ident">init_cx_blocks_count</span> : int</code></dt>
<dd>
<div class="desc"><p>Readonly property exposing the overall CX count for the two conjugating
CX blocks at the time the circuit was instantiated.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def init_cx_blocks_count(self) -&gt; int:
    &#34;&#34;&#34;
        Readonly property exposing the overall CX count for the two conjugating
        CX blocks at the time the circuit was instantiated.
    &#34;&#34;&#34;
    return self._init_cx_blocks_count</code></pre>
</details>
</dd>
<dt id="pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.init_cx_count"><code class="name">var <span class="ident">init_cx_count</span> : int</code></dt>
<dd>
<div class="desc"><p>Readonly property exposing the CX count for the original circuit.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def init_cx_count(self) -&gt; int:
    &#34;&#34;&#34;
        Readonly property exposing the CX count for the original circuit.
    &#34;&#34;&#34;
    return self._init_cx_count</code></pre>
</details>
</dd>
<dt id="pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.init_phase_block_cx_count"><code class="name">var <span class="ident">init_phase_block_cx_count</span> : int</code></dt>
<dd>
<div class="desc"><p>Readonly property exposing the overall CX count for a single
phase block at the time the circuit was instantiated.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def init_phase_block_cx_count(self) -&gt; int:
    &#34;&#34;&#34;
        Readonly property exposing the overall CX count for a single
        phase block at the time the circuit was instantiated.
    &#34;&#34;&#34;
    return (self.init_cx_count-self.init_cx_blocks_count)//self.circuit_rep</code></pre>
</details>
</dd>
<dt id="pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.num_qubits"><code class="name">var <span class="ident">num_qubits</span> : int</code></dt>
<dd>
<div class="desc"><p>Readonly property exposing the number of qubits spanned by the circuit to be optimized.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def num_qubits(self) -&gt; int:
    &#34;&#34;&#34;
        Readonly property exposing the number of qubits spanned by the circuit to be optimized.
    &#34;&#34;&#34;
    return self._phase_block.num_qubits</code></pre>
</details>
</dd>
<dt id="pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.phase_block"><code class="name">var <span class="ident">phase_block</span> : <a title="pauliopt.phase.phase_circuits.PhaseCircuitView" href="phase_circuits.html#pauliopt.phase.phase_circuits.PhaseCircuitView">PhaseCircuitView</a></code></dt>
<dd>
<div class="desc"><p>Readonly property exposing a readonly view on the phase block of the optimized circuit.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def phase_block(self) -&gt; PhaseCircuitView:
    &#34;&#34;&#34;
        Readonly property exposing a readonly view on the phase block of the optimized circuit.
    &#34;&#34;&#34;
    return self._phase_block_view</code></pre>
</details>
</dd>
<dt id="pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.phase_block_cx_count"><code class="name">var <span class="ident">phase_block_cx_count</span> : int</code></dt>
<dd>
<div class="desc"><p>Readonly property exposing the overall CX count for a single
phase block in the currently optimized circuit.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def phase_block_cx_count(self) -&gt; int:
    &#34;&#34;&#34;
        Readonly property exposing the overall CX count for a single
        phase block in the currently optimized circuit.
    &#34;&#34;&#34;
    return (self.cx_count-self.cx_blocks_count)//self.circuit_rep</code></pre>
</details>
</dd>
<dt id="pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.topology"><code class="name">var <span class="ident">topology</span> : <a title="pauliopt.topologies.Topology" href="../topologies.html#pauliopt.topologies.Topology">Topology</a></code></dt>
<dd>
<div class="desc"><p>Readonly property exposing the topology constraining the circuit optimization.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def topology(self) -&gt; Topology:
    &#34;&#34;&#34;
        Readonly property exposing the topology constraining the circuit optimization.
    &#34;&#34;&#34;
    return self._topology</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.anneal"><code class="name flex">
<span>def <span class="ident">anneal</span></span>(<span>self, num_iters: int, *, schedule: Union[Tuple[Literal['linear', 'geometric', 'reciprocal', 'log'], Union[int, float], Union[int, float]], <a title="pauliopt.utils.TempSchedule" href="../utils.html#pauliopt.utils.TempSchedule">TempSchedule</a>] = ('linear', 1.0, 0.1), loggers: <a title="pauliopt.phase.optimized_circuits.AnnealingLoggers" href="#pauliopt.phase.optimized_circuits.AnnealingLoggers">AnnealingLoggers</a> = {})</span>
</code></dt>
<dd>
<div class="desc"><p>Performs a cycle of simulated annealing optimization,
using the given number of iterations, temperature schedule,
initial/final temperatures.</p>
<p>The circuit is modified in-place and then returned, as per the
<a href="https://en.wikipedia.org/wiki/Fluent_interface">fluent API pattern</a>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def anneal(self,
           num_iters: int, *,
           schedule: Union[StandardTempSchedule, TempSchedule] = (&#34;linear&#34;, 1.0, 0.1),
           loggers: AnnealingLoggers = {}):
           # pylint: disable = dangerous-default-value
    # pylint: disable = too-many-locals
    &#34;&#34;&#34;
        Performs a cycle of simulated annealing optimization,
        using the given number of iterations, temperature schedule,
        initial/final temperatures.

        The circuit is modified in-place and then returned, as per the
        [fluent API pattern](https://en.wikipedia.org/wiki/Fluent_interface).
    &#34;&#34;&#34;
    # Validate arguments:
    if not isinstance(num_iters, int) or num_iters &lt;= 0:
        raise TypeError(f&#34;Expected a positive integer, found {num_iters}.&#34;)
    schedule = _validate_temp_schedule(schedule)
    log_start, log_iter, log_end = _validate_loggers(loggers)
    # Log start:
    if log_start is not None:
        log_start(self._cx_count, num_iters)
    # Pre-sample random numbers to use in iterations:
    rand = self._rng.uniform(size=num_iters)
    # Run iterations:
    for it in range(num_iters):
        t = schedule(it, num_iters=num_iters)
        layer_idx, (ctrl, trgt) = self.random_flip_cx()
        new_cx_count, new_cx_blocks_count = self._compute_cx_count()
        cx_count_diff = new_cx_count-self._cx_count
        accept_step = cx_count_diff &lt; 0 or rand[it] &lt; np.exp(-cx_count_diff/t)
        if log_iter is not None:
            log_iter(it, self._cx_count, new_cx_count, accept_step,
                     (layer_idx, (ctrl, trgt)), t, num_iters)
        if accept_step:
            # Accept changes:
            self._cx_count = new_cx_count
            self._cx_blocks_count = new_cx_blocks_count
        else:
            # Undo changes:
            self._flip_cx(layer_idx, ctrl, trgt)
    # Log end:
    if log_end is not None:
        log_end(self._cx_count, num_iters)</code></pre>
</details>
</dd>
<dt id="pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.clone"><code class="name flex">
<span>def <span class="ident">clone</span></span>(<span>self, rng_seed: Union[int, NoneType] = None) ‑> <a title="pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit" href="#pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit">OptimizedPhaseCircuit</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns a copy of this optimized phase circuit.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clone(self, rng_seed: Optional[int] = None) -&gt; &#34;OptimizedPhaseCircuit&#34;:
    &#34;&#34;&#34;
        Returns a copy of this optimized phase circuit.
    &#34;&#34;&#34;
    return OptimizedPhaseCircuit(self.phase_block, self.topology, self.cx_block,
                                 circuit_rep=self.circuit_rep, rng_seed=rng_seed)</code></pre>
</details>
</dd>
<dt id="pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.flip_cx"><code class="name flex">
<span>def <span class="ident">flip_cx</span></span>(<span>self, layer_idx: int, ctrl: int, trgt: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Performs the actions needed to flip the given CX gate in the given layer
of the CX circuit used for the optimization:</p>
<ul>
<li>undoes all gates in layers subsequent to the given layer which are
causally following the given gate, starting from the last layer and
working backwards towards the gate;</li>
<li>applies the desired gate;</li>
<li>redoes all gate undone, in reverse order (starting from the gate and
working forwards towards the last layer).</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flip_cx(self, layer_idx: int, ctrl: int, trgt: int):
    &#34;&#34;&#34;
        Performs the actions needed to flip the given CX gate in the given layer
        of the CX circuit used for the optimization:

        - undoes all gates in layers subsequent to the given layer which are
          causally following the given gate, starting from the last layer and
          working backwards towards the gate;
        - applies the desired gate;
        - redoes all gate undone, in reverse order (starting from the gate and
          working forwards towards the last layer).
    &#34;&#34;&#34;
    if not self.is_cx_flippable(layer_idx, ctrl, trgt):
        raise ValueError(f&#34;Gate {(ctrl, trgt)} cannot be flipped in layer number {layer_idx}.&#34;)
    self._flip_cx(layer_idx, ctrl, trgt)</code></pre>
</details>
</dd>
<dt id="pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.is_cx_flippable"><code class="name flex">
<span>def <span class="ident">is_cx_flippable</span></span>(<span>self, layer_idx: int, ctrl: int, trgt: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whether the given CX gate can be flipped in the given layer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_cx_flippable(self, layer_idx: int, ctrl: int, trgt: int) -&gt; bool:
    &#34;&#34;&#34;
        Checks whether the given CX gate can be flipped in the given layer.
    &#34;&#34;&#34;
    if not isinstance(layer_idx, int) or not 0 &lt;= layer_idx &lt; len(self._cx_block):
        raise TypeError(f&#34;Invalid layer index {layer_idx} for CX circuit.&#34;)
    layer = self._cx_block[layer_idx]
    return layer.is_cx_flippable(ctrl, trgt)</code></pre>
</details>
</dd>
<dt id="pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.random_flip_cx"><code class="name flex">
<span>def <span class="ident">random_flip_cx</span></span>(<span>self) ‑> Tuple[int, Tuple[int, int]]</span>
</code></dt>
<dd>
<div class="desc"><p>Randomly flips a CX gate in the CX circuit used for the optimization,
updating both the CX circuit and the circuit being optimized.</p>
<p>Returns the layer index and gate (pair of control and target) that were
flipped (e.g. in case the flip needs to be subsequently undone).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def random_flip_cx(self) -&gt; Tuple[int, Tuple[int, int]]:
    &#34;&#34;&#34;
        Randomly flips a CX gate in the CX circuit used for the optimization,
        updating both the CX circuit and the circuit being optimized.

        Returns the layer index and gate (pair of control and target) that were
        flipped (e.g. in case the flip needs to be subsequently undone).
    &#34;&#34;&#34;
    while True:
        layer_idx = int(self._rng.integers(len(self._cx_block)))
        ctrl, trgt = self._cx_block[layer_idx].random_flip_cx(self._rng)
        if layer_idx &lt; len(self._cx_block)-1 and self._cx_block[layer_idx+1].has_cx(ctrl, trgt):
            # Try again if CX gate already present in layer above (to avoid redundancy)
            continue
        if layer_idx &gt; 0 and self._cx_block[layer_idx-1].has_cx(ctrl, trgt):
            # Try again if CX gate already present in layer below (to avoid redundancy)
            continue
        self._flip_cx(layer_idx, ctrl, trgt)
        return layer_idx, (ctrl, trgt)</code></pre>
</details>
</dd>
<dt id="pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.to_qiskit"><code class="name flex">
<span>def <span class="ident">to_qiskit</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the optimized circuit as a Qiskit circuit.</p>
<p>This method relies on the <code>qiskit</code> library being available.
Specifically, the <code>circuit</code> argument must be of type
<code>qiskit.providers.BaseBackend</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_qiskit(self):
    &#34;&#34;&#34;
        Returns the optimized circuit as a Qiskit circuit.

        This method relies on the `qiskit` library being available.
        Specifically, the `circuit` argument must be of type
        `qiskit.providers.BaseBackend`.
    &#34;&#34;&#34;
    try:
        # pylint: disable = import-outside-toplevel
        from qiskit.circuit import QuantumCircuit # type: ignore
    except ModuleNotFoundError as _:
        raise ModuleNotFoundError(&#34;You must install the &#39;qiskit&#39; library.&#34;)
    circuit = QuantumCircuit(self.num_qubits)
    for layer in reversed(self._cx_block):
        for ctrl, trgt in layer.gates:
            circuit.cx(ctrl, trgt)
    for __ in range(self._circuit_rep):
        for gadget in self._phase_block.gadgets:
            gadget.on_qiskit_circuit(self._topology, circuit)
    for layer in self._cx_block:
        for ctrl, trgt in layer.gates:
            circuit.cx(ctrl, trgt)
    return circuit</code></pre>
</details>
</dd>
<dt id="pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.to_svg"><code class="name flex">
<span>def <span class="ident">to_svg</span></span>(<span>self, *, zcolor: str = '#CCFFCC', xcolor: str = '#FF8888', hscale: float = 1.0, vscale: float = 1.0, scale: float = 1.0, svg_code_only: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an SVG representation of this optimized circuit, using
the ZX calculus to express phase gadgets and CX gates.</p>
<p>The keyword arguments <code>zcolor</code> and <code>xcolor</code> can be used to
specify a colour for the Z and X basis spiders in the circuit.
The keyword arguments <code>hscale</code> and <code>vscale</code> can be used to
scale the circuit representation horizontally and vertically.
The keyword argument <code>scale</code> can be used to scale the circuit
representation isotropically.
The keyword argument <code>svg_code_only</code> (default <code>False</code>) can be used
to specify that the SVG code itself be returned, rather than the
IPython <code>SVG</code> object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_svg(self, *,
           zcolor: str = &#34;#CCFFCC&#34;,
           xcolor: str = &#34;#FF8888&#34;,
           hscale: float = 1.0, vscale: float = 1.0,
           scale: float = 1.0,
           svg_code_only: bool = False
           ):
    &#34;&#34;&#34;
        Returns an SVG representation of this optimized circuit, using
        the ZX calculus to express phase gadgets and CX gates.

        The keyword arguments `zcolor` and `xcolor` can be used to
        specify a colour for the Z and X basis spiders in the circuit.
        The keyword arguments `hscale` and `vscale` can be used to
        scale the circuit representation horizontally and vertically.
        The keyword argument `scale` can be used to scale the circuit
        representation isotropically.
        The keyword argument `svg_code_only` (default `False`) can be used
        to specify that the SVG code itself be returned, rather than the
        IPython `SVG` object.
    &#34;&#34;&#34;
    if not isinstance(zcolor, str):
        raise TypeError(&#34;Keyword argument &#39;zcolor&#39; must be string.&#34;)
    if not isinstance(xcolor, str):
        raise TypeError(&#34;Keyword argument &#39;xcolor&#39; must be string.&#34;)
    if not isinstance(hscale, (int, float)) or hscale &lt;= 0.0:
        raise TypeError(&#34;Keyword argument &#39;hscale&#39; must be positive float.&#34;)
    if not isinstance(vscale, (int, float)) or vscale &lt;= 0.0:
        raise TypeError(&#34;Keyword argument &#39;vscale&#39; must be positive float.&#34;)
    if not isinstance(scale, (int, float)) or scale &lt;= 0.0:
        raise TypeError(&#34;Keyword argument &#39;scale&#39; must be positive float.&#34;)
    return self._to_svg(zcolor=zcolor, xcolor=xcolor,
                        hscale=hscale, vscale=vscale, scale=scale,
                        svg_code_only=svg_code_only)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pauliopt.phase" href="index.html">pauliopt.phase</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pauliopt.phase.optimized_circuits.AnnealingCostLogger" href="#pauliopt.phase.optimized_circuits.AnnealingCostLogger">AnnealingCostLogger</a></code></h4>
</li>
<li>
<h4><code><a title="pauliopt.phase.optimized_circuits.AnnealingIterLogger" href="#pauliopt.phase.optimized_circuits.AnnealingIterLogger">AnnealingIterLogger</a></code></h4>
</li>
<li>
<h4><code><a title="pauliopt.phase.optimized_circuits.AnnealingLoggers" href="#pauliopt.phase.optimized_circuits.AnnealingLoggers">AnnealingLoggers</a></code></h4>
<ul class="">
<li><code><a title="pauliopt.phase.optimized_circuits.AnnealingLoggers.log_end" href="#pauliopt.phase.optimized_circuits.AnnealingLoggers.log_end">log_end</a></code></li>
<li><code><a title="pauliopt.phase.optimized_circuits.AnnealingLoggers.log_iter" href="#pauliopt.phase.optimized_circuits.AnnealingLoggers.log_iter">log_iter</a></code></li>
<li><code><a title="pauliopt.phase.optimized_circuits.AnnealingLoggers.log_start" href="#pauliopt.phase.optimized_circuits.AnnealingLoggers.log_start">log_start</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit" href="#pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit">OptimizedPhaseCircuit</a></code></h4>
<ul class="">
<li><code><a title="pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.anneal" href="#pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.anneal">anneal</a></code></li>
<li><code><a title="pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.circuit_rep" href="#pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.circuit_rep">circuit_rep</a></code></li>
<li><code><a title="pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.clone" href="#pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.clone">clone</a></code></li>
<li><code><a title="pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.cx_block" href="#pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.cx_block">cx_block</a></code></li>
<li><code><a title="pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.cx_blocks_count" href="#pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.cx_blocks_count">cx_blocks_count</a></code></li>
<li><code><a title="pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.cx_count" href="#pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.cx_count">cx_count</a></code></li>
<li><code><a title="pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.flip_cx" href="#pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.flip_cx">flip_cx</a></code></li>
<li><code><a title="pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.init_cx_blocks_count" href="#pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.init_cx_blocks_count">init_cx_blocks_count</a></code></li>
<li><code><a title="pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.init_cx_count" href="#pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.init_cx_count">init_cx_count</a></code></li>
<li><code><a title="pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.init_phase_block_cx_count" href="#pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.init_phase_block_cx_count">init_phase_block_cx_count</a></code></li>
<li><code><a title="pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.is_cx_flippable" href="#pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.is_cx_flippable">is_cx_flippable</a></code></li>
<li><code><a title="pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.num_qubits" href="#pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.num_qubits">num_qubits</a></code></li>
<li><code><a title="pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.phase_block" href="#pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.phase_block">phase_block</a></code></li>
<li><code><a title="pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.phase_block_cx_count" href="#pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.phase_block_cx_count">phase_block_cx_count</a></code></li>
<li><code><a title="pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.random_flip_cx" href="#pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.random_flip_cx">random_flip_cx</a></code></li>
<li><code><a title="pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.to_qiskit" href="#pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.to_qiskit">to_qiskit</a></code></li>
<li><code><a title="pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.to_svg" href="#pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.to_svg">to_svg</a></code></li>
<li><code><a title="pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.topology" href="#pauliopt.phase.optimized_circuits.OptimizedPhaseCircuit.topology">topology</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>