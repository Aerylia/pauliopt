<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>pauliopt.qasm API documentation</title>
<meta name="description" content="QASM file parsing" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pauliopt.qasm</code></h1>
</header>
<section id="section-intro">
<p>QASM file parsing</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
    QASM file parsing
&#34;&#34;&#34;

from fractions import Fraction
import re
from typing import cast, Dict, Iterator, List, Optional, overload, Sequence, Tuple, Union
from pauliopt.utils import Angle


def assert_same_size_targets(*trgts: &#34;QASM.RegTarget&#34;):
    &#34;&#34;&#34;
        Asserts that all register targets have the same size.
    &#34;&#34;&#34;
    size: Optional[int] = None
    for trgt in trgts:
        if not isinstance(trgt, QASM.RegTarget):
            raise TypeError(f&#34;Expected register target, found {trgt}&#34;)
        if size is None:
            size = trgt.size
        elif size != trgt.size:
            raise ValueError(f&#34;Expected all targets of size {size}, &#34;
                             f&#34;found a target of size {trgt.size} instead.&#34;)


class QASM(Sequence[&#34;QASM.Statement&#34;]):
    &#34;&#34;&#34;
        QASM program.
        Based on the QASM spec from [arXiv: 1707.03429](https://arxiv.org/abs/1707.03429)
    &#34;&#34;&#34;

    _statements: Tuple[&#34;QASM.Statement&#34;, ...]
    _registers: Dict[str, Union[&#34;QASM.QReg&#34;, &#34;QASM.CReg&#34;]]

    def __init__(self, *statements: &#34;QASM.Statement&#34;):
        for s in statements:
            if not isinstance(s, QASM.Statement):
                raise ValueError(f&#34;Invalid statement: {s}&#34;)
        self._statements = statements
        self._registers = {}
        version_declared = False
        for s in statements:
            if isinstance(s, QASM.Version):
                if version_declared:
                    raise ValueError(f&#34;Repeated OPENQASM version statements: {s}&#34;)
                version_declared = True
                continue
            if not version_declared and not isinstance(s, QASM.Comment):
                raise ValueError(f&#34;The first non-comment statement must be the OPENQASM version&#34;
                                 f&#34;declaration. Instead, found: &#39;{s}&#39;&#34;)
            if isinstance(s, (QASM.QReg, QASM.CReg)):
                if s.name in self._registers:
                    raise ValueError(f&#34;Repeated register declaration: {s.name}&#34;)
                self._registers[s.name] = s
                continue
            for r in s.registers:
                if r.name not in self._registers:
                    raise ValueError(f&#34;Unknown register {r.name} for statement: {s}&#34;)
                if r != self._registers[r.name]:
                    raise ValueError(f&#34;Register clash for name {r.name}: &#34;)

    @property
    def num_qubits(self) -&gt; int:
        &#34;&#34;&#34; Number of qubits in this circuit. &#34;&#34;&#34;
        return sum(reg.size for reg in self._registers.values() if isinstance(reg, QASM.QReg))

    @property
    def num_bits(self) -&gt; int:
        &#34;&#34;&#34; Number of bits in this circuit. &#34;&#34;&#34;
        return sum(reg.size for reg in self._registers.values() if isinstance(reg, QASM.CReg))

    @property
    def registers(self) -&gt; Iterator[Union[&#34;QASM.QReg&#34;, &#34;QASM.CReg&#34;]]:
        &#34;&#34;&#34; Iterator over the registers of this QASM program. &#34;&#34;&#34;
        return (reg for _, reg in self._registers.items())

    def __iter__(self) -&gt; Iterator[&#34;QASM.Statement&#34;]:
        return iter(self._statements)

    def __len__(self) -&gt; int:
        return len(self._statements)

    @overload
    def __getitem__(self, idx: int) -&gt; &#34;QASM.Statement&#34;:
        ...

    @overload
    def __getitem__(self, idx: slice) -&gt; Sequence[&#34;QASM.Statement&#34;]:
        ...

    def __getitem__(self, idx: Union[int, slice]):
        return self._statements[idx]

    def __str__(self) -&gt; str:
        return &#34;\n&#34;.join(str(statement) for statement in self)+&#34;\n&#34;

    class Statement:
        &#34;&#34;&#34; QASM statement. &#34;&#34;&#34;

        @property
        def registers(self) -&gt; Sequence[&#34;QASM.Reg&#34;]:
            &#34;&#34;&#34; List of registers involved in this statement. &#34;&#34;&#34;
            return []

        @staticmethod
        def parse(line: str) -&gt; &#34;QASM.Statement&#34;:
            &#34;&#34;&#34;
                Attempts to parse a QASM statement from a line of code.
            &#34;&#34;&#34;
            ...

    class Version(Statement):
        &#34;&#34;&#34; QASM version statement. &#34;&#34;&#34;

        _version: str

        def __init__(self, version: str):
            if version != &#34;2.0&#34;:
                raise TypeError(f&#34;Invalid version {version}&#34;)
            self._version = version

        @property
        def version(self) -&gt; str:
            &#34;&#34;&#34; QASM version. &#34;&#34;&#34;
            return self._version

        def __str__(self):
            return f&#34;OPENQASM {self.version};&#34;

    class Reg(Statement):
        &#34;&#34;&#34; Register. &#34;&#34;&#34;

        _name: str
        _size: int

        def __init__(self, name: str, size: int):
            if not isinstance(name, str) or not name:
                raise TypeError(f&#34;Invalid register name {name}&#34;)
            if not isinstance(size, int) or size &lt;= 0:
                raise TypeError(f&#34;Invalid register size {size}&#34;)
            self._name = name
            self._size = size

        @property
        def registers(self) -&gt; Sequence[&#34;QASM.Reg&#34;]:
            &#34;&#34;&#34; List of registers involved in this statement. &#34;&#34;&#34;
            return [self]

        @property
        def name(self):
            &#34;&#34;&#34; Register name. &#34;&#34;&#34;
            return self._name

        @property
        def size(self):
            &#34;&#34;&#34; Register size. &#34;&#34;&#34;
            return self._size

    class QReg(Reg):
        &#34;&#34;&#34; Quantum register. &#34;&#34;&#34;

        def __init__(self, name: str, size: int):
            super().__init__(name, size)

        def __str__(self):
            return f&#34;qreg {self.name}[{self.size}];&#34;

        def __eq__(self, other):
            if not isinstance(other, QASM.QReg):
                return NotImplemented
            return self.name == other.name and self.size == other.size

    class CReg(Reg):
        &#34;&#34;&#34; Classical register. &#34;&#34;&#34;

        def __init__(self, name: str, size: int):
            super().__init__(name, size)

        def __str__(self):
            return f&#34;creg {self.name}[{self.size}];&#34;

        def __eq__(self, other):
            if not isinstance(other, QASM.CReg):
                return NotImplemented
            return self.name == other.name and self.size == other.size

    class Include(Statement):
        &#34;&#34;&#34; QASM include statement. &#34;&#34;&#34;

        _filename: str

        def __init__(self, filename: str):
            if not isinstance(filename, str) or not filename:
                raise TypeError(f&#34;Invalid filename {filename}&#34;)
            self._filename = filename

        @property
        def filename(self) -&gt; str:
            &#34;&#34;&#34; Filename. &#34;&#34;&#34;
            return self._filename

        def __str__(self):
            return f&#34;include \&#34;{self.filename}\&#34;;&#34;

    class Comment(Statement):
        &#34;&#34;&#34; QASM comment statement. &#34;&#34;&#34;

        _text: str

        def __init__(self, text: str):
            if not isinstance(text, str):
                raise TypeError(f&#34;Invalid comment text {text}&#34;)
            self._text = text

        @property
        def text(self) -&gt; str:
            &#34;&#34;&#34; Comment text. &#34;&#34;&#34;
            return self._text

        def __str__(self):
            return f&#34;// {self.text}&#34;

    class RegTarget:
        &#34;&#34;&#34; A qreg or creg target. &#34;&#34;&#34;

        _register: Union[&#34;QASM.QReg&#34;, &#34;QASM.CReg&#34;]
        _pos: Optional[int]

        def __init__(self, register: Union[&#34;QASM.QReg&#34;, &#34;QASM.CReg&#34;], pos: Optional[int] = None):
            if not isinstance(register, (QASM.QReg, QASM.CReg)):
                raise TypeError(f&#34;Invalid register {register}&#34;)
            if pos is not None and (not isinstance(pos, int) or pos &lt; 0):
                raise TypeError(f&#34;Invalid register position {pos}&#34;)
            self._register = register
            self._pos = pos

        @property
        def registers(self) -&gt; Sequence[&#34;QASM.Reg&#34;]:
            &#34;&#34;&#34; List of registers involved in this statement. &#34;&#34;&#34;
            return [self.register]

        @property
        def register(self) -&gt; Union[&#34;QASM.QReg&#34;, &#34;QASM.CReg&#34;]:
            &#34;&#34;&#34; Register. &#34;&#34;&#34;
            return self._register

        @property
        def pos(self) -&gt; Optional[int]:
            &#34;&#34;&#34; Optional register position. &#34;&#34;&#34;
            return self._pos

        @property
        def size(self):
            &#34;&#34;&#34; Size of this target&#34;&#34;&#34;
            return 1 if self.pos is not None else self.register.size

        def __str__(self):
            if self.pos is not None:
                return f&#34;{self.register.name}[{self.pos}]&#34;
            return f&#34;{self.register.name}&#34;

    class QRegTarget(RegTarget):
        &#34;&#34;&#34; A qreg target. &#34;&#34;&#34;

        def __init__(self, register: &#34;QASM.QReg&#34;, pos: Optional[int] = None):
            if not isinstance(register, QASM.QReg):
                raise TypeError(f&#34;Invalid quantum register {register}&#34;)
            super().__init__(register, pos)

        @property
        def register(self) -&gt; &#34;QASM.QReg&#34;:
            &#34;&#34;&#34; Register. &#34;&#34;&#34;
            return cast(QASM.QReg, self._register)

    class CRegTarget(RegTarget):
        &#34;&#34;&#34; A creg target. &#34;&#34;&#34;

        def __init__(self, register: &#34;QASM.CReg&#34;, pos: Optional[int] = None):
            if not isinstance(register, QASM.CReg):
                raise TypeError(f&#34;Invalid classical register {register}&#34;)
            super().__init__(register, pos)

        @property
        def register(self) -&gt; &#34;QASM.CReg&#34;:
            &#34;&#34;&#34; Register. &#34;&#34;&#34;
            return cast(QASM.CReg, self._register)

    class UGate(Statement):
        &#34;&#34;&#34; Statement for a U3 gate. &#34;&#34;&#34;

        _theta: Angle
        _phi: Angle
        _lam: Angle
        _qubit: &#34;QASM.QRegTarget&#34;

        def __init__(self, theta: Angle, phi: Angle, lam: Angle,
                     qubit: &#34;QASM.QRegTarget&#34;):
            if not isinstance(theta, Angle):
                raise TypeError(f&#34;Invalid angle expression {theta}&#34;)
            if not isinstance(phi, Angle):
                raise TypeError(f&#34;Invalid angle expression {phi}&#34;)
            if not isinstance(lam, Angle):
                raise TypeError(f&#34;Invalid angle expression {lam}&#34;)
            if not isinstance(qubit, QASM.QRegTarget):
                raise TypeError(f&#34;Invalid qubit/qreg {qubit}&#34;)
            self._theta = theta
            self._phi = phi
            self._lam = lam
            self._qubit = qubit

        @property
        def registers(self) -&gt; Sequence[&#34;QASM.Reg&#34;]:
            &#34;&#34;&#34; List of registers involved in this statement. &#34;&#34;&#34;
            return [self.qubit.register]

        @property
        def theta(self) -&gt; Angle:
            &#34;&#34;&#34; Theta angle for the U3 gate. &#34;&#34;&#34;
            return self._theta

        @property
        def phi(self) -&gt; Angle:
            &#34;&#34;&#34; Phi angle for the U3 gate. &#34;&#34;&#34;
            return self._phi

        @property
        def lam(self) -&gt; Angle:
            &#34;&#34;&#34; Lambda angle for the U3 gate. &#34;&#34;&#34;
            return self._lam

        @property
        def qubit(self) -&gt; &#34;QASM.QRegTarget&#34;:
            &#34;&#34;&#34; Qubit/qreg for the U3 gate. &#34;&#34;&#34;
            return self._qubit

        def __str__(self):
            return (f&#34;U({QASM._angle_str(self.theta)}, &#34;
                    f&#34;{QASM._angle_str(self.phi)}, &#34;
                    f&#34;{QASM._angle_str(self.lam)})&#34;
                    f&#34; {self.qubit};&#34;)

    class CXGate(Statement):
        &#34;&#34;&#34; Statement for a CX gate. &#34;&#34;&#34;

        _control: &#34;QASM.QRegTarget&#34;
        _target: &#34;QASM.QRegTarget&#34;

        def __init__(self, control: &#34;QASM.QRegTarget&#34;, target: &#34;QASM.QRegTarget&#34;):
            if not isinstance(control, QASM.QRegTarget):
                raise TypeError(f&#34;Invalid qubit/qreg {control}&#34;)
            if not isinstance(target, QASM.QRegTarget):
                raise TypeError(f&#34;Invalid qubit/qreg {target}&#34;)
            self._control = control
            self._target = target
            if control.pos is None and target.pos is None and control.size != target.size:
                raise ValueError(f&#34;Mismatched register sizes: {control.size} vs {target.size}.&#34;)

        @property
        def registers(self) -&gt; Sequence[&#34;QASM.Reg&#34;]:
            &#34;&#34;&#34; List of registers involved in this statement. &#34;&#34;&#34;
            return [self.control.register, self.target.register]

        @property
        def control(self) -&gt; &#34;QASM.QRegTarget&#34;:
            &#34;&#34;&#34; Control qubit/qreg for the CX gate. &#34;&#34;&#34;
            return self._control

        @property
        def target(self) -&gt; &#34;QASM.QRegTarget&#34;:
            &#34;&#34;&#34; Target qubit/qreg for the CX gate. &#34;&#34;&#34;
            return self._target

        def __str__(self):
            return f&#34;CX {self.control} {self.target};&#34;

    class Measure(Statement):
        &#34;&#34;&#34; Statement for a measurement. &#34;&#34;&#34;

        _qubit: &#34;QASM.QRegTarget&#34;
        _bit: &#34;QASM.CRegTarget&#34;

        def __init__(self, qubit: &#34;QASM.QRegTarget&#34;, bit: &#34;QASM.CRegTarget&#34;):
            if not isinstance(qubit, QASM.QRegTarget):
                raise TypeError(f&#34;Invalid qubit/qreg {qubit}&#34;)
            if not isinstance(bit, QASM.CRegTarget):
                raise TypeError(f&#34;Invalid bit/creg {bit}&#34;)
            assert_same_size_targets(qubit, bit)
            self._qubit = qubit
            self._bit = bit

        @property
        def registers(self) -&gt; Sequence[&#34;QASM.Reg&#34;]:
            &#34;&#34;&#34; List of registers involved in this statement. &#34;&#34;&#34;
            return [self.qubit.register, self.bit.register]

        @property
        def qubit(self) -&gt; &#34;QASM.QRegTarget&#34;:
            &#34;&#34;&#34; Qubit/qreg to be measured. &#34;&#34;&#34;
            return self._qubit

        @property
        def bit(self) -&gt; &#34;QASM.CRegTarget&#34;:
            &#34;&#34;&#34; Bit/creg to store measurement outcome. &#34;&#34;&#34;
            return self._bit

        def __str__(self):
            return f&#34;measure {self.qubit} -&gt; {self.bit};&#34;

    class Reset(Statement):
        &#34;&#34;&#34; Statement for a reset. &#34;&#34;&#34;

        _qubit: &#34;QASM.QRegTarget&#34;

        def __init__(self, qubit: &#34;QASM.QRegTarget&#34;):
            if not isinstance(qubit, QASM.QRegTarget):
                raise TypeError(f&#34;Invalid qubit/qreg {qubit}&#34;)
            self._qubit = qubit

        @property
        def registers(self) -&gt; Sequence[&#34;QASM.Reg&#34;]:
            &#34;&#34;&#34; List of registers involved in this statement. &#34;&#34;&#34;
            return [self.qubit.register]

        @property
        def qubit(self) -&gt; &#34;QASM.QRegTarget&#34;:
            &#34;&#34;&#34; Qubit/qreg to be measured. &#34;&#34;&#34;
            return self._qubit

        def __str__(self):
            return f&#34;reset {self.qubit};&#34;

    class Gate(Statement):
        &#34;&#34;&#34; Statement for a named gate. &#34;&#34;&#34;

        _name: str
        _params: Tuple[Angle, ...]
        _targets: Tuple[&#34;QASM.RegTarget&#34;, ...]

        def __init__(self, name: str,
                     targets: Sequence[&#34;QASM.RegTarget&#34;],
                     params: Sequence[Angle] = tuple()):
            if not isinstance(name, str) or not name:
                raise TypeError(f&#34;Invalid gate name {name}&#34;)
            if (not isinstance(targets, Sequence)
                    or not all(isinstance(p, QASM.RegTarget) for p in targets)):
                raise TypeError(f&#34;Invalid sequence of register targets: {targets}&#34;)
            if not targets:
                raise TypeError(&#34;Empty sequence of register targets.&#34;)
            if (not isinstance(params, Sequence)
                    or not all(isinstance(p, Angle) for p in params)):
                raise TypeError(f&#34;Invalid sequence of angle parameters: {params}&#34;)
            self._name = name
            self._params = tuple(params)
            self._targets = tuple(targets)
            assert_same_size_targets(*self._targets)

        @property
        def registers(self) -&gt; Sequence[&#34;QASM.Reg&#34;]:
            &#34;&#34;&#34; List of registers involved in this statement. &#34;&#34;&#34;
            return [t.register for t in self.targets]

        @property
        def name(self) -&gt; str:
            &#34;&#34;&#34; Name for this gate. &#34;&#34;&#34;
            return self._name

        @property
        def params(self) -&gt; Tuple[Angle, ...]:
            &#34;&#34;&#34; Tuple of angle parameters for this gate. &#34;&#34;&#34;
            return self._params

        @property
        def targets(self) -&gt; Tuple[&#34;QASM.RegTarget&#34;, ...]:
            &#34;&#34;&#34; Tuple of register targets for this gate. &#34;&#34;&#34;
            return self._targets

        def __str__(self):
            if self.params:
                return (f&#34;{self.name}({&#39;, &#39;.join(QASM._angle_str(p) for p in self.params)}) &#34;
                        f&#34;{&#39;, &#39;.join(str(t) for t in self.targets)};&#34;)
            return (f&#34;{self.name} &#34;
                    f&#34;{&#39;, &#39;.join(str(t) for t in self.targets)};&#34;)

    class Barrier(Statement):
        &#34;&#34;&#34; Statement for a barrier. &#34;&#34;&#34;

        _targets: Tuple[&#34;QASM.QRegTarget&#34;, ...]

        def __init__(self, targets: Sequence[&#34;QASM.QRegTarget&#34;]):
            if (not isinstance(targets, Sequence)
                    or not all(isinstance(p, QASM.QRegTarget) for p in targets)):
                raise TypeError(f&#34;Invalid sequence of register targets: {targets}&#34;)
            self._targets = tuple(targets)

        @property
        def registers(self) -&gt; Sequence[&#34;QASM.Reg&#34;]:
            &#34;&#34;&#34; List of registers involved in this statement. &#34;&#34;&#34;
            return [t.register for t in self.targets]

        @property
        def targets(self) -&gt; Tuple[&#34;QASM.RegTarget&#34;, ...]:
            &#34;&#34;&#34; Tuple of register targets for this barrier. &#34;&#34;&#34;
            return self._targets

        def __str__(self):
            return f&#34;barrier {&#39;, &#39;.join(str(t) for t in self.targets)};&#34;

    class Conditional(Statement):
        &#34;&#34;&#34; Statement for a conditional statement. &#34;&#34;&#34;

        _register: &#34;QASM.CReg&#34;
        _value: int
        _statement: &#34;QASM.Statement&#34;

        def __init__(self, register: &#34;QASM.CReg&#34;, value: int,
                     statement: &#34;QASM.Statement&#34;):
            if not isinstance(register, QASM.CReg):
                raise TypeError(f&#34;Invalid classical register {register}&#34;)
            if not isinstance(value, int) or not 0 &lt;= value &lt; 2**register.size:
                raise TypeError(f&#34;Invalid value {value} for register {register}.&#34;)
            if not isinstance(statement, QASM.Statement):
                raise TypeError(f&#34;Invalid statement: {statement}&#34;)
            self._register = register
            self._value = value
            self._statement = statement

        @property
        def registers(self) -&gt; Sequence[&#34;QASM.Reg&#34;]:
            &#34;&#34;&#34; List of registers involved in this statement. &#34;&#34;&#34;
            return list(self.statement.registers)+[self.register]

        @property
        def register(self) -&gt; &#34;QASM.CReg&#34;:
            &#34;&#34;&#34; The register being tested in this conditional statement. &#34;&#34;&#34;
            return self._register

        @property
        def value(self) -&gt; int:
            &#34;&#34;&#34; The register value being tested in this conditional statement. &#34;&#34;&#34;
            return self._value

        @property
        def statement(self) -&gt; &#34;QASM.Statement&#34;:
            &#34;&#34;&#34; The statement to execute if the given creg has the given value. &#34;&#34;&#34;
            return self._statement

        def __str__(self):
            return f&#34;if({self.register.name}=={self.value}) {self.statement}&#34;

    @staticmethod
    def _angle_str(angle: Angle) -&gt; str:
        num = angle.value.numerator
        den = angle.value.denominator
        if num == 0:
            return &#34;0&#34;
        if num == 1:
            if den == 1:
                return &#34;pi&#34;
            return &#34;pi/%d&#34;%den
        return &#34;%d*pi/%d&#34;%(num, den)

    @staticmethod
    def _parse_angle(angle_str: str) -&gt; Angle:
        angle_str = angle_str.strip()
        angle_str = re.sub(r&#34; *\* *&#34;, &#34;*&#34;, angle_str)
        angle_str = re.sub(r&#34; */ *&#34;, &#34;/&#34;, angle_str)
        angle_str = re.sub(r&#34; *pi *&#34;, &#34;pi&#34;, angle_str)
        pattern = re.compile(r&#34;pi&#34;)
        match = pattern.fullmatch(angle_str)
        if match:
            return Angle(Fraction(1, 1))
        pattern = re.compile(r&#34;0&#34;)
        match = pattern.fullmatch(angle_str)
        if match:
            return Angle(Fraction(0, 1))
        pattern = re.compile(r&#34;pi/(.+)&#34;)
        match = pattern.fullmatch(angle_str)
        if match:
            return Angle(Fraction(1, int(match[1])))
        pattern = re.compile(r&#34;(.+)\*pi&#34;)
        match = pattern.fullmatch(angle_str)
        if match:
            return Angle(Fraction(int(match[1]), 1))
        pattern = re.compile(r&#34;(.+)\*pi/(.+)&#34;)
        match = pattern.fullmatch(angle_str)
        if match:
            return Angle(Fraction(int(match[1]), int(match[2])))
        # TODO: implement angle approximation
        raise ValueError(f&#34;Only fractional multiples of pi are accepted as angles.&#34;
                         f&#34;Instead, found &#39;{angle_str}&#39;&#34;)

    @staticmethod
    def _parse_comment(line: str) -&gt; &#34;QASM.Comment&#34;:
        return QASM.Comment(line[2:])

    @staticmethod
    def _parse_version(tokens: List[str]) -&gt; &#34;QASM.Version&#34;:
        return QASM.Version(tokens[1])

    @staticmethod
    def _parse_include(tokens: List[str]) -&gt; &#34;QASM.Include&#34;:
        if len(tokens) != 2:
            raise ValueError(f&#34;Expected exactly 2 statement tokens for include statement. &#34;
                             f&#34;Instead, found {tokens}&#34;)
        pattern = re.compile(r&#34;\&#34;(.+)\&#34;&#34;)
        match = pattern.fullmatch(tokens[1])
        if not match:
            raise ValueError(f&#34;Invalid include filename: &#39;{tokens[1]}&#39;&#34;)
        return QASM.Include(match[1])

    @staticmethod
    def _parse_qreg(tokens: List[str]) -&gt; &#34;QASM.QReg&#34;:
        if len(tokens) != 2:
            raise ValueError(f&#34;Expected exactly 2 statement tokens for qreg statement. &#34;
                             f&#34;Instead, found {tokens}&#34;)
        pattern = re.compile(r&#34;([a-zA-Z0-9]+)\[(.+)\]&#34;)
        match = pattern.fullmatch(tokens[1])
        if not match:
            raise ValueError(f&#34;Invalid register declaration: &#39;{tokens[1]}&#39;&#34;)
        return QASM.QReg(match[1], int(match[2]))

    @staticmethod
    def _parse_creg(tokens: List[str]) -&gt; &#34;QASM.CReg&#34;:
        if len(tokens) != 2:
            raise ValueError(f&#34;Expected exactly 2 statement tokens for creg statement. &#34;
                             f&#34;Instead, found {tokens}&#34;)
        pattern = re.compile(r&#34;([a-zA-Z0-9]+)\[(.+)\]&#34;)
        match = pattern.fullmatch(tokens[1])
        if not match:
            raise ValueError(f&#34;Invalid register declaration: &#39;{tokens[1]}&#39;&#34;)
        return QASM.CReg(match[1], int(match[2]))

    @staticmethod
    def _parse_qreg_target(token: str,
                           qregs: Dict[str, &#34;QASM.QReg&#34;]) -&gt; &#34;QASM.QRegTarget&#34;:
        if token in qregs:
            return QASM.QRegTarget(qregs[token])
        pattern = re.compile(r&#34;([a-zA-Z0-9]+)\[(.+)\]&#34;)
        match = pattern.fullmatch(token)
        if not match or match[1] not in qregs:
            raise ValueError(f&#34;Invalid register target or unknown register: &#39;{token}&#39;&#34;)
        return QASM.QRegTarget(qregs[match[1]], int(match[2]))

    @staticmethod
    def _parse_creg_target(token: str,
                           cregs: Dict[str, &#34;QASM.CReg&#34;]) -&gt; &#34;QASM.CRegTarget&#34;:
        if token in cregs:
            return QASM.CRegTarget(cregs[token])
        pattern = re.compile(r&#34;([a-zA-Z0-9]+)\[(.+)\]&#34;)
        match = pattern.fullmatch(token)
        if not match or match[1] not in cregs:
            raise ValueError(f&#34;Invalid register target or unknown register: &#39;{token}&#39;&#34;)
        return QASM.CRegTarget(cregs[match[1]], int(match[2]))

    @staticmethod
    def _parse_reg_target(token: str,
                          qregs: Dict[str, &#34;QASM.QReg&#34;],
                          cregs: Dict[str, &#34;QASM.CReg&#34;]) -&gt; &#34;QASM.RegTarget&#34;:
        if token in qregs:
            return QASM.QRegTarget(qregs[token])
        if token in cregs:
            return QASM.CRegTarget(cregs[token])
        pattern = re.compile(r&#34;([a-zA-Z0-9]+)\[(.+)\]&#34;)
        match = pattern.fullmatch(token)
        if not match or (match[1] not in qregs and match[1] not in cregs):
            raise ValueError(f&#34;Invalid register target or unknown register: &#39;{token}&#39;&#34;)
        if match[1] in qregs:
            return QASM.QRegTarget(qregs[match[1]], int(match[2]))
        return QASM.CRegTarget(cregs[match[1]], int(match[2]))

    @staticmethod
    def _parse_u(tokens: List[str], qregs: Dict[str, &#34;QASM.QReg&#34;]) -&gt; &#34;QASM.UGate&#34;:
        if len(tokens) != 2:
            raise ValueError(f&#34;Expected exactly 2 statement tokens for U gate statement. &#34;
                             f&#34;Instead, found {tokens}&#34;)
        pattern = re.compile(r&#34;U\((.+)\)&#34;)
        match = pattern.fullmatch(tokens[0])
        if not match:
            raise ValueError(f&#34;Invalid first token for U gate statement: &#39;{tokens[0]}&#39;&#34;)
        params = match[1].split(&#34;,&#34;)
        if len(params) != 3:
            raise ValueError(f&#34;Expected exactly 3 parameter tokens for U gate statement. &#34;
                             f&#34;Instead, found {params}&#34;)
        angles = [QASM._parse_angle(p) for p in params]
        qubit = QASM._parse_qreg_target(tokens[1], qregs)
        return QASM.UGate(angles[0], angles[1], angles[2], qubit)

    @staticmethod
    def _parse_cx(tokens: List[str], qregs: Dict[str, &#34;QASM.QReg&#34;]) -&gt; &#34;QASM.CXGate&#34;:
        if len(tokens) != 2:
            raise ValueError(f&#34;Expected exactly 2 statement tokens for CX gate statement. &#34;
                             f&#34;Instead, found {tokens}&#34;)
        qreg_targets = tokens[1].split(&#34;,&#34;)
        if len(qreg_targets) != 2:
            raise ValueError(f&#34;Expected exactly 2 qreg target tokens for CX gate statement. &#34;
                             f&#34;Instead, found {qreg_targets}&#34;)
        ctrl = QASM._parse_qreg_target(qreg_targets[0], qregs)
        trgt = QASM._parse_qreg_target(qreg_targets[1], qregs)
        return QASM.CXGate(ctrl, trgt)

    @staticmethod
    def _parse_measure(tokens: List[str],
                       qregs: Dict[str, &#34;QASM.QReg&#34;],
                       cregs: Dict[str, &#34;QASM.CReg&#34;]) -&gt; &#34;QASM.Measure&#34;:
        if len(tokens) != 2:
            raise ValueError(f&#34;Expected exactly 2 statement tokens for measure statement. &#34;
                             f&#34;Instead, found {tokens}&#34;)
        targets = tokens[1].split(&#34;-&gt;&#34;)
        if len(targets) != 2:
            raise ValueError(f&#34;Expected exactly 2 target tokens for measure statement. &#34;
                             f&#34;Instead, found {targets}&#34;)
        qubit = QASM._parse_qreg_target(targets[0], qregs)
        bit = QASM._parse_creg_target(targets[1], cregs)
        return QASM.Measure(qubit, bit)

    @staticmethod
    def _parse_reset(tokens: List[str], qregs: Dict[str, &#34;QASM.QReg&#34;]) -&gt; &#34;QASM.Reset&#34;:
        if len(tokens) != 2:
            raise ValueError(f&#34;Expected exactly 2 statement tokens for reset statement. &#34;
                             f&#34;Instead, found {tokens}&#34;)
        qubit = QASM._parse_qreg_target(tokens[1], qregs)
        return QASM.Reset(qubit)

    @staticmethod
    def _parse_barrier(tokens: List[str], qregs: Dict[str, &#34;QASM.QReg&#34;]) -&gt; &#34;QASM.Barrier&#34;:
        if len(tokens) != 2:
            raise ValueError(f&#34;Expected exactly 2 statement tokens for barrier statement. &#34;
                             f&#34;Instead, found {tokens}&#34;)
        qreg_targets = tokens[1].split(&#34;,&#34;)
        if not qreg_targets:
            raise ValueError(f&#34;Expected at least one qreg target token for barrier statement. &#34;
                             f&#34;Instead, found {qreg_targets}&#34;)
        qubits = [QASM._parse_qreg_target(t, qregs) for t in qreg_targets]
        return QASM.Barrier(qubits)

    @staticmethod
    def _parse_conditional(tokens: List[str],
                           qregs: Dict[str, &#34;QASM.QReg&#34;],
                           cregs: Dict[str, &#34;QASM.CReg&#34;]) -&gt; &#34;QASM.Conditional&#34;:
        if len(tokens) &lt; 2:
            raise ValueError(f&#34;Expected at least 2 statement tokens for conditional statement. &#34;
                             f&#34;Instead, found {tokens}&#34;)
        pattern = re.compile(r&#34;if\((.+)==(.+)\)&#34;)
        match = pattern.fullmatch(tokens[0])
        if not match:
            raise ValueError(f&#34;Invalid first token for conditional statement: &#39;{tokens[0]}&#39;&#34;)
        register = cregs[match[1]]
        value = int(match[2])
        return QASM.Conditional(register, value, QASM._parse_statement(tokens[1:], qregs, cregs))

    @staticmethod
    def _parse_gate(tokens: List[str],
                    qregs: Dict[str, &#34;QASM.QReg&#34;],
                    cregs: Dict[str, &#34;QASM.CReg&#34;]) -&gt; &#34;QASM.Gate&#34;:
        if len(tokens) != 2:
            raise ValueError(f&#34;Expected exactly 2 statement tokens for named gate statement. &#34;
                             f&#34;Instead, found {tokens}&#34;)
        pattern = re.compile(r&#34;([a-zA-Z0-9]+)\((.+)\)&#34;)
        match = pattern.fullmatch(tokens[0])
        if match:
            name = match[1]
            params = match[2].split(&#34;,&#34;)
        else:
            name = tokens[0]
            params = []
        angles = [QASM._parse_angle(p) for p in params]
        target_tokens = tokens[1].split(&#34;,&#34;)
        if len(target_tokens) == 0:
            raise ValueError(f&#34;Expected at least one target token for named gate statement. &#34;
                             f&#34;Instead, found {target_tokens}&#34;)
        targets = [QASM._parse_reg_target(t, qregs, cregs) for t in target_tokens]
        return QASM.Gate(name, targets, angles)

    @staticmethod
    def _parse_statement(tokens: List[str],
                         qregs: Dict[str, &#34;QASM.QReg&#34;],
                         cregs: Dict[str, &#34;QASM.CReg&#34;]) -&gt; &#34;QASM.Statement&#34;:
        # pylint: disable = too-many-return-statements
        if tokens[0] == &#34;OPENQASM&#34;:
            return QASM._parse_version(tokens)
        if tokens[0] == &#34;qreg&#34;:
            qreg: QASM.QReg = QASM._parse_qreg(tokens)
            if qreg.name in qregs or qreg.name in cregs:
                raise ValueError(f&#34;Repeated register declaration: {qreg.name}&#34;)
            qregs[qreg.name] = qreg
            return qreg
        if tokens[0] == &#34;creg&#34;:
            creg: QASM.CReg = QASM._parse_creg(tokens)
            if creg.name in qregs or creg.name in cregs:
                raise ValueError(f&#34;Repeated register declaration: {creg.name}&#34;)
            cregs[creg.name] = creg
            return creg
        if tokens[0] == &#34;include&#34;:
            return QASM._parse_include(tokens)
        if tokens[0].startswith(&#34;U&#34;):
            return QASM._parse_u(tokens, qregs)
        if tokens[0] == &#34;CX&#34;:
            return QASM._parse_cx(tokens, qregs)
        if tokens[0] == &#34;measure&#34;:
            return QASM._parse_measure(tokens, qregs, cregs)
        if tokens[0] == &#34;reset&#34;:
            return QASM._parse_reset(tokens, qregs)
        if tokens[0] == &#34;barrier&#34;:
            return QASM._parse_barrier(tokens, qregs)
        if tokens[0].startswith(&#34;if&#34;):
            return QASM._parse_conditional(tokens, qregs, cregs)
        return QASM._parse_gate(tokens, qregs, cregs)

    @staticmethod
    def parse(program: str):
        &#34;&#34;&#34; Parses a QASM program into a `QASM` object. &#34;&#34;&#34;
        # pylint: disable = too-many-branches, too-many-statements
        if not isinstance(program, str):
            raise TypeError(&#34;Expected a string.&#34;)
        lines = program.split(&#34;\n&#34;)
        statements: List[QASM.Statement] = []
        cregs: Dict[str, QASM.CReg] = {}
        qregs: Dict[str, QASM.QReg] = {}
        for line in lines:
            line = line.strip()
            line = re.sub(r&#34; *, *&#34;, &#34;,&#34;, line)
            line = re.sub(r&#34; *== *&#34;, &#34;==&#34;, line)
            line = re.sub(r&#34; *-&gt; *&#34;, &#34;-&gt;&#34;, line)
            line = re.sub(r&#34;\( *&#34;, &#34;(&#34;, line)
            line = re.sub(r&#34; *\)&#34;, &#34;)&#34;, line)
            line = re.sub(r&#34;\[ *&#34;, &#34;[&#34;, line)
            line = re.sub(r&#34; *\]&#34;, &#34;]&#34;, line)
            line = re.sub(r&#34;  *&#34;, &#34; &#34;, line)
            if line.startswith(&#34;//&#34;):
                statements.append(QASM._parse_comment(line))
                continue
            if not line:
                continue
            if line.startswith(&#34;gate&#34;):
                # TODO: implement gate definition statements
                continue
            if line.startswith(&#34;gate&#34;):
                # TODO: implement opaque gate definition statements
                continue
            if not line.endswith(&#34;;&#34;):
                raise ValueError(f&#34;Statements should be terminated by semicolon. &#34;
                                 f&#34;Instead, found: {line}&#34;)
            line = line[:-1] # remove final semicolon
            tokens: List[str] = line.split(&#34; &#34;)
            tokens = [t for t in tokens if len(t) != 0]
            try:
                statements.append(QASM._parse_statement(tokens, qregs, cregs))
            except ValueError as _:
                raise ValueError(f&#34;An error arose while parsing line: {line}&#34;)
        return QASM(*statements)

# # Some testing:
# code = &#34;&#34;&#34;
# // quantum teleportation example
# OPENQASM 2.0;
# include &#34;qelib1.inc&#34;;
# qreg q[3];
# creg c0[1];
# creg c1[1];
# creg c2[1];
# // optional post-rotation for state tomography
# gate post q { }
# u3(pi/2,pi/4,3*pi/4) q[0];
# h q[1];
# cx q[1],q[2];
# barrier q;
# cx q[0],q[1];
# h q[0];
# measure q[0] -&gt; c0[0];
# measure q[1] -&gt; c1[0];
# if(c0==1) z q[2];
# if(c1==1) x q[2];
# post q[2];
# measure q[2] -&gt; c2[0];
# &#34;&#34;&#34;
# print(QASM.parse(code))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pauliopt.qasm.assert_same_size_targets"><code class="name flex">
<span>def <span class="ident">assert_same_size_targets</span></span>(<span>*trgts: <a title="pauliopt.qasm.QASM.RegTarget" href="#pauliopt.qasm.QASM.RegTarget">QASM.RegTarget</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Asserts that all register targets have the same size.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assert_same_size_targets(*trgts: &#34;QASM.RegTarget&#34;):
    &#34;&#34;&#34;
        Asserts that all register targets have the same size.
    &#34;&#34;&#34;
    size: Optional[int] = None
    for trgt in trgts:
        if not isinstance(trgt, QASM.RegTarget):
            raise TypeError(f&#34;Expected register target, found {trgt}&#34;)
        if size is None:
            size = trgt.size
        elif size != trgt.size:
            raise ValueError(f&#34;Expected all targets of size {size}, &#34;
                             f&#34;found a target of size {trgt.size} instead.&#34;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pauliopt.qasm.QASM"><code class="flex name class">
<span>class <span class="ident">QASM</span></span>
<span>(</span><span>*statements: <a title="pauliopt.qasm.QASM.Statement" href="#pauliopt.qasm.QASM.Statement">QASM.Statement</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>QASM program.
Based on the QASM spec from <a href="https://arxiv.org/abs/1707.03429">arXiv: 1707.03429</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class QASM(Sequence[&#34;QASM.Statement&#34;]):
    &#34;&#34;&#34;
        QASM program.
        Based on the QASM spec from [arXiv: 1707.03429](https://arxiv.org/abs/1707.03429)
    &#34;&#34;&#34;

    _statements: Tuple[&#34;QASM.Statement&#34;, ...]
    _registers: Dict[str, Union[&#34;QASM.QReg&#34;, &#34;QASM.CReg&#34;]]

    def __init__(self, *statements: &#34;QASM.Statement&#34;):
        for s in statements:
            if not isinstance(s, QASM.Statement):
                raise ValueError(f&#34;Invalid statement: {s}&#34;)
        self._statements = statements
        self._registers = {}
        version_declared = False
        for s in statements:
            if isinstance(s, QASM.Version):
                if version_declared:
                    raise ValueError(f&#34;Repeated OPENQASM version statements: {s}&#34;)
                version_declared = True
                continue
            if not version_declared and not isinstance(s, QASM.Comment):
                raise ValueError(f&#34;The first non-comment statement must be the OPENQASM version&#34;
                                 f&#34;declaration. Instead, found: &#39;{s}&#39;&#34;)
            if isinstance(s, (QASM.QReg, QASM.CReg)):
                if s.name in self._registers:
                    raise ValueError(f&#34;Repeated register declaration: {s.name}&#34;)
                self._registers[s.name] = s
                continue
            for r in s.registers:
                if r.name not in self._registers:
                    raise ValueError(f&#34;Unknown register {r.name} for statement: {s}&#34;)
                if r != self._registers[r.name]:
                    raise ValueError(f&#34;Register clash for name {r.name}: &#34;)

    @property
    def num_qubits(self) -&gt; int:
        &#34;&#34;&#34; Number of qubits in this circuit. &#34;&#34;&#34;
        return sum(reg.size for reg in self._registers.values() if isinstance(reg, QASM.QReg))

    @property
    def num_bits(self) -&gt; int:
        &#34;&#34;&#34; Number of bits in this circuit. &#34;&#34;&#34;
        return sum(reg.size for reg in self._registers.values() if isinstance(reg, QASM.CReg))

    @property
    def registers(self) -&gt; Iterator[Union[&#34;QASM.QReg&#34;, &#34;QASM.CReg&#34;]]:
        &#34;&#34;&#34; Iterator over the registers of this QASM program. &#34;&#34;&#34;
        return (reg for _, reg in self._registers.items())

    def __iter__(self) -&gt; Iterator[&#34;QASM.Statement&#34;]:
        return iter(self._statements)

    def __len__(self) -&gt; int:
        return len(self._statements)

    @overload
    def __getitem__(self, idx: int) -&gt; &#34;QASM.Statement&#34;:
        ...

    @overload
    def __getitem__(self, idx: slice) -&gt; Sequence[&#34;QASM.Statement&#34;]:
        ...

    def __getitem__(self, idx: Union[int, slice]):
        return self._statements[idx]

    def __str__(self) -&gt; str:
        return &#34;\n&#34;.join(str(statement) for statement in self)+&#34;\n&#34;

    class Statement:
        &#34;&#34;&#34; QASM statement. &#34;&#34;&#34;

        @property
        def registers(self) -&gt; Sequence[&#34;QASM.Reg&#34;]:
            &#34;&#34;&#34; List of registers involved in this statement. &#34;&#34;&#34;
            return []

        @staticmethod
        def parse(line: str) -&gt; &#34;QASM.Statement&#34;:
            &#34;&#34;&#34;
                Attempts to parse a QASM statement from a line of code.
            &#34;&#34;&#34;
            ...

    class Version(Statement):
        &#34;&#34;&#34; QASM version statement. &#34;&#34;&#34;

        _version: str

        def __init__(self, version: str):
            if version != &#34;2.0&#34;:
                raise TypeError(f&#34;Invalid version {version}&#34;)
            self._version = version

        @property
        def version(self) -&gt; str:
            &#34;&#34;&#34; QASM version. &#34;&#34;&#34;
            return self._version

        def __str__(self):
            return f&#34;OPENQASM {self.version};&#34;

    class Reg(Statement):
        &#34;&#34;&#34; Register. &#34;&#34;&#34;

        _name: str
        _size: int

        def __init__(self, name: str, size: int):
            if not isinstance(name, str) or not name:
                raise TypeError(f&#34;Invalid register name {name}&#34;)
            if not isinstance(size, int) or size &lt;= 0:
                raise TypeError(f&#34;Invalid register size {size}&#34;)
            self._name = name
            self._size = size

        @property
        def registers(self) -&gt; Sequence[&#34;QASM.Reg&#34;]:
            &#34;&#34;&#34; List of registers involved in this statement. &#34;&#34;&#34;
            return [self]

        @property
        def name(self):
            &#34;&#34;&#34; Register name. &#34;&#34;&#34;
            return self._name

        @property
        def size(self):
            &#34;&#34;&#34; Register size. &#34;&#34;&#34;
            return self._size

    class QReg(Reg):
        &#34;&#34;&#34; Quantum register. &#34;&#34;&#34;

        def __init__(self, name: str, size: int):
            super().__init__(name, size)

        def __str__(self):
            return f&#34;qreg {self.name}[{self.size}];&#34;

        def __eq__(self, other):
            if not isinstance(other, QASM.QReg):
                return NotImplemented
            return self.name == other.name and self.size == other.size

    class CReg(Reg):
        &#34;&#34;&#34; Classical register. &#34;&#34;&#34;

        def __init__(self, name: str, size: int):
            super().__init__(name, size)

        def __str__(self):
            return f&#34;creg {self.name}[{self.size}];&#34;

        def __eq__(self, other):
            if not isinstance(other, QASM.CReg):
                return NotImplemented
            return self.name == other.name and self.size == other.size

    class Include(Statement):
        &#34;&#34;&#34; QASM include statement. &#34;&#34;&#34;

        _filename: str

        def __init__(self, filename: str):
            if not isinstance(filename, str) or not filename:
                raise TypeError(f&#34;Invalid filename {filename}&#34;)
            self._filename = filename

        @property
        def filename(self) -&gt; str:
            &#34;&#34;&#34; Filename. &#34;&#34;&#34;
            return self._filename

        def __str__(self):
            return f&#34;include \&#34;{self.filename}\&#34;;&#34;

    class Comment(Statement):
        &#34;&#34;&#34; QASM comment statement. &#34;&#34;&#34;

        _text: str

        def __init__(self, text: str):
            if not isinstance(text, str):
                raise TypeError(f&#34;Invalid comment text {text}&#34;)
            self._text = text

        @property
        def text(self) -&gt; str:
            &#34;&#34;&#34; Comment text. &#34;&#34;&#34;
            return self._text

        def __str__(self):
            return f&#34;// {self.text}&#34;

    class RegTarget:
        &#34;&#34;&#34; A qreg or creg target. &#34;&#34;&#34;

        _register: Union[&#34;QASM.QReg&#34;, &#34;QASM.CReg&#34;]
        _pos: Optional[int]

        def __init__(self, register: Union[&#34;QASM.QReg&#34;, &#34;QASM.CReg&#34;], pos: Optional[int] = None):
            if not isinstance(register, (QASM.QReg, QASM.CReg)):
                raise TypeError(f&#34;Invalid register {register}&#34;)
            if pos is not None and (not isinstance(pos, int) or pos &lt; 0):
                raise TypeError(f&#34;Invalid register position {pos}&#34;)
            self._register = register
            self._pos = pos

        @property
        def registers(self) -&gt; Sequence[&#34;QASM.Reg&#34;]:
            &#34;&#34;&#34; List of registers involved in this statement. &#34;&#34;&#34;
            return [self.register]

        @property
        def register(self) -&gt; Union[&#34;QASM.QReg&#34;, &#34;QASM.CReg&#34;]:
            &#34;&#34;&#34; Register. &#34;&#34;&#34;
            return self._register

        @property
        def pos(self) -&gt; Optional[int]:
            &#34;&#34;&#34; Optional register position. &#34;&#34;&#34;
            return self._pos

        @property
        def size(self):
            &#34;&#34;&#34; Size of this target&#34;&#34;&#34;
            return 1 if self.pos is not None else self.register.size

        def __str__(self):
            if self.pos is not None:
                return f&#34;{self.register.name}[{self.pos}]&#34;
            return f&#34;{self.register.name}&#34;

    class QRegTarget(RegTarget):
        &#34;&#34;&#34; A qreg target. &#34;&#34;&#34;

        def __init__(self, register: &#34;QASM.QReg&#34;, pos: Optional[int] = None):
            if not isinstance(register, QASM.QReg):
                raise TypeError(f&#34;Invalid quantum register {register}&#34;)
            super().__init__(register, pos)

        @property
        def register(self) -&gt; &#34;QASM.QReg&#34;:
            &#34;&#34;&#34; Register. &#34;&#34;&#34;
            return cast(QASM.QReg, self._register)

    class CRegTarget(RegTarget):
        &#34;&#34;&#34; A creg target. &#34;&#34;&#34;

        def __init__(self, register: &#34;QASM.CReg&#34;, pos: Optional[int] = None):
            if not isinstance(register, QASM.CReg):
                raise TypeError(f&#34;Invalid classical register {register}&#34;)
            super().__init__(register, pos)

        @property
        def register(self) -&gt; &#34;QASM.CReg&#34;:
            &#34;&#34;&#34; Register. &#34;&#34;&#34;
            return cast(QASM.CReg, self._register)

    class UGate(Statement):
        &#34;&#34;&#34; Statement for a U3 gate. &#34;&#34;&#34;

        _theta: Angle
        _phi: Angle
        _lam: Angle
        _qubit: &#34;QASM.QRegTarget&#34;

        def __init__(self, theta: Angle, phi: Angle, lam: Angle,
                     qubit: &#34;QASM.QRegTarget&#34;):
            if not isinstance(theta, Angle):
                raise TypeError(f&#34;Invalid angle expression {theta}&#34;)
            if not isinstance(phi, Angle):
                raise TypeError(f&#34;Invalid angle expression {phi}&#34;)
            if not isinstance(lam, Angle):
                raise TypeError(f&#34;Invalid angle expression {lam}&#34;)
            if not isinstance(qubit, QASM.QRegTarget):
                raise TypeError(f&#34;Invalid qubit/qreg {qubit}&#34;)
            self._theta = theta
            self._phi = phi
            self._lam = lam
            self._qubit = qubit

        @property
        def registers(self) -&gt; Sequence[&#34;QASM.Reg&#34;]:
            &#34;&#34;&#34; List of registers involved in this statement. &#34;&#34;&#34;
            return [self.qubit.register]

        @property
        def theta(self) -&gt; Angle:
            &#34;&#34;&#34; Theta angle for the U3 gate. &#34;&#34;&#34;
            return self._theta

        @property
        def phi(self) -&gt; Angle:
            &#34;&#34;&#34; Phi angle for the U3 gate. &#34;&#34;&#34;
            return self._phi

        @property
        def lam(self) -&gt; Angle:
            &#34;&#34;&#34; Lambda angle for the U3 gate. &#34;&#34;&#34;
            return self._lam

        @property
        def qubit(self) -&gt; &#34;QASM.QRegTarget&#34;:
            &#34;&#34;&#34; Qubit/qreg for the U3 gate. &#34;&#34;&#34;
            return self._qubit

        def __str__(self):
            return (f&#34;U({QASM._angle_str(self.theta)}, &#34;
                    f&#34;{QASM._angle_str(self.phi)}, &#34;
                    f&#34;{QASM._angle_str(self.lam)})&#34;
                    f&#34; {self.qubit};&#34;)

    class CXGate(Statement):
        &#34;&#34;&#34; Statement for a CX gate. &#34;&#34;&#34;

        _control: &#34;QASM.QRegTarget&#34;
        _target: &#34;QASM.QRegTarget&#34;

        def __init__(self, control: &#34;QASM.QRegTarget&#34;, target: &#34;QASM.QRegTarget&#34;):
            if not isinstance(control, QASM.QRegTarget):
                raise TypeError(f&#34;Invalid qubit/qreg {control}&#34;)
            if not isinstance(target, QASM.QRegTarget):
                raise TypeError(f&#34;Invalid qubit/qreg {target}&#34;)
            self._control = control
            self._target = target
            if control.pos is None and target.pos is None and control.size != target.size:
                raise ValueError(f&#34;Mismatched register sizes: {control.size} vs {target.size}.&#34;)

        @property
        def registers(self) -&gt; Sequence[&#34;QASM.Reg&#34;]:
            &#34;&#34;&#34; List of registers involved in this statement. &#34;&#34;&#34;
            return [self.control.register, self.target.register]

        @property
        def control(self) -&gt; &#34;QASM.QRegTarget&#34;:
            &#34;&#34;&#34; Control qubit/qreg for the CX gate. &#34;&#34;&#34;
            return self._control

        @property
        def target(self) -&gt; &#34;QASM.QRegTarget&#34;:
            &#34;&#34;&#34; Target qubit/qreg for the CX gate. &#34;&#34;&#34;
            return self._target

        def __str__(self):
            return f&#34;CX {self.control} {self.target};&#34;

    class Measure(Statement):
        &#34;&#34;&#34; Statement for a measurement. &#34;&#34;&#34;

        _qubit: &#34;QASM.QRegTarget&#34;
        _bit: &#34;QASM.CRegTarget&#34;

        def __init__(self, qubit: &#34;QASM.QRegTarget&#34;, bit: &#34;QASM.CRegTarget&#34;):
            if not isinstance(qubit, QASM.QRegTarget):
                raise TypeError(f&#34;Invalid qubit/qreg {qubit}&#34;)
            if not isinstance(bit, QASM.CRegTarget):
                raise TypeError(f&#34;Invalid bit/creg {bit}&#34;)
            assert_same_size_targets(qubit, bit)
            self._qubit = qubit
            self._bit = bit

        @property
        def registers(self) -&gt; Sequence[&#34;QASM.Reg&#34;]:
            &#34;&#34;&#34; List of registers involved in this statement. &#34;&#34;&#34;
            return [self.qubit.register, self.bit.register]

        @property
        def qubit(self) -&gt; &#34;QASM.QRegTarget&#34;:
            &#34;&#34;&#34; Qubit/qreg to be measured. &#34;&#34;&#34;
            return self._qubit

        @property
        def bit(self) -&gt; &#34;QASM.CRegTarget&#34;:
            &#34;&#34;&#34; Bit/creg to store measurement outcome. &#34;&#34;&#34;
            return self._bit

        def __str__(self):
            return f&#34;measure {self.qubit} -&gt; {self.bit};&#34;

    class Reset(Statement):
        &#34;&#34;&#34; Statement for a reset. &#34;&#34;&#34;

        _qubit: &#34;QASM.QRegTarget&#34;

        def __init__(self, qubit: &#34;QASM.QRegTarget&#34;):
            if not isinstance(qubit, QASM.QRegTarget):
                raise TypeError(f&#34;Invalid qubit/qreg {qubit}&#34;)
            self._qubit = qubit

        @property
        def registers(self) -&gt; Sequence[&#34;QASM.Reg&#34;]:
            &#34;&#34;&#34; List of registers involved in this statement. &#34;&#34;&#34;
            return [self.qubit.register]

        @property
        def qubit(self) -&gt; &#34;QASM.QRegTarget&#34;:
            &#34;&#34;&#34; Qubit/qreg to be measured. &#34;&#34;&#34;
            return self._qubit

        def __str__(self):
            return f&#34;reset {self.qubit};&#34;

    class Gate(Statement):
        &#34;&#34;&#34; Statement for a named gate. &#34;&#34;&#34;

        _name: str
        _params: Tuple[Angle, ...]
        _targets: Tuple[&#34;QASM.RegTarget&#34;, ...]

        def __init__(self, name: str,
                     targets: Sequence[&#34;QASM.RegTarget&#34;],
                     params: Sequence[Angle] = tuple()):
            if not isinstance(name, str) or not name:
                raise TypeError(f&#34;Invalid gate name {name}&#34;)
            if (not isinstance(targets, Sequence)
                    or not all(isinstance(p, QASM.RegTarget) for p in targets)):
                raise TypeError(f&#34;Invalid sequence of register targets: {targets}&#34;)
            if not targets:
                raise TypeError(&#34;Empty sequence of register targets.&#34;)
            if (not isinstance(params, Sequence)
                    or not all(isinstance(p, Angle) for p in params)):
                raise TypeError(f&#34;Invalid sequence of angle parameters: {params}&#34;)
            self._name = name
            self._params = tuple(params)
            self._targets = tuple(targets)
            assert_same_size_targets(*self._targets)

        @property
        def registers(self) -&gt; Sequence[&#34;QASM.Reg&#34;]:
            &#34;&#34;&#34; List of registers involved in this statement. &#34;&#34;&#34;
            return [t.register for t in self.targets]

        @property
        def name(self) -&gt; str:
            &#34;&#34;&#34; Name for this gate. &#34;&#34;&#34;
            return self._name

        @property
        def params(self) -&gt; Tuple[Angle, ...]:
            &#34;&#34;&#34; Tuple of angle parameters for this gate. &#34;&#34;&#34;
            return self._params

        @property
        def targets(self) -&gt; Tuple[&#34;QASM.RegTarget&#34;, ...]:
            &#34;&#34;&#34; Tuple of register targets for this gate. &#34;&#34;&#34;
            return self._targets

        def __str__(self):
            if self.params:
                return (f&#34;{self.name}({&#39;, &#39;.join(QASM._angle_str(p) for p in self.params)}) &#34;
                        f&#34;{&#39;, &#39;.join(str(t) for t in self.targets)};&#34;)
            return (f&#34;{self.name} &#34;
                    f&#34;{&#39;, &#39;.join(str(t) for t in self.targets)};&#34;)

    class Barrier(Statement):
        &#34;&#34;&#34; Statement for a barrier. &#34;&#34;&#34;

        _targets: Tuple[&#34;QASM.QRegTarget&#34;, ...]

        def __init__(self, targets: Sequence[&#34;QASM.QRegTarget&#34;]):
            if (not isinstance(targets, Sequence)
                    or not all(isinstance(p, QASM.QRegTarget) for p in targets)):
                raise TypeError(f&#34;Invalid sequence of register targets: {targets}&#34;)
            self._targets = tuple(targets)

        @property
        def registers(self) -&gt; Sequence[&#34;QASM.Reg&#34;]:
            &#34;&#34;&#34; List of registers involved in this statement. &#34;&#34;&#34;
            return [t.register for t in self.targets]

        @property
        def targets(self) -&gt; Tuple[&#34;QASM.RegTarget&#34;, ...]:
            &#34;&#34;&#34; Tuple of register targets for this barrier. &#34;&#34;&#34;
            return self._targets

        def __str__(self):
            return f&#34;barrier {&#39;, &#39;.join(str(t) for t in self.targets)};&#34;

    class Conditional(Statement):
        &#34;&#34;&#34; Statement for a conditional statement. &#34;&#34;&#34;

        _register: &#34;QASM.CReg&#34;
        _value: int
        _statement: &#34;QASM.Statement&#34;

        def __init__(self, register: &#34;QASM.CReg&#34;, value: int,
                     statement: &#34;QASM.Statement&#34;):
            if not isinstance(register, QASM.CReg):
                raise TypeError(f&#34;Invalid classical register {register}&#34;)
            if not isinstance(value, int) or not 0 &lt;= value &lt; 2**register.size:
                raise TypeError(f&#34;Invalid value {value} for register {register}.&#34;)
            if not isinstance(statement, QASM.Statement):
                raise TypeError(f&#34;Invalid statement: {statement}&#34;)
            self._register = register
            self._value = value
            self._statement = statement

        @property
        def registers(self) -&gt; Sequence[&#34;QASM.Reg&#34;]:
            &#34;&#34;&#34; List of registers involved in this statement. &#34;&#34;&#34;
            return list(self.statement.registers)+[self.register]

        @property
        def register(self) -&gt; &#34;QASM.CReg&#34;:
            &#34;&#34;&#34; The register being tested in this conditional statement. &#34;&#34;&#34;
            return self._register

        @property
        def value(self) -&gt; int:
            &#34;&#34;&#34; The register value being tested in this conditional statement. &#34;&#34;&#34;
            return self._value

        @property
        def statement(self) -&gt; &#34;QASM.Statement&#34;:
            &#34;&#34;&#34; The statement to execute if the given creg has the given value. &#34;&#34;&#34;
            return self._statement

        def __str__(self):
            return f&#34;if({self.register.name}=={self.value}) {self.statement}&#34;

    @staticmethod
    def _angle_str(angle: Angle) -&gt; str:
        num = angle.value.numerator
        den = angle.value.denominator
        if num == 0:
            return &#34;0&#34;
        if num == 1:
            if den == 1:
                return &#34;pi&#34;
            return &#34;pi/%d&#34;%den
        return &#34;%d*pi/%d&#34;%(num, den)

    @staticmethod
    def _parse_angle(angle_str: str) -&gt; Angle:
        angle_str = angle_str.strip()
        angle_str = re.sub(r&#34; *\* *&#34;, &#34;*&#34;, angle_str)
        angle_str = re.sub(r&#34; */ *&#34;, &#34;/&#34;, angle_str)
        angle_str = re.sub(r&#34; *pi *&#34;, &#34;pi&#34;, angle_str)
        pattern = re.compile(r&#34;pi&#34;)
        match = pattern.fullmatch(angle_str)
        if match:
            return Angle(Fraction(1, 1))
        pattern = re.compile(r&#34;0&#34;)
        match = pattern.fullmatch(angle_str)
        if match:
            return Angle(Fraction(0, 1))
        pattern = re.compile(r&#34;pi/(.+)&#34;)
        match = pattern.fullmatch(angle_str)
        if match:
            return Angle(Fraction(1, int(match[1])))
        pattern = re.compile(r&#34;(.+)\*pi&#34;)
        match = pattern.fullmatch(angle_str)
        if match:
            return Angle(Fraction(int(match[1]), 1))
        pattern = re.compile(r&#34;(.+)\*pi/(.+)&#34;)
        match = pattern.fullmatch(angle_str)
        if match:
            return Angle(Fraction(int(match[1]), int(match[2])))
        # TODO: implement angle approximation
        raise ValueError(f&#34;Only fractional multiples of pi are accepted as angles.&#34;
                         f&#34;Instead, found &#39;{angle_str}&#39;&#34;)

    @staticmethod
    def _parse_comment(line: str) -&gt; &#34;QASM.Comment&#34;:
        return QASM.Comment(line[2:])

    @staticmethod
    def _parse_version(tokens: List[str]) -&gt; &#34;QASM.Version&#34;:
        return QASM.Version(tokens[1])

    @staticmethod
    def _parse_include(tokens: List[str]) -&gt; &#34;QASM.Include&#34;:
        if len(tokens) != 2:
            raise ValueError(f&#34;Expected exactly 2 statement tokens for include statement. &#34;
                             f&#34;Instead, found {tokens}&#34;)
        pattern = re.compile(r&#34;\&#34;(.+)\&#34;&#34;)
        match = pattern.fullmatch(tokens[1])
        if not match:
            raise ValueError(f&#34;Invalid include filename: &#39;{tokens[1]}&#39;&#34;)
        return QASM.Include(match[1])

    @staticmethod
    def _parse_qreg(tokens: List[str]) -&gt; &#34;QASM.QReg&#34;:
        if len(tokens) != 2:
            raise ValueError(f&#34;Expected exactly 2 statement tokens for qreg statement. &#34;
                             f&#34;Instead, found {tokens}&#34;)
        pattern = re.compile(r&#34;([a-zA-Z0-9]+)\[(.+)\]&#34;)
        match = pattern.fullmatch(tokens[1])
        if not match:
            raise ValueError(f&#34;Invalid register declaration: &#39;{tokens[1]}&#39;&#34;)
        return QASM.QReg(match[1], int(match[2]))

    @staticmethod
    def _parse_creg(tokens: List[str]) -&gt; &#34;QASM.CReg&#34;:
        if len(tokens) != 2:
            raise ValueError(f&#34;Expected exactly 2 statement tokens for creg statement. &#34;
                             f&#34;Instead, found {tokens}&#34;)
        pattern = re.compile(r&#34;([a-zA-Z0-9]+)\[(.+)\]&#34;)
        match = pattern.fullmatch(tokens[1])
        if not match:
            raise ValueError(f&#34;Invalid register declaration: &#39;{tokens[1]}&#39;&#34;)
        return QASM.CReg(match[1], int(match[2]))

    @staticmethod
    def _parse_qreg_target(token: str,
                           qregs: Dict[str, &#34;QASM.QReg&#34;]) -&gt; &#34;QASM.QRegTarget&#34;:
        if token in qregs:
            return QASM.QRegTarget(qregs[token])
        pattern = re.compile(r&#34;([a-zA-Z0-9]+)\[(.+)\]&#34;)
        match = pattern.fullmatch(token)
        if not match or match[1] not in qregs:
            raise ValueError(f&#34;Invalid register target or unknown register: &#39;{token}&#39;&#34;)
        return QASM.QRegTarget(qregs[match[1]], int(match[2]))

    @staticmethod
    def _parse_creg_target(token: str,
                           cregs: Dict[str, &#34;QASM.CReg&#34;]) -&gt; &#34;QASM.CRegTarget&#34;:
        if token in cregs:
            return QASM.CRegTarget(cregs[token])
        pattern = re.compile(r&#34;([a-zA-Z0-9]+)\[(.+)\]&#34;)
        match = pattern.fullmatch(token)
        if not match or match[1] not in cregs:
            raise ValueError(f&#34;Invalid register target or unknown register: &#39;{token}&#39;&#34;)
        return QASM.CRegTarget(cregs[match[1]], int(match[2]))

    @staticmethod
    def _parse_reg_target(token: str,
                          qregs: Dict[str, &#34;QASM.QReg&#34;],
                          cregs: Dict[str, &#34;QASM.CReg&#34;]) -&gt; &#34;QASM.RegTarget&#34;:
        if token in qregs:
            return QASM.QRegTarget(qregs[token])
        if token in cregs:
            return QASM.CRegTarget(cregs[token])
        pattern = re.compile(r&#34;([a-zA-Z0-9]+)\[(.+)\]&#34;)
        match = pattern.fullmatch(token)
        if not match or (match[1] not in qregs and match[1] not in cregs):
            raise ValueError(f&#34;Invalid register target or unknown register: &#39;{token}&#39;&#34;)
        if match[1] in qregs:
            return QASM.QRegTarget(qregs[match[1]], int(match[2]))
        return QASM.CRegTarget(cregs[match[1]], int(match[2]))

    @staticmethod
    def _parse_u(tokens: List[str], qregs: Dict[str, &#34;QASM.QReg&#34;]) -&gt; &#34;QASM.UGate&#34;:
        if len(tokens) != 2:
            raise ValueError(f&#34;Expected exactly 2 statement tokens for U gate statement. &#34;
                             f&#34;Instead, found {tokens}&#34;)
        pattern = re.compile(r&#34;U\((.+)\)&#34;)
        match = pattern.fullmatch(tokens[0])
        if not match:
            raise ValueError(f&#34;Invalid first token for U gate statement: &#39;{tokens[0]}&#39;&#34;)
        params = match[1].split(&#34;,&#34;)
        if len(params) != 3:
            raise ValueError(f&#34;Expected exactly 3 parameter tokens for U gate statement. &#34;
                             f&#34;Instead, found {params}&#34;)
        angles = [QASM._parse_angle(p) for p in params]
        qubit = QASM._parse_qreg_target(tokens[1], qregs)
        return QASM.UGate(angles[0], angles[1], angles[2], qubit)

    @staticmethod
    def _parse_cx(tokens: List[str], qregs: Dict[str, &#34;QASM.QReg&#34;]) -&gt; &#34;QASM.CXGate&#34;:
        if len(tokens) != 2:
            raise ValueError(f&#34;Expected exactly 2 statement tokens for CX gate statement. &#34;
                             f&#34;Instead, found {tokens}&#34;)
        qreg_targets = tokens[1].split(&#34;,&#34;)
        if len(qreg_targets) != 2:
            raise ValueError(f&#34;Expected exactly 2 qreg target tokens for CX gate statement. &#34;
                             f&#34;Instead, found {qreg_targets}&#34;)
        ctrl = QASM._parse_qreg_target(qreg_targets[0], qregs)
        trgt = QASM._parse_qreg_target(qreg_targets[1], qregs)
        return QASM.CXGate(ctrl, trgt)

    @staticmethod
    def _parse_measure(tokens: List[str],
                       qregs: Dict[str, &#34;QASM.QReg&#34;],
                       cregs: Dict[str, &#34;QASM.CReg&#34;]) -&gt; &#34;QASM.Measure&#34;:
        if len(tokens) != 2:
            raise ValueError(f&#34;Expected exactly 2 statement tokens for measure statement. &#34;
                             f&#34;Instead, found {tokens}&#34;)
        targets = tokens[1].split(&#34;-&gt;&#34;)
        if len(targets) != 2:
            raise ValueError(f&#34;Expected exactly 2 target tokens for measure statement. &#34;
                             f&#34;Instead, found {targets}&#34;)
        qubit = QASM._parse_qreg_target(targets[0], qregs)
        bit = QASM._parse_creg_target(targets[1], cregs)
        return QASM.Measure(qubit, bit)

    @staticmethod
    def _parse_reset(tokens: List[str], qregs: Dict[str, &#34;QASM.QReg&#34;]) -&gt; &#34;QASM.Reset&#34;:
        if len(tokens) != 2:
            raise ValueError(f&#34;Expected exactly 2 statement tokens for reset statement. &#34;
                             f&#34;Instead, found {tokens}&#34;)
        qubit = QASM._parse_qreg_target(tokens[1], qregs)
        return QASM.Reset(qubit)

    @staticmethod
    def _parse_barrier(tokens: List[str], qregs: Dict[str, &#34;QASM.QReg&#34;]) -&gt; &#34;QASM.Barrier&#34;:
        if len(tokens) != 2:
            raise ValueError(f&#34;Expected exactly 2 statement tokens for barrier statement. &#34;
                             f&#34;Instead, found {tokens}&#34;)
        qreg_targets = tokens[1].split(&#34;,&#34;)
        if not qreg_targets:
            raise ValueError(f&#34;Expected at least one qreg target token for barrier statement. &#34;
                             f&#34;Instead, found {qreg_targets}&#34;)
        qubits = [QASM._parse_qreg_target(t, qregs) for t in qreg_targets]
        return QASM.Barrier(qubits)

    @staticmethod
    def _parse_conditional(tokens: List[str],
                           qregs: Dict[str, &#34;QASM.QReg&#34;],
                           cregs: Dict[str, &#34;QASM.CReg&#34;]) -&gt; &#34;QASM.Conditional&#34;:
        if len(tokens) &lt; 2:
            raise ValueError(f&#34;Expected at least 2 statement tokens for conditional statement. &#34;
                             f&#34;Instead, found {tokens}&#34;)
        pattern = re.compile(r&#34;if\((.+)==(.+)\)&#34;)
        match = pattern.fullmatch(tokens[0])
        if not match:
            raise ValueError(f&#34;Invalid first token for conditional statement: &#39;{tokens[0]}&#39;&#34;)
        register = cregs[match[1]]
        value = int(match[2])
        return QASM.Conditional(register, value, QASM._parse_statement(tokens[1:], qregs, cregs))

    @staticmethod
    def _parse_gate(tokens: List[str],
                    qregs: Dict[str, &#34;QASM.QReg&#34;],
                    cregs: Dict[str, &#34;QASM.CReg&#34;]) -&gt; &#34;QASM.Gate&#34;:
        if len(tokens) != 2:
            raise ValueError(f&#34;Expected exactly 2 statement tokens for named gate statement. &#34;
                             f&#34;Instead, found {tokens}&#34;)
        pattern = re.compile(r&#34;([a-zA-Z0-9]+)\((.+)\)&#34;)
        match = pattern.fullmatch(tokens[0])
        if match:
            name = match[1]
            params = match[2].split(&#34;,&#34;)
        else:
            name = tokens[0]
            params = []
        angles = [QASM._parse_angle(p) for p in params]
        target_tokens = tokens[1].split(&#34;,&#34;)
        if len(target_tokens) == 0:
            raise ValueError(f&#34;Expected at least one target token for named gate statement. &#34;
                             f&#34;Instead, found {target_tokens}&#34;)
        targets = [QASM._parse_reg_target(t, qregs, cregs) for t in target_tokens]
        return QASM.Gate(name, targets, angles)

    @staticmethod
    def _parse_statement(tokens: List[str],
                         qregs: Dict[str, &#34;QASM.QReg&#34;],
                         cregs: Dict[str, &#34;QASM.CReg&#34;]) -&gt; &#34;QASM.Statement&#34;:
        # pylint: disable = too-many-return-statements
        if tokens[0] == &#34;OPENQASM&#34;:
            return QASM._parse_version(tokens)
        if tokens[0] == &#34;qreg&#34;:
            qreg: QASM.QReg = QASM._parse_qreg(tokens)
            if qreg.name in qregs or qreg.name in cregs:
                raise ValueError(f&#34;Repeated register declaration: {qreg.name}&#34;)
            qregs[qreg.name] = qreg
            return qreg
        if tokens[0] == &#34;creg&#34;:
            creg: QASM.CReg = QASM._parse_creg(tokens)
            if creg.name in qregs or creg.name in cregs:
                raise ValueError(f&#34;Repeated register declaration: {creg.name}&#34;)
            cregs[creg.name] = creg
            return creg
        if tokens[0] == &#34;include&#34;:
            return QASM._parse_include(tokens)
        if tokens[0].startswith(&#34;U&#34;):
            return QASM._parse_u(tokens, qregs)
        if tokens[0] == &#34;CX&#34;:
            return QASM._parse_cx(tokens, qregs)
        if tokens[0] == &#34;measure&#34;:
            return QASM._parse_measure(tokens, qregs, cregs)
        if tokens[0] == &#34;reset&#34;:
            return QASM._parse_reset(tokens, qregs)
        if tokens[0] == &#34;barrier&#34;:
            return QASM._parse_barrier(tokens, qregs)
        if tokens[0].startswith(&#34;if&#34;):
            return QASM._parse_conditional(tokens, qregs, cregs)
        return QASM._parse_gate(tokens, qregs, cregs)

    @staticmethod
    def parse(program: str):
        &#34;&#34;&#34; Parses a QASM program into a `QASM` object. &#34;&#34;&#34;
        # pylint: disable = too-many-branches, too-many-statements
        if not isinstance(program, str):
            raise TypeError(&#34;Expected a string.&#34;)
        lines = program.split(&#34;\n&#34;)
        statements: List[QASM.Statement] = []
        cregs: Dict[str, QASM.CReg] = {}
        qregs: Dict[str, QASM.QReg] = {}
        for line in lines:
            line = line.strip()
            line = re.sub(r&#34; *, *&#34;, &#34;,&#34;, line)
            line = re.sub(r&#34; *== *&#34;, &#34;==&#34;, line)
            line = re.sub(r&#34; *-&gt; *&#34;, &#34;-&gt;&#34;, line)
            line = re.sub(r&#34;\( *&#34;, &#34;(&#34;, line)
            line = re.sub(r&#34; *\)&#34;, &#34;)&#34;, line)
            line = re.sub(r&#34;\[ *&#34;, &#34;[&#34;, line)
            line = re.sub(r&#34; *\]&#34;, &#34;]&#34;, line)
            line = re.sub(r&#34;  *&#34;, &#34; &#34;, line)
            if line.startswith(&#34;//&#34;):
                statements.append(QASM._parse_comment(line))
                continue
            if not line:
                continue
            if line.startswith(&#34;gate&#34;):
                # TODO: implement gate definition statements
                continue
            if line.startswith(&#34;gate&#34;):
                # TODO: implement opaque gate definition statements
                continue
            if not line.endswith(&#34;;&#34;):
                raise ValueError(f&#34;Statements should be terminated by semicolon. &#34;
                                 f&#34;Instead, found: {line}&#34;)
            line = line[:-1] # remove final semicolon
            tokens: List[str] = line.split(&#34; &#34;)
            tokens = [t for t in tokens if len(t) != 0]
            try:
                statements.append(QASM._parse_statement(tokens, qregs, cregs))
            except ValueError as _:
                raise ValueError(f&#34;An error arose while parsing line: {line}&#34;)
        return QASM(*statements)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>collections.abc.Sequence</li>
<li>collections.abc.Reversible</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pauliopt.qasm.QASM.Barrier"><code class="name">var <span class="ident">Barrier</span></code></dt>
<dd>
<div class="desc"><p>Statement for a barrier.</p></div>
</dd>
<dt id="pauliopt.qasm.QASM.CReg"><code class="name">var <span class="ident">CReg</span></code></dt>
<dd>
<div class="desc"><p>Classical register.</p></div>
</dd>
<dt id="pauliopt.qasm.QASM.CRegTarget"><code class="name">var <span class="ident">CRegTarget</span></code></dt>
<dd>
<div class="desc"><p>A creg target.</p></div>
</dd>
<dt id="pauliopt.qasm.QASM.CXGate"><code class="name">var <span class="ident">CXGate</span></code></dt>
<dd>
<div class="desc"><p>Statement for a CX gate.</p></div>
</dd>
<dt id="pauliopt.qasm.QASM.Comment"><code class="name">var <span class="ident">Comment</span></code></dt>
<dd>
<div class="desc"><p>QASM comment statement.</p></div>
</dd>
<dt id="pauliopt.qasm.QASM.Conditional"><code class="name">var <span class="ident">Conditional</span></code></dt>
<dd>
<div class="desc"><p>Statement for a conditional statement.</p></div>
</dd>
<dt id="pauliopt.qasm.QASM.Gate"><code class="name">var <span class="ident">Gate</span></code></dt>
<dd>
<div class="desc"><p>Statement for a named gate.</p></div>
</dd>
<dt id="pauliopt.qasm.QASM.Include"><code class="name">var <span class="ident">Include</span></code></dt>
<dd>
<div class="desc"><p>QASM include statement.</p></div>
</dd>
<dt id="pauliopt.qasm.QASM.Measure"><code class="name">var <span class="ident">Measure</span></code></dt>
<dd>
<div class="desc"><p>Statement for a measurement.</p></div>
</dd>
<dt id="pauliopt.qasm.QASM.QReg"><code class="name">var <span class="ident">QReg</span></code></dt>
<dd>
<div class="desc"><p>Quantum register.</p></div>
</dd>
<dt id="pauliopt.qasm.QASM.QRegTarget"><code class="name">var <span class="ident">QRegTarget</span></code></dt>
<dd>
<div class="desc"><p>A qreg target.</p></div>
</dd>
<dt id="pauliopt.qasm.QASM.Reg"><code class="name">var <span class="ident">Reg</span></code></dt>
<dd>
<div class="desc"><p>Register.</p></div>
</dd>
<dt id="pauliopt.qasm.QASM.RegTarget"><code class="name">var <span class="ident">RegTarget</span></code></dt>
<dd>
<div class="desc"><p>A qreg or creg target.</p></div>
</dd>
<dt id="pauliopt.qasm.QASM.Reset"><code class="name">var <span class="ident">Reset</span></code></dt>
<dd>
<div class="desc"><p>Statement for a reset.</p></div>
</dd>
<dt id="pauliopt.qasm.QASM.Statement"><code class="name">var <span class="ident">Statement</span></code></dt>
<dd>
<div class="desc"><p>QASM statement.</p></div>
</dd>
<dt id="pauliopt.qasm.QASM.UGate"><code class="name">var <span class="ident">UGate</span></code></dt>
<dd>
<div class="desc"><p>Statement for a U3 gate.</p></div>
</dd>
<dt id="pauliopt.qasm.QASM.Version"><code class="name">var <span class="ident">Version</span></code></dt>
<dd>
<div class="desc"><p>QASM version statement.</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="pauliopt.qasm.QASM.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>program: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses a QASM program into a <code><a title="pauliopt.qasm.QASM" href="#pauliopt.qasm.QASM">QASM</a></code> object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(program: str):
    &#34;&#34;&#34; Parses a QASM program into a `QASM` object. &#34;&#34;&#34;
    # pylint: disable = too-many-branches, too-many-statements
    if not isinstance(program, str):
        raise TypeError(&#34;Expected a string.&#34;)
    lines = program.split(&#34;\n&#34;)
    statements: List[QASM.Statement] = []
    cregs: Dict[str, QASM.CReg] = {}
    qregs: Dict[str, QASM.QReg] = {}
    for line in lines:
        line = line.strip()
        line = re.sub(r&#34; *, *&#34;, &#34;,&#34;, line)
        line = re.sub(r&#34; *== *&#34;, &#34;==&#34;, line)
        line = re.sub(r&#34; *-&gt; *&#34;, &#34;-&gt;&#34;, line)
        line = re.sub(r&#34;\( *&#34;, &#34;(&#34;, line)
        line = re.sub(r&#34; *\)&#34;, &#34;)&#34;, line)
        line = re.sub(r&#34;\[ *&#34;, &#34;[&#34;, line)
        line = re.sub(r&#34; *\]&#34;, &#34;]&#34;, line)
        line = re.sub(r&#34;  *&#34;, &#34; &#34;, line)
        if line.startswith(&#34;//&#34;):
            statements.append(QASM._parse_comment(line))
            continue
        if not line:
            continue
        if line.startswith(&#34;gate&#34;):
            # TODO: implement gate definition statements
            continue
        if line.startswith(&#34;gate&#34;):
            # TODO: implement opaque gate definition statements
            continue
        if not line.endswith(&#34;;&#34;):
            raise ValueError(f&#34;Statements should be terminated by semicolon. &#34;
                             f&#34;Instead, found: {line}&#34;)
        line = line[:-1] # remove final semicolon
        tokens: List[str] = line.split(&#34; &#34;)
        tokens = [t for t in tokens if len(t) != 0]
        try:
            statements.append(QASM._parse_statement(tokens, qregs, cregs))
        except ValueError as _:
            raise ValueError(f&#34;An error arose while parsing line: {line}&#34;)
    return QASM(*statements)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="pauliopt.qasm.QASM.num_bits"><code class="name">var <span class="ident">num_bits</span> : int</code></dt>
<dd>
<div class="desc"><p>Number of bits in this circuit.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def num_bits(self) -&gt; int:
    &#34;&#34;&#34; Number of bits in this circuit. &#34;&#34;&#34;
    return sum(reg.size for reg in self._registers.values() if isinstance(reg, QASM.CReg))</code></pre>
</details>
</dd>
<dt id="pauliopt.qasm.QASM.num_qubits"><code class="name">var <span class="ident">num_qubits</span> : int</code></dt>
<dd>
<div class="desc"><p>Number of qubits in this circuit.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def num_qubits(self) -&gt; int:
    &#34;&#34;&#34; Number of qubits in this circuit. &#34;&#34;&#34;
    return sum(reg.size for reg in self._registers.values() if isinstance(reg, QASM.QReg))</code></pre>
</details>
</dd>
<dt id="pauliopt.qasm.QASM.registers"><code class="name">var <span class="ident">registers</span> : Iterator[Union[<a title="pauliopt.qasm.QASM.QReg" href="#pauliopt.qasm.QASM.QReg">QASM.QReg</a>, <a title="pauliopt.qasm.QASM.CReg" href="#pauliopt.qasm.QASM.CReg">QASM.CReg</a>]]</code></dt>
<dd>
<div class="desc"><p>Iterator over the registers of this QASM program.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def registers(self) -&gt; Iterator[Union[&#34;QASM.QReg&#34;, &#34;QASM.CReg&#34;]]:
    &#34;&#34;&#34; Iterator over the registers of this QASM program. &#34;&#34;&#34;
    return (reg for _, reg in self._registers.items())</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pauliopt" href="index.html">pauliopt</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pauliopt.qasm.assert_same_size_targets" href="#pauliopt.qasm.assert_same_size_targets">assert_same_size_targets</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pauliopt.qasm.QASM" href="#pauliopt.qasm.QASM">QASM</a></code></h4>
<ul class="two-column">
<li><code><a title="pauliopt.qasm.QASM.Barrier" href="#pauliopt.qasm.QASM.Barrier">Barrier</a></code></li>
<li><code><a title="pauliopt.qasm.QASM.CReg" href="#pauliopt.qasm.QASM.CReg">CReg</a></code></li>
<li><code><a title="pauliopt.qasm.QASM.CRegTarget" href="#pauliopt.qasm.QASM.CRegTarget">CRegTarget</a></code></li>
<li><code><a title="pauliopt.qasm.QASM.CXGate" href="#pauliopt.qasm.QASM.CXGate">CXGate</a></code></li>
<li><code><a title="pauliopt.qasm.QASM.Comment" href="#pauliopt.qasm.QASM.Comment">Comment</a></code></li>
<li><code><a title="pauliopt.qasm.QASM.Conditional" href="#pauliopt.qasm.QASM.Conditional">Conditional</a></code></li>
<li><code><a title="pauliopt.qasm.QASM.Gate" href="#pauliopt.qasm.QASM.Gate">Gate</a></code></li>
<li><code><a title="pauliopt.qasm.QASM.Include" href="#pauliopt.qasm.QASM.Include">Include</a></code></li>
<li><code><a title="pauliopt.qasm.QASM.Measure" href="#pauliopt.qasm.QASM.Measure">Measure</a></code></li>
<li><code><a title="pauliopt.qasm.QASM.QReg" href="#pauliopt.qasm.QASM.QReg">QReg</a></code></li>
<li><code><a title="pauliopt.qasm.QASM.QRegTarget" href="#pauliopt.qasm.QASM.QRegTarget">QRegTarget</a></code></li>
<li><code><a title="pauliopt.qasm.QASM.Reg" href="#pauliopt.qasm.QASM.Reg">Reg</a></code></li>
<li><code><a title="pauliopt.qasm.QASM.RegTarget" href="#pauliopt.qasm.QASM.RegTarget">RegTarget</a></code></li>
<li><code><a title="pauliopt.qasm.QASM.Reset" href="#pauliopt.qasm.QASM.Reset">Reset</a></code></li>
<li><code><a title="pauliopt.qasm.QASM.Statement" href="#pauliopt.qasm.QASM.Statement">Statement</a></code></li>
<li><code><a title="pauliopt.qasm.QASM.UGate" href="#pauliopt.qasm.QASM.UGate">UGate</a></code></li>
<li><code><a title="pauliopt.qasm.QASM.Version" href="#pauliopt.qasm.QASM.Version">Version</a></code></li>
<li><code><a title="pauliopt.qasm.QASM.num_bits" href="#pauliopt.qasm.QASM.num_bits">num_bits</a></code></li>
<li><code><a title="pauliopt.qasm.QASM.num_qubits" href="#pauliopt.qasm.QASM.num_qubits">num_qubits</a></code></li>
<li><code><a title="pauliopt.qasm.QASM.parse" href="#pauliopt.qasm.QASM.parse">parse</a></code></li>
<li><code><a title="pauliopt.qasm.QASM.registers" href="#pauliopt.qasm.QASM.registers">registers</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>