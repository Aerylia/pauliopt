<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>pauliopt.utils API documentation</title>
<meta name="description" content="Utility classes and functions for the `pauliopt` library." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pauliopt.utils</code></h1>
</header>
<section id="section-intro">
<p>Utility classes and functions for the <code><a title="pauliopt" href="index.html">pauliopt</a></code> library.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
    Utility classes and functions for the `pauliopt` library.
&#34;&#34;&#34;

import math
from decimal import Decimal
from fractions import Fraction
from typing import (Final, List, Literal, Mapping, Optional, overload,
                    Protocol, runtime_checkable, Sequence, Tuple, TypeVar, Union)

AngleT = TypeVar(&#34;AngleT&#34;, bound=&#34;AngleProtocol&#34;)
&#34;&#34;&#34;
    Type variable for something fitting the `AngleProtocol` protocol below.
&#34;&#34;&#34;

@runtime_checkable
class AngleProtocol(Protocol[AngleT]):
    &#34;&#34;&#34;
        A protocol for an angle type.

        Copyright (C) 2019 - Hashberg Ltd
    &#34;&#34;&#34;

    def __neg__(self: AngleT) -&gt; AngleT:
        ...

    def __pos__(self: AngleT) -&gt; AngleT:
        ...

    def __add__(self: AngleT, other: AngleT) -&gt; AngleT:
        ...

    def __sub__(self: AngleT, other: AngleT) -&gt; AngleT:
        ...

    def __mul__(self: AngleT, other: Union[int, Fraction]) -&gt; AngleT:
        ...

    def __rmul__(self: AngleT, other: Union[int, Fraction]) -&gt; AngleT:
        ...

    def __truediv__(self: AngleT, other: Union[int, Fraction]) -&gt; AngleT:
        ...

    def __float__(self: AngleT) -&gt; float:
        ...



AngleInitT = Union[int, Fraction, Decimal, str]

class Angle(AngleProtocol[&#34;Angle&#34;]):
    &#34;&#34;&#34;
        A container class for angles,
        as rational multiples of PI modulo 2PI.

        Copyright (C) 2019 - Hashberg Ltd
    &#34;&#34;&#34;

    _value: Fraction

    def __init__(self, theta: Union[&#34;Angle&#34;, AngleInitT]):
        if isinstance(theta, Angle):
            self._value = theta.value
        else:
            self._value = Fraction(theta)

    @property
    def value(self) -&gt; Fraction:
        &#34;&#34;&#34;
            The value of this angle as a fraction of PI.
        &#34;&#34;&#34;
        return self._value%2

    @property
    def as_root_of_unity(self) -&gt; Tuple[int, int]:
        &#34;&#34;&#34;
            Returns `(a,n)` where `n` is the smallest such
            that this angle is an $n$-th root of unity
            and `0 &lt;= a &lt; n` such that this is $e^{i 2\\pi \\frac{a}{n}}$
        &#34;&#34;&#34;
        num = self.value.numerator
        den = self.value.denominator
        a: int = num//2 if num%2 == 0 else num
        order: int = den if num % 2 == 0 else 2*den
        return (a, order)

    @property
    def order(self):
        &#34;&#34;&#34;
            The order of this angle as a root of unity.
        &#34;&#34;&#34;
        num = self.value.numerator
        den = self.value.denominator
        return den if num % 2 == 0 else 2*den

    def __pos__(self) -&gt; &#34;Angle&#34;:
        return self

    def __neg__(self) -&gt; &#34;Angle&#34;:
        return Angle(-self._value)

    def __add__(self, other: &#34;Angle&#34;) -&gt; &#34;Angle&#34;:
        if isinstance(other, Angle):
            return Angle(self._value + other._value)
        return NotImplemented

    def __sub__(self, other: &#34;Angle&#34;) -&gt; &#34;Angle&#34;:
        if isinstance(other, Angle):
            return Angle(self._value - other._value)
        return NotImplemented

    def __mul__(self, other: Union[int, Fraction, str]) -&gt; &#34;Angle&#34;:
        if isinstance(other, int):
            return Angle(self._value * Fraction(other))
        return NotImplemented

    def __rmul__(self, other: Union[int, Fraction, str]) -&gt; &#34;Angle&#34;:
        if isinstance(other, int):
            return Angle(self._value * Fraction(other))
        return NotImplemented

    def __truediv__(self, other: Union[int, Fraction, str]) -&gt; &#34;Angle&#34;:
        if isinstance(other, int):
            return Angle(self._value / Fraction(other))
        return NotImplemented

    def __hash__(self) -&gt; int:
        return hash(repr(self))

    def __str__(self) -&gt; str:
        num = self.value.numerator
        den = self.value.denominator
        if num == 0:
            return &#34;0&#34;
        if num == 1:
            if den == 1:
                return &#34;π&#34;
            return &#34;π/%d&#34;%den
        return &#34;%dπ/%d&#34;%(num, den)

    def __repr__(self) -&gt; str:
        num = self.value.numerator
        den = self.value.denominator
        if num == 0:
            return &#34;Angle.zero&#34;
        if num == 1:
            if den == 1:
                return &#34;Angle.pi&#34;
            return &#34;Angle.pi/%d&#34;%den
        return &#34;%d*Angle.pi/%d&#34;%(num, den)

    @property
    def repr_latex(self) -&gt; str:
        &#34;&#34;&#34;
            LaTeX math mode representation of this number.
        &#34;&#34;&#34;
        num = self.value.numerator
        den = self.value.denominator
        if num == 0:
            return &#34;0&#34;
        if num == 1:
            if den == 1:
                return &#34;\\pi&#34;
            return &#34;\\frac{\\pi}{%d}&#34;%den
        return &#34;\\frac{%d\\pi}{%d}&#34;%(num, den)

    def _repr_latex_(self):
        &#34;&#34;&#34;
            Magic method for IPython/Jupyter pretty-printing.
            See https://ipython.readthedocs.io/en/stable/api/generated/IPython.display.html
        &#34;&#34;&#34;
        return &#34;$%s$&#34;%self.repr_latex

    def __eq__(self, other):
        if not isinstance(other, Angle):
            return NotImplemented
        return self.value == other.value

    def __float__(self) -&gt; float:
        return float(self.value)*math.pi

    @overload
    @staticmethod
    def random(subdivision: int = 4, *,
               size: Literal[1]=1,
               rng_seed: Optional[int] = None) -&gt; &#34;Angle&#34;:
        ...

    @overload
    @staticmethod
    def random(subdivision: int = 4, *,
               size: int = 1,
               rng_seed: Optional[int] = None) -&gt; Union[&#34;Angle&#34;, Tuple[&#34;Angle&#34;, ...]]:
        ...

    @staticmethod
    def random(subdivision: int = 4, *, size: int = 1, rng_seed: Optional[int] = None):
        &#34;&#34;&#34;
            Generates a random angle with the given `subdivision`:
            `r * pi/subdivision` for random `r in range(2*subdivision)`.

            Requires `numpy`.
        &#34;&#34;&#34;
        if not isinstance(subdivision, int):
            raise TypeError()
        if not isinstance(size, int):
            raise TypeError()
        if subdivision &lt;= 0:
            raise ValueError(&#34;Subdivision must be positive.&#34;)
        if size &lt;= 0:
            raise ValueError(&#34;Size must be positive.&#34;)
        if rng_seed is not None and not isinstance(rng_seed, int):
            raise TypeError(&#34;RNG seed must be integer or &#39;None&#39;.&#34;)
        try:
            # pylint: disable = import-outside-toplevel, unused-import
            import numpy as np # type: ignore
        except ModuleNotFoundError as _:
            raise ModuleNotFoundError(&#34;You must install the &#39;numpy&#39; library.&#34;)
        rng = np.random.default_rng(seed=rng_seed)
        rs = rng.integers(2*subdivision, size=size)
        if size == 1:
            return Angle(Fraction(int(rs[0]), subdivision))
        return tuple(Angle(Fraction(int(r), subdivision)) for r in rs)

    zero: Final[&#34;Angle&#34;] # type: ignore
    &#34;&#34;&#34; A constant for the angle 0. &#34;&#34;&#34;

    pi: Final[&#34;Angle&#34;] # type: ignore
    &#34;&#34;&#34; A constant for the angle pi. &#34;&#34;&#34;

# Set static constants for Angle:
Angle.zero = Angle(0) # type: ignore
Angle.pi = Angle(1) # type: ignore


pi: Final[Angle] = Angle.pi
&#34;&#34;&#34; Constant for `Angle.pi`. &#34;&#34;&#34;

π: Final[Angle] = Angle.pi
&#34;&#34;&#34; Constant for `Angle.pi`. &#34;&#34;&#34;


def _validate_vec2(vec2: Tuple[int, int]):
    if not isinstance(vec2, tuple) or len(vec2) != 2:
        raise TypeError(&#34;Expected pair.&#34;)
    if not all(isinstance(x, int) for x in vec2):
        raise TypeError(&#34;Expected pair of integers.&#34;)

class SVGBuilder:
    &#34;&#34;&#34;
        Utility class for building certain SVG images.
        Follows the [Fluent interface pattern](https://en.wikipedia.org/wiki/Fluent_interface).
    &#34;&#34;&#34;

    _width: int
    _height: int
    _fill: str
    _stroke: str
    _tags: List[str]

    def __init__(self, width: int, height: int):
        if not isinstance(width, int) or width &lt;= 0:
            raise TypeError(&#34;Width should be positive integer.&#34;)
        if not isinstance(height, int) or height &lt;= 0:
            raise TypeError(&#34;Height should be positive integer.&#34;)
        self._width = width
        self._height = height
        self._fill = &#34;none&#34;
        self._stroke = &#34;black&#34;
        self._tags = []

    @property
    def width(self) -&gt; int:
        &#34;&#34;&#34;
            The figure width.
        &#34;&#34;&#34;
        return self._width

    @property
    def height(self) -&gt; int:
        &#34;&#34;&#34;
            The figure height.
        &#34;&#34;&#34;
        return self._height

    @property
    def tags(self) -&gt; Sequence[str]:
        &#34;&#34;&#34;
            The current sequence of tags.
        &#34;&#34;&#34;
        return self._tags

    def line(self, fro: Tuple[int, int], to: Tuple[int, int]) -&gt; &#34;SVGBuilder&#34;:
        &#34;&#34;&#34;
            Draws a line from given coordinates to given coordinates.
        &#34;&#34;&#34;
        _validate_vec2(fro)
        _validate_vec2(to)
        fx, fy = fro
        tx, ty = to
        tag = (f&#39;&lt;path fill=&#34;none&#34; stroke=&#34;black&#34;&#39;
               f&#39; d=&#34;M {fx}, {fy} L {tx}, {ty}&#34;/&gt;&#39;)
        self._tags.append(tag)
        return self

    def circle(self, centre: Tuple[int, int], r: int, fill: str) -&gt; &#34;SVGBuilder&#34;:
        &#34;&#34;&#34;
            Draws a circle with given centre and radius.
        &#34;&#34;&#34;
        _validate_vec2(centre)
        if not isinstance(fill, str):
            raise TypeError(&#34;Fill must be string.&#34;)
        x, y = centre
        tag = (f&#39;&lt;circle fill=&#34;{fill}&#34; stroke=&#34;black&#34;&#39;
               f&#39; cx=&#34;{x}&#34; cy=&#34;{y}&#34; r=&#34;{r}&#34;/&gt;&#39;)
        self._tags.append(tag)
        return self

    def text(self, pos: Tuple[int, int], text: str, *, font_size: int = 10) -&gt; &#34;SVGBuilder&#34;:
        &#34;&#34;&#34;
            Draws text at the given position (stroke/fill not used).
        &#34;&#34;&#34;
        _validate_vec2(pos)
        if not isinstance(text, str):
            raise TypeError(&#34;Text must be string.&#34;)
        if not isinstance(font_size, int) or font_size &lt;= 0:
            raise TypeError(&#34;Font size must be positive integer.&#34;)
        x, y = pos
        tag = f&#39;&lt;text x=&#34;{x}&#34; y=&#34;{y+font_size//4}&#34; font-size=&#34;{font_size}&#34;&gt;{text}&lt;/text&gt;&#39;
        self._tags.append(tag)
        return self

    def __repr__(self) -&gt; str:
        body = &#34;\n&#34;.join(self._tags)
        return f&#39;&lt;svg width=&#34;{self.width}&#34; height=&#34;{self.height}&#34;&gt;{body}&lt;/svg&gt;&#39;


@runtime_checkable
class TempSchedule(Protocol):
    &#34;&#34;&#34;
        Protocol for a temperature schedule.
        The temperature is a number (int or float) computed from the iteration
        number `it` (starting from 0) and the total number of iterations `num_iter`
        (passed as a keyword argument).
    &#34;&#34;&#34;

    def __call__(self, it: int, num_iters: int) -&gt; float:
        ...

@runtime_checkable
class TempScheduleProvider(Protocol):
    &#34;&#34;&#34;
        Protocol for a function constructing a temperature schedule
        from an initial and final temperatures.
    &#34;&#34;&#34;

    def __call__(self, t_init: Union[int, float], t_final: Union[int, float]) -&gt; TempSchedule:
        ...


def linear_temp_schedule(t_init: Union[int, float], t_final: Union[int, float]) -&gt; TempSchedule:
    &#34;&#34;&#34;
        Returns a straight/linear temperature schedule for given initial and final temperatures,
        from https://link.springer.com/article/10.1007/BF00143921
    &#34;&#34;&#34;
    if not isinstance(t_init, (int, float)):
        raise TypeError(f&#34;Expected int or float, found {type(t_init)}.&#34;)
    if not isinstance(t_final, (int, float)):
        raise TypeError(f&#34;Expected int or float, found {type(t_final)}.&#34;)
    def temp_schedule(it: int, num_iters: int) -&gt; float:
        return t_init + (t_final-t_init)*it/(num_iters-1)
    return temp_schedule


def geometric_temp_schedule(t_init: Union[int, float], t_final: Union[int, float]) -&gt; TempSchedule:
    &#34;&#34;&#34;
        Returns a geometric temperature schedule for given initial and final temperatures,
        from https://link.springer.com/article/10.1007/BF00143921
    &#34;&#34;&#34;
    if not isinstance(t_init, (int, float)):
        raise TypeError(f&#34;Expected int or float, found {type(t_init)}.&#34;)
    if not isinstance(t_final, (int, float)):
        raise TypeError(f&#34;Expected int or float, found {type(t_final)}.&#34;)
    def temp_schedule(it: int, num_iters: int) -&gt; float:
        return t_init * ((t_final/t_init)**(it/(num_iters-1)))
    return temp_schedule


def reciprocal_temp_schedule(t_init: Union[int, float], t_final: Union[int, float]) -&gt; TempSchedule:
    &#34;&#34;&#34;
        Returns a reciprocal temperature schedule for given initial and final temperatures,
        from https://link.springer.com/article/10.1007/BF00143921
    &#34;&#34;&#34;
    if not isinstance(t_init, (int, float)):
        raise TypeError(f&#34;Expected int or float, found {type(t_init)}.&#34;)
    if not isinstance(t_final, (int, float)):
        raise TypeError(f&#34;Expected int or float, found {type(t_final)}.&#34;)
    def temp_schedule(it: int, num_iters: int) -&gt; float:
        num = t_init*t_final*(num_iters-1)
        denom = (t_final*num_iters-t_init)+(t_init-t_final)*(it+1)
        return num/denom
    return temp_schedule


def log_temp_schedule(t_init: Union[int, float], t_final: Union[int, float]) -&gt; TempSchedule:
    &#34;&#34;&#34;
        Returns a logarithmic temperature schedule for given initial and final temperatures,
        from https://link.springer.com/article/10.1007/BF00143921
    &#34;&#34;&#34;
    if not isinstance(t_init, (int, float)):
        raise TypeError(f&#34;Expected int or float, found {type(t_init)}.&#34;)
    if not isinstance(t_final, (int, float)):
        raise TypeError(f&#34;Expected int or float, found {type(t_final)}.&#34;)
    def temp_schedule(it: int, num_iters: int) -&gt; float:
        num = t_init*t_final*(math.log(num_iters+1)-math.log(2))
        denom = (t_final*math.log(num_iters+1)-t_init*math.log(2))+(t_init-t_final)*math.log(it+2)
        return num/denom
    return temp_schedule


StandardTempScheduleName = Literal[&#34;linear&#34;, &#34;geometric&#34;, &#34;reciprocal&#34;, &#34;log&#34;]
&#34;&#34;&#34;
    Names of the standard temperature schedules.
&#34;&#34;&#34;


StandardTempSchedule = Tuple[StandardTempScheduleName,
                             Union[int, float], Union[int, float]]
&#34;&#34;&#34;
    Type for standard temperature schedules.
&#34;&#34;&#34;


StandardTempSchedules: Final[Mapping[StandardTempScheduleName, TempScheduleProvider]] = {
    &#34;linear&#34;: linear_temp_schedule,
    &#34;geometric&#34;: geometric_temp_schedule,
    &#34;reciprocal&#34;: reciprocal_temp_schedule,
    &#34;log&#34;: log_temp_schedule,
}
&#34;&#34;&#34;
    Dictionary of standard temperature schedule providers.
&#34;&#34;&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="pauliopt.utils.AngleT"><code class="name">var <span class="ident">AngleT</span></code></dt>
<dd>
<div class="desc"><p>Type variable for something fitting the <code><a title="pauliopt.utils.AngleProtocol" href="#pauliopt.utils.AngleProtocol">AngleProtocol</a></code> protocol below.</p></div>
</dd>
<dt id="pauliopt.utils.StandardTempSchedule"><code class="name">var <span class="ident">StandardTempSchedule</span></code></dt>
<dd>
<div class="desc"><p>Type for standard temperature schedules.</p></div>
</dd>
<dt id="pauliopt.utils.StandardTempScheduleName"><code class="name">var <span class="ident">StandardTempScheduleName</span></code></dt>
<dd>
<div class="desc"><p>Names of the standard temperature schedules.</p></div>
</dd>
<dt id="pauliopt.utils.StandardTempSchedules"><code class="name">var <span class="ident">StandardTempSchedules</span> : Final[Mapping[Literal['linear', 'geometric', 'reciprocal', 'log'], <a title="pauliopt.utils.TempScheduleProvider" href="#pauliopt.utils.TempScheduleProvider">TempScheduleProvider</a>]]</code></dt>
<dd>
<div class="desc"><p>Dictionary of standard temperature schedule providers.</p></div>
</dd>
<dt id="pauliopt.utils.pi"><code class="name">var <span class="ident">pi</span> : Final[<a title="pauliopt.utils.Angle" href="#pauliopt.utils.Angle">Angle</a>]</code></dt>
<dd>
<div class="desc"><p>Constant for <code><a title="pauliopt.utils.Angle.pi" href="#pauliopt.utils.Angle.pi">Angle.pi</a></code>.</p></div>
</dd>
<dt id="pauliopt.utils.π"><code class="name">var <span class="ident">π</span> : Final[<a title="pauliopt.utils.Angle" href="#pauliopt.utils.Angle">Angle</a>]</code></dt>
<dd>
<div class="desc"><p>Constant for <code><a title="pauliopt.utils.Angle.pi" href="#pauliopt.utils.Angle.pi">Angle.pi</a></code>.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pauliopt.utils.geometric_temp_schedule"><code class="name flex">
<span>def <span class="ident">geometric_temp_schedule</span></span>(<span>t_init: Union[int, float], t_final: Union[int, float]) ‑> <a title="pauliopt.utils.TempSchedule" href="#pauliopt.utils.TempSchedule">TempSchedule</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns a geometric temperature schedule for given initial and final temperatures,
from <a href="https://link.springer.com/article/10.1007/BF00143921">https://link.springer.com/article/10.1007/BF00143921</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def geometric_temp_schedule(t_init: Union[int, float], t_final: Union[int, float]) -&gt; TempSchedule:
    &#34;&#34;&#34;
        Returns a geometric temperature schedule for given initial and final temperatures,
        from https://link.springer.com/article/10.1007/BF00143921
    &#34;&#34;&#34;
    if not isinstance(t_init, (int, float)):
        raise TypeError(f&#34;Expected int or float, found {type(t_init)}.&#34;)
    if not isinstance(t_final, (int, float)):
        raise TypeError(f&#34;Expected int or float, found {type(t_final)}.&#34;)
    def temp_schedule(it: int, num_iters: int) -&gt; float:
        return t_init * ((t_final/t_init)**(it/(num_iters-1)))
    return temp_schedule</code></pre>
</details>
</dd>
<dt id="pauliopt.utils.linear_temp_schedule"><code class="name flex">
<span>def <span class="ident">linear_temp_schedule</span></span>(<span>t_init: Union[int, float], t_final: Union[int, float]) ‑> <a title="pauliopt.utils.TempSchedule" href="#pauliopt.utils.TempSchedule">TempSchedule</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns a straight/linear temperature schedule for given initial and final temperatures,
from <a href="https://link.springer.com/article/10.1007/BF00143921">https://link.springer.com/article/10.1007/BF00143921</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def linear_temp_schedule(t_init: Union[int, float], t_final: Union[int, float]) -&gt; TempSchedule:
    &#34;&#34;&#34;
        Returns a straight/linear temperature schedule for given initial and final temperatures,
        from https://link.springer.com/article/10.1007/BF00143921
    &#34;&#34;&#34;
    if not isinstance(t_init, (int, float)):
        raise TypeError(f&#34;Expected int or float, found {type(t_init)}.&#34;)
    if not isinstance(t_final, (int, float)):
        raise TypeError(f&#34;Expected int or float, found {type(t_final)}.&#34;)
    def temp_schedule(it: int, num_iters: int) -&gt; float:
        return t_init + (t_final-t_init)*it/(num_iters-1)
    return temp_schedule</code></pre>
</details>
</dd>
<dt id="pauliopt.utils.log_temp_schedule"><code class="name flex">
<span>def <span class="ident">log_temp_schedule</span></span>(<span>t_init: Union[int, float], t_final: Union[int, float]) ‑> <a title="pauliopt.utils.TempSchedule" href="#pauliopt.utils.TempSchedule">TempSchedule</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns a logarithmic temperature schedule for given initial and final temperatures,
from <a href="https://link.springer.com/article/10.1007/BF00143921">https://link.springer.com/article/10.1007/BF00143921</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log_temp_schedule(t_init: Union[int, float], t_final: Union[int, float]) -&gt; TempSchedule:
    &#34;&#34;&#34;
        Returns a logarithmic temperature schedule for given initial and final temperatures,
        from https://link.springer.com/article/10.1007/BF00143921
    &#34;&#34;&#34;
    if not isinstance(t_init, (int, float)):
        raise TypeError(f&#34;Expected int or float, found {type(t_init)}.&#34;)
    if not isinstance(t_final, (int, float)):
        raise TypeError(f&#34;Expected int or float, found {type(t_final)}.&#34;)
    def temp_schedule(it: int, num_iters: int) -&gt; float:
        num = t_init*t_final*(math.log(num_iters+1)-math.log(2))
        denom = (t_final*math.log(num_iters+1)-t_init*math.log(2))+(t_init-t_final)*math.log(it+2)
        return num/denom
    return temp_schedule</code></pre>
</details>
</dd>
<dt id="pauliopt.utils.reciprocal_temp_schedule"><code class="name flex">
<span>def <span class="ident">reciprocal_temp_schedule</span></span>(<span>t_init: Union[int, float], t_final: Union[int, float]) ‑> <a title="pauliopt.utils.TempSchedule" href="#pauliopt.utils.TempSchedule">TempSchedule</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns a reciprocal temperature schedule for given initial and final temperatures,
from <a href="https://link.springer.com/article/10.1007/BF00143921">https://link.springer.com/article/10.1007/BF00143921</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reciprocal_temp_schedule(t_init: Union[int, float], t_final: Union[int, float]) -&gt; TempSchedule:
    &#34;&#34;&#34;
        Returns a reciprocal temperature schedule for given initial and final temperatures,
        from https://link.springer.com/article/10.1007/BF00143921
    &#34;&#34;&#34;
    if not isinstance(t_init, (int, float)):
        raise TypeError(f&#34;Expected int or float, found {type(t_init)}.&#34;)
    if not isinstance(t_final, (int, float)):
        raise TypeError(f&#34;Expected int or float, found {type(t_final)}.&#34;)
    def temp_schedule(it: int, num_iters: int) -&gt; float:
        num = t_init*t_final*(num_iters-1)
        denom = (t_final*num_iters-t_init)+(t_init-t_final)*(it+1)
        return num/denom
    return temp_schedule</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pauliopt.utils.Angle"><code class="flex name class">
<span>class <span class="ident">Angle</span></span>
<span>(</span><span>theta: Union[ForwardRef('<a title="pauliopt.utils.Angle" href="#pauliopt.utils.Angle">Angle</a>'), int, fractions.Fraction, decimal.Decimal, str])</span>
</code></dt>
<dd>
<div class="desc"><p>A container class for angles,
as rational multiples of PI modulo 2PI.</p>
<p>Copyright (C) 2019 - Hashberg Ltd</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Angle(AngleProtocol[&#34;Angle&#34;]):
    &#34;&#34;&#34;
        A container class for angles,
        as rational multiples of PI modulo 2PI.

        Copyright (C) 2019 - Hashberg Ltd
    &#34;&#34;&#34;

    _value: Fraction

    def __init__(self, theta: Union[&#34;Angle&#34;, AngleInitT]):
        if isinstance(theta, Angle):
            self._value = theta.value
        else:
            self._value = Fraction(theta)

    @property
    def value(self) -&gt; Fraction:
        &#34;&#34;&#34;
            The value of this angle as a fraction of PI.
        &#34;&#34;&#34;
        return self._value%2

    @property
    def as_root_of_unity(self) -&gt; Tuple[int, int]:
        &#34;&#34;&#34;
            Returns `(a,n)` where `n` is the smallest such
            that this angle is an $n$-th root of unity
            and `0 &lt;= a &lt; n` such that this is $e^{i 2\\pi \\frac{a}{n}}$
        &#34;&#34;&#34;
        num = self.value.numerator
        den = self.value.denominator
        a: int = num//2 if num%2 == 0 else num
        order: int = den if num % 2 == 0 else 2*den
        return (a, order)

    @property
    def order(self):
        &#34;&#34;&#34;
            The order of this angle as a root of unity.
        &#34;&#34;&#34;
        num = self.value.numerator
        den = self.value.denominator
        return den if num % 2 == 0 else 2*den

    def __pos__(self) -&gt; &#34;Angle&#34;:
        return self

    def __neg__(self) -&gt; &#34;Angle&#34;:
        return Angle(-self._value)

    def __add__(self, other: &#34;Angle&#34;) -&gt; &#34;Angle&#34;:
        if isinstance(other, Angle):
            return Angle(self._value + other._value)
        return NotImplemented

    def __sub__(self, other: &#34;Angle&#34;) -&gt; &#34;Angle&#34;:
        if isinstance(other, Angle):
            return Angle(self._value - other._value)
        return NotImplemented

    def __mul__(self, other: Union[int, Fraction, str]) -&gt; &#34;Angle&#34;:
        if isinstance(other, int):
            return Angle(self._value * Fraction(other))
        return NotImplemented

    def __rmul__(self, other: Union[int, Fraction, str]) -&gt; &#34;Angle&#34;:
        if isinstance(other, int):
            return Angle(self._value * Fraction(other))
        return NotImplemented

    def __truediv__(self, other: Union[int, Fraction, str]) -&gt; &#34;Angle&#34;:
        if isinstance(other, int):
            return Angle(self._value / Fraction(other))
        return NotImplemented

    def __hash__(self) -&gt; int:
        return hash(repr(self))

    def __str__(self) -&gt; str:
        num = self.value.numerator
        den = self.value.denominator
        if num == 0:
            return &#34;0&#34;
        if num == 1:
            if den == 1:
                return &#34;π&#34;
            return &#34;π/%d&#34;%den
        return &#34;%dπ/%d&#34;%(num, den)

    def __repr__(self) -&gt; str:
        num = self.value.numerator
        den = self.value.denominator
        if num == 0:
            return &#34;Angle.zero&#34;
        if num == 1:
            if den == 1:
                return &#34;Angle.pi&#34;
            return &#34;Angle.pi/%d&#34;%den
        return &#34;%d*Angle.pi/%d&#34;%(num, den)

    @property
    def repr_latex(self) -&gt; str:
        &#34;&#34;&#34;
            LaTeX math mode representation of this number.
        &#34;&#34;&#34;
        num = self.value.numerator
        den = self.value.denominator
        if num == 0:
            return &#34;0&#34;
        if num == 1:
            if den == 1:
                return &#34;\\pi&#34;
            return &#34;\\frac{\\pi}{%d}&#34;%den
        return &#34;\\frac{%d\\pi}{%d}&#34;%(num, den)

    def _repr_latex_(self):
        &#34;&#34;&#34;
            Magic method for IPython/Jupyter pretty-printing.
            See https://ipython.readthedocs.io/en/stable/api/generated/IPython.display.html
        &#34;&#34;&#34;
        return &#34;$%s$&#34;%self.repr_latex

    def __eq__(self, other):
        if not isinstance(other, Angle):
            return NotImplemented
        return self.value == other.value

    def __float__(self) -&gt; float:
        return float(self.value)*math.pi

    @overload
    @staticmethod
    def random(subdivision: int = 4, *,
               size: Literal[1]=1,
               rng_seed: Optional[int] = None) -&gt; &#34;Angle&#34;:
        ...

    @overload
    @staticmethod
    def random(subdivision: int = 4, *,
               size: int = 1,
               rng_seed: Optional[int] = None) -&gt; Union[&#34;Angle&#34;, Tuple[&#34;Angle&#34;, ...]]:
        ...

    @staticmethod
    def random(subdivision: int = 4, *, size: int = 1, rng_seed: Optional[int] = None):
        &#34;&#34;&#34;
            Generates a random angle with the given `subdivision`:
            `r * pi/subdivision` for random `r in range(2*subdivision)`.

            Requires `numpy`.
        &#34;&#34;&#34;
        if not isinstance(subdivision, int):
            raise TypeError()
        if not isinstance(size, int):
            raise TypeError()
        if subdivision &lt;= 0:
            raise ValueError(&#34;Subdivision must be positive.&#34;)
        if size &lt;= 0:
            raise ValueError(&#34;Size must be positive.&#34;)
        if rng_seed is not None and not isinstance(rng_seed, int):
            raise TypeError(&#34;RNG seed must be integer or &#39;None&#39;.&#34;)
        try:
            # pylint: disable = import-outside-toplevel, unused-import
            import numpy as np # type: ignore
        except ModuleNotFoundError as _:
            raise ModuleNotFoundError(&#34;You must install the &#39;numpy&#39; library.&#34;)
        rng = np.random.default_rng(seed=rng_seed)
        rs = rng.integers(2*subdivision, size=size)
        if size == 1:
            return Angle(Fraction(int(rs[0]), subdivision))
        return tuple(Angle(Fraction(int(r), subdivision)) for r in rs)

    zero: Final[&#34;Angle&#34;] # type: ignore
    &#34;&#34;&#34; A constant for the angle 0. &#34;&#34;&#34;

    pi: Final[&#34;Angle&#34;] # type: ignore
    &#34;&#34;&#34; A constant for the angle pi. &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pauliopt.utils.AngleProtocol" href="#pauliopt.utils.AngleProtocol">AngleProtocol</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pauliopt.utils.Angle.pi"><code class="name">var <span class="ident">pi</span> : Final[<a title="pauliopt.utils.Angle" href="#pauliopt.utils.Angle">Angle</a>]</code></dt>
<dd>
<div class="desc"><p>A constant for the angle pi.</p></div>
</dd>
<dt id="pauliopt.utils.Angle.zero"><code class="name">var <span class="ident">zero</span> : Final[<a title="pauliopt.utils.Angle" href="#pauliopt.utils.Angle">Angle</a>]</code></dt>
<dd>
<div class="desc"><p>A constant for the angle 0.</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="pauliopt.utils.Angle.random"><code class="name flex">
<span>def <span class="ident">random</span></span>(<span>subdivision: int = 4, *, size: int = 1, rng_seed: Union[int, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a random angle with the given <code>subdivision</code>:
<code>r * pi/subdivision</code> for random <code>r in range(2*subdivision)</code>.</p>
<p>Requires <code>numpy</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def random(subdivision: int = 4, *, size: int = 1, rng_seed: Optional[int] = None):
    &#34;&#34;&#34;
        Generates a random angle with the given `subdivision`:
        `r * pi/subdivision` for random `r in range(2*subdivision)`.

        Requires `numpy`.
    &#34;&#34;&#34;
    if not isinstance(subdivision, int):
        raise TypeError()
    if not isinstance(size, int):
        raise TypeError()
    if subdivision &lt;= 0:
        raise ValueError(&#34;Subdivision must be positive.&#34;)
    if size &lt;= 0:
        raise ValueError(&#34;Size must be positive.&#34;)
    if rng_seed is not None and not isinstance(rng_seed, int):
        raise TypeError(&#34;RNG seed must be integer or &#39;None&#39;.&#34;)
    try:
        # pylint: disable = import-outside-toplevel, unused-import
        import numpy as np # type: ignore
    except ModuleNotFoundError as _:
        raise ModuleNotFoundError(&#34;You must install the &#39;numpy&#39; library.&#34;)
    rng = np.random.default_rng(seed=rng_seed)
    rs = rng.integers(2*subdivision, size=size)
    if size == 1:
        return Angle(Fraction(int(rs[0]), subdivision))
    return tuple(Angle(Fraction(int(r), subdivision)) for r in rs)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="pauliopt.utils.Angle.as_root_of_unity"><code class="name">var <span class="ident">as_root_of_unity</span> : Tuple[int, int]</code></dt>
<dd>
<div class="desc"><p>Returns <code>(a,n)</code> where <code>n</code> is the smallest such
that this angle is an $n$-th root of unity
and <code>0 &lt;= a &lt; n</code> such that this is $e^{i 2\pi \frac{a}{n}}$</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def as_root_of_unity(self) -&gt; Tuple[int, int]:
    &#34;&#34;&#34;
        Returns `(a,n)` where `n` is the smallest such
        that this angle is an $n$-th root of unity
        and `0 &lt;= a &lt; n` such that this is $e^{i 2\\pi \\frac{a}{n}}$
    &#34;&#34;&#34;
    num = self.value.numerator
    den = self.value.denominator
    a: int = num//2 if num%2 == 0 else num
    order: int = den if num % 2 == 0 else 2*den
    return (a, order)</code></pre>
</details>
</dd>
<dt id="pauliopt.utils.Angle.order"><code class="name">var <span class="ident">order</span></code></dt>
<dd>
<div class="desc"><p>The order of this angle as a root of unity.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def order(self):
    &#34;&#34;&#34;
        The order of this angle as a root of unity.
    &#34;&#34;&#34;
    num = self.value.numerator
    den = self.value.denominator
    return den if num % 2 == 0 else 2*den</code></pre>
</details>
</dd>
<dt id="pauliopt.utils.Angle.repr_latex"><code class="name">var <span class="ident">repr_latex</span> : str</code></dt>
<dd>
<div class="desc"><p>LaTeX math mode representation of this number.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def repr_latex(self) -&gt; str:
    &#34;&#34;&#34;
        LaTeX math mode representation of this number.
    &#34;&#34;&#34;
    num = self.value.numerator
    den = self.value.denominator
    if num == 0:
        return &#34;0&#34;
    if num == 1:
        if den == 1:
            return &#34;\\pi&#34;
        return &#34;\\frac{\\pi}{%d}&#34;%den
    return &#34;\\frac{%d\\pi}{%d}&#34;%(num, den)</code></pre>
</details>
</dd>
<dt id="pauliopt.utils.Angle.value"><code class="name">var <span class="ident">value</span> : fractions.Fraction</code></dt>
<dd>
<div class="desc"><p>The value of this angle as a fraction of PI.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def value(self) -&gt; Fraction:
    &#34;&#34;&#34;
        The value of this angle as a fraction of PI.
    &#34;&#34;&#34;
    return self._value%2</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pauliopt.utils.AngleProtocol"><code class="flex name class">
<span>class <span class="ident">AngleProtocol</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A protocol for an angle type.</p>
<p>Copyright (C) 2019 - Hashberg Ltd</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AngleProtocol(Protocol[AngleT]):
    &#34;&#34;&#34;
        A protocol for an angle type.

        Copyright (C) 2019 - Hashberg Ltd
    &#34;&#34;&#34;

    def __neg__(self: AngleT) -&gt; AngleT:
        ...

    def __pos__(self: AngleT) -&gt; AngleT:
        ...

    def __add__(self: AngleT, other: AngleT) -&gt; AngleT:
        ...

    def __sub__(self: AngleT, other: AngleT) -&gt; AngleT:
        ...

    def __mul__(self: AngleT, other: Union[int, Fraction]) -&gt; AngleT:
        ...

    def __rmul__(self: AngleT, other: Union[int, Fraction]) -&gt; AngleT:
        ...

    def __truediv__(self: AngleT, other: Union[int, Fraction]) -&gt; AngleT:
        ...

    def __float__(self: AngleT) -&gt; float:
        ...</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pauliopt.utils.Angle" href="#pauliopt.utils.Angle">Angle</a></li>
</ul>
</dd>
<dt id="pauliopt.utils.SVGBuilder"><code class="flex name class">
<span>class <span class="ident">SVGBuilder</span></span>
<span>(</span><span>width: int, height: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Utility class for building certain SVG images.
Follows the <a href="https://en.wikipedia.org/wiki/Fluent_interface">Fluent interface pattern</a>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SVGBuilder:
    &#34;&#34;&#34;
        Utility class for building certain SVG images.
        Follows the [Fluent interface pattern](https://en.wikipedia.org/wiki/Fluent_interface).
    &#34;&#34;&#34;

    _width: int
    _height: int
    _fill: str
    _stroke: str
    _tags: List[str]

    def __init__(self, width: int, height: int):
        if not isinstance(width, int) or width &lt;= 0:
            raise TypeError(&#34;Width should be positive integer.&#34;)
        if not isinstance(height, int) or height &lt;= 0:
            raise TypeError(&#34;Height should be positive integer.&#34;)
        self._width = width
        self._height = height
        self._fill = &#34;none&#34;
        self._stroke = &#34;black&#34;
        self._tags = []

    @property
    def width(self) -&gt; int:
        &#34;&#34;&#34;
            The figure width.
        &#34;&#34;&#34;
        return self._width

    @property
    def height(self) -&gt; int:
        &#34;&#34;&#34;
            The figure height.
        &#34;&#34;&#34;
        return self._height

    @property
    def tags(self) -&gt; Sequence[str]:
        &#34;&#34;&#34;
            The current sequence of tags.
        &#34;&#34;&#34;
        return self._tags

    def line(self, fro: Tuple[int, int], to: Tuple[int, int]) -&gt; &#34;SVGBuilder&#34;:
        &#34;&#34;&#34;
            Draws a line from given coordinates to given coordinates.
        &#34;&#34;&#34;
        _validate_vec2(fro)
        _validate_vec2(to)
        fx, fy = fro
        tx, ty = to
        tag = (f&#39;&lt;path fill=&#34;none&#34; stroke=&#34;black&#34;&#39;
               f&#39; d=&#34;M {fx}, {fy} L {tx}, {ty}&#34;/&gt;&#39;)
        self._tags.append(tag)
        return self

    def circle(self, centre: Tuple[int, int], r: int, fill: str) -&gt; &#34;SVGBuilder&#34;:
        &#34;&#34;&#34;
            Draws a circle with given centre and radius.
        &#34;&#34;&#34;
        _validate_vec2(centre)
        if not isinstance(fill, str):
            raise TypeError(&#34;Fill must be string.&#34;)
        x, y = centre
        tag = (f&#39;&lt;circle fill=&#34;{fill}&#34; stroke=&#34;black&#34;&#39;
               f&#39; cx=&#34;{x}&#34; cy=&#34;{y}&#34; r=&#34;{r}&#34;/&gt;&#39;)
        self._tags.append(tag)
        return self

    def text(self, pos: Tuple[int, int], text: str, *, font_size: int = 10) -&gt; &#34;SVGBuilder&#34;:
        &#34;&#34;&#34;
            Draws text at the given position (stroke/fill not used).
        &#34;&#34;&#34;
        _validate_vec2(pos)
        if not isinstance(text, str):
            raise TypeError(&#34;Text must be string.&#34;)
        if not isinstance(font_size, int) or font_size &lt;= 0:
            raise TypeError(&#34;Font size must be positive integer.&#34;)
        x, y = pos
        tag = f&#39;&lt;text x=&#34;{x}&#34; y=&#34;{y+font_size//4}&#34; font-size=&#34;{font_size}&#34;&gt;{text}&lt;/text&gt;&#39;
        self._tags.append(tag)
        return self

    def __repr__(self) -&gt; str:
        body = &#34;\n&#34;.join(self._tags)
        return f&#39;&lt;svg width=&#34;{self.width}&#34; height=&#34;{self.height}&#34;&gt;{body}&lt;/svg&gt;&#39;</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pauliopt.utils.SVGBuilder.height"><code class="name">var <span class="ident">height</span> : int</code></dt>
<dd>
<div class="desc"><p>The figure height.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def height(self) -&gt; int:
    &#34;&#34;&#34;
        The figure height.
    &#34;&#34;&#34;
    return self._height</code></pre>
</details>
</dd>
<dt id="pauliopt.utils.SVGBuilder.tags"><code class="name">var <span class="ident">tags</span> : Sequence[str]</code></dt>
<dd>
<div class="desc"><p>The current sequence of tags.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def tags(self) -&gt; Sequence[str]:
    &#34;&#34;&#34;
        The current sequence of tags.
    &#34;&#34;&#34;
    return self._tags</code></pre>
</details>
</dd>
<dt id="pauliopt.utils.SVGBuilder.width"><code class="name">var <span class="ident">width</span> : int</code></dt>
<dd>
<div class="desc"><p>The figure width.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def width(self) -&gt; int:
    &#34;&#34;&#34;
        The figure width.
    &#34;&#34;&#34;
    return self._width</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pauliopt.utils.SVGBuilder.circle"><code class="name flex">
<span>def <span class="ident">circle</span></span>(<span>self, centre: Tuple[int, int], r: int, fill: str) ‑> <a title="pauliopt.utils.SVGBuilder" href="#pauliopt.utils.SVGBuilder">SVGBuilder</a></span>
</code></dt>
<dd>
<div class="desc"><p>Draws a circle with given centre and radius.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def circle(self, centre: Tuple[int, int], r: int, fill: str) -&gt; &#34;SVGBuilder&#34;:
    &#34;&#34;&#34;
        Draws a circle with given centre and radius.
    &#34;&#34;&#34;
    _validate_vec2(centre)
    if not isinstance(fill, str):
        raise TypeError(&#34;Fill must be string.&#34;)
    x, y = centre
    tag = (f&#39;&lt;circle fill=&#34;{fill}&#34; stroke=&#34;black&#34;&#39;
           f&#39; cx=&#34;{x}&#34; cy=&#34;{y}&#34; r=&#34;{r}&#34;/&gt;&#39;)
    self._tags.append(tag)
    return self</code></pre>
</details>
</dd>
<dt id="pauliopt.utils.SVGBuilder.line"><code class="name flex">
<span>def <span class="ident">line</span></span>(<span>self, fro: Tuple[int, int], to: Tuple[int, int]) ‑> <a title="pauliopt.utils.SVGBuilder" href="#pauliopt.utils.SVGBuilder">SVGBuilder</a></span>
</code></dt>
<dd>
<div class="desc"><p>Draws a line from given coordinates to given coordinates.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def line(self, fro: Tuple[int, int], to: Tuple[int, int]) -&gt; &#34;SVGBuilder&#34;:
    &#34;&#34;&#34;
        Draws a line from given coordinates to given coordinates.
    &#34;&#34;&#34;
    _validate_vec2(fro)
    _validate_vec2(to)
    fx, fy = fro
    tx, ty = to
    tag = (f&#39;&lt;path fill=&#34;none&#34; stroke=&#34;black&#34;&#39;
           f&#39; d=&#34;M {fx}, {fy} L {tx}, {ty}&#34;/&gt;&#39;)
    self._tags.append(tag)
    return self</code></pre>
</details>
</dd>
<dt id="pauliopt.utils.SVGBuilder.text"><code class="name flex">
<span>def <span class="ident">text</span></span>(<span>self, pos: Tuple[int, int], text: str, *, font_size: int = 10) ‑> <a title="pauliopt.utils.SVGBuilder" href="#pauliopt.utils.SVGBuilder">SVGBuilder</a></span>
</code></dt>
<dd>
<div class="desc"><p>Draws text at the given position (stroke/fill not used).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def text(self, pos: Tuple[int, int], text: str, *, font_size: int = 10) -&gt; &#34;SVGBuilder&#34;:
    &#34;&#34;&#34;
        Draws text at the given position (stroke/fill not used).
    &#34;&#34;&#34;
    _validate_vec2(pos)
    if not isinstance(text, str):
        raise TypeError(&#34;Text must be string.&#34;)
    if not isinstance(font_size, int) or font_size &lt;= 0:
        raise TypeError(&#34;Font size must be positive integer.&#34;)
    x, y = pos
    tag = f&#39;&lt;text x=&#34;{x}&#34; y=&#34;{y+font_size//4}&#34; font-size=&#34;{font_size}&#34;&gt;{text}&lt;/text&gt;&#39;
    self._tags.append(tag)
    return self</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pauliopt.utils.TempSchedule"><code class="flex name class">
<span>class <span class="ident">TempSchedule</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Protocol for a temperature schedule.
The temperature is a number (int or float) computed from the iteration
number <code>it</code> (starting from 0) and the total number of iterations <code>num_iter</code>
(passed as a keyword argument).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TempSchedule(Protocol):
    &#34;&#34;&#34;
        Protocol for a temperature schedule.
        The temperature is a number (int or float) computed from the iteration
        number `it` (starting from 0) and the total number of iterations `num_iter`
        (passed as a keyword argument).
    &#34;&#34;&#34;

    def __call__(self, it: int, num_iters: int) -&gt; float:
        ...</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="pauliopt.utils.TempScheduleProvider"><code class="flex name class">
<span>class <span class="ident">TempScheduleProvider</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Protocol for a function constructing a temperature schedule
from an initial and final temperatures.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TempScheduleProvider(Protocol):
    &#34;&#34;&#34;
        Protocol for a function constructing a temperature schedule
        from an initial and final temperatures.
    &#34;&#34;&#34;

    def __call__(self, t_init: Union[int, float], t_final: Union[int, float]) -&gt; TempSchedule:
        ...</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pauliopt" href="index.html">pauliopt</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="pauliopt.utils.AngleT" href="#pauliopt.utils.AngleT">AngleT</a></code></li>
<li><code><a title="pauliopt.utils.StandardTempSchedule" href="#pauliopt.utils.StandardTempSchedule">StandardTempSchedule</a></code></li>
<li><code><a title="pauliopt.utils.StandardTempScheduleName" href="#pauliopt.utils.StandardTempScheduleName">StandardTempScheduleName</a></code></li>
<li><code><a title="pauliopt.utils.StandardTempSchedules" href="#pauliopt.utils.StandardTempSchedules">StandardTempSchedules</a></code></li>
<li><code><a title="pauliopt.utils.pi" href="#pauliopt.utils.pi">pi</a></code></li>
<li><code><a title="pauliopt.utils.π" href="#pauliopt.utils.π">π</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pauliopt.utils.geometric_temp_schedule" href="#pauliopt.utils.geometric_temp_schedule">geometric_temp_schedule</a></code></li>
<li><code><a title="pauliopt.utils.linear_temp_schedule" href="#pauliopt.utils.linear_temp_schedule">linear_temp_schedule</a></code></li>
<li><code><a title="pauliopt.utils.log_temp_schedule" href="#pauliopt.utils.log_temp_schedule">log_temp_schedule</a></code></li>
<li><code><a title="pauliopt.utils.reciprocal_temp_schedule" href="#pauliopt.utils.reciprocal_temp_schedule">reciprocal_temp_schedule</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pauliopt.utils.Angle" href="#pauliopt.utils.Angle">Angle</a></code></h4>
<ul class="two-column">
<li><code><a title="pauliopt.utils.Angle.as_root_of_unity" href="#pauliopt.utils.Angle.as_root_of_unity">as_root_of_unity</a></code></li>
<li><code><a title="pauliopt.utils.Angle.order" href="#pauliopt.utils.Angle.order">order</a></code></li>
<li><code><a title="pauliopt.utils.Angle.pi" href="#pauliopt.utils.Angle.pi">pi</a></code></li>
<li><code><a title="pauliopt.utils.Angle.random" href="#pauliopt.utils.Angle.random">random</a></code></li>
<li><code><a title="pauliopt.utils.Angle.repr_latex" href="#pauliopt.utils.Angle.repr_latex">repr_latex</a></code></li>
<li><code><a title="pauliopt.utils.Angle.value" href="#pauliopt.utils.Angle.value">value</a></code></li>
<li><code><a title="pauliopt.utils.Angle.zero" href="#pauliopt.utils.Angle.zero">zero</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pauliopt.utils.AngleProtocol" href="#pauliopt.utils.AngleProtocol">AngleProtocol</a></code></h4>
</li>
<li>
<h4><code><a title="pauliopt.utils.SVGBuilder" href="#pauliopt.utils.SVGBuilder">SVGBuilder</a></code></h4>
<ul class="two-column">
<li><code><a title="pauliopt.utils.SVGBuilder.circle" href="#pauliopt.utils.SVGBuilder.circle">circle</a></code></li>
<li><code><a title="pauliopt.utils.SVGBuilder.height" href="#pauliopt.utils.SVGBuilder.height">height</a></code></li>
<li><code><a title="pauliopt.utils.SVGBuilder.line" href="#pauliopt.utils.SVGBuilder.line">line</a></code></li>
<li><code><a title="pauliopt.utils.SVGBuilder.tags" href="#pauliopt.utils.SVGBuilder.tags">tags</a></code></li>
<li><code><a title="pauliopt.utils.SVGBuilder.text" href="#pauliopt.utils.SVGBuilder.text">text</a></code></li>
<li><code><a title="pauliopt.utils.SVGBuilder.width" href="#pauliopt.utils.SVGBuilder.width">width</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pauliopt.utils.TempSchedule" href="#pauliopt.utils.TempSchedule">TempSchedule</a></code></h4>
</li>
<li>
<h4><code><a title="pauliopt.utils.TempScheduleProvider" href="#pauliopt.utils.TempScheduleProvider">TempScheduleProvider</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>